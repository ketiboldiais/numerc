<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>haskell</title>
		<!-- <base href="http://127.0.0.1:5500/csfoundations/" /> -->
		<link rel="stylesheet" href="css/csfoundations.css" />
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous" />
	</head>
	<body>
		<header>
			<h1>Computer Science Fundamentals</h1>
		</header>

		<main>
			<article id="haskell_programming" class="grid" data-colcade="columns: .grid-col, items: grid-item">
				<!-- grid -->
					<div class="grid-col grid-col--1"></div>
					<div class="grid-col grid-col--2"></div>
					<div class="grid-col grid-col--3"></div>
					<div class="grid-col grid-col--4"></div>
				<section id="haskell_intro" class="grid-item">
					<h2>Functional Programming with Haskell</h2>
					<p>Haskell has a reputation for being a difficult programming language. That difficulty is not so much in the language itself, but rather how its taught. Compared to other programming languages, Haskell is a <span class="italicsText">functional programming language</span>. We will see what this means as we proceed through the next section, but the gist of it is: Haskell is often perceived as difficult because introductory programming courses, by and large, emphasize imperative or object-oriented programming. Functional programming is effectively an about-face.</p>

					<p>There is nothing wrong with object-oriented or imperative programming, but there are numerous problems that are best handled by functional programming approaches. We study those approaches in these next sections.</p>

					<pre class="language-haskell"><code>
						main :: IO ()
						main = putStrLn "Hello, world!"
					</code></pre>

					<p><span class="monoText">Haskell</span> is what we might call the purest of all functional programming languages. We use Haskell because everything we learn in these materials is directly applicable to all other functional programming languages &mdash; Scala, Swift, Rust, Go, and many more.</p>
				</section>

				<section id="principles_of_functional_programming" class="grid-item">
					<p><span class="topic">Programming Language Families.</span> Programming languages generally fall into two broad categories: (1) <span class="italicsText">imperative languages</span>; and (2) <span class="italicsText">declarative languages</span>. Imperative languages include languages like Java, C, and Pascal. Some of these languages are object-oriented langauges, like Java, Python, and JavaScript. Others are procedural, like C, Pascal, and Fortran. The common trait across these languages: Programs instruct the computer <span class="italicsText">how</span> to perform a computation.</p>

					<p>In contrast are the <span class="italicsText">declarative languages</span> &mdash; languages like Haskell, Lisp, ML, and Prolog. Some declarative languages are <span class="italicsText">functional programming languages</span>, like Haskell, Swift, and Scheme. Other declarative languages are <span class="italicsText">logic programming languages</span>, the most famous of which is Prolog.</p>

					<p>These distinctions, however, are not always clear cut. For example, the latest updates to Java have brought the language closer to functional programming. Similarly, Swift is a functional programming language, but allows object-oriented programming. Where imperative languages instruct the computer <span class="italicsText">how</span> to perform a computation, declarative languages merely state, or describe the problem, and leave the computation to the computer.</p>

					<p>Which language, or paradigm, is better depends on the task at hand. For example, if we are writing a program for a life-support machine or jet fighter, we might prefer a procedural language like Pascal or C, since human lives are at risk. On other hand, if we are writing a fluid simulation program &mdash; a highly resource intensive process &mdash; then a functional programming approach would be ideal (as we will soon see).</p>

					<p><span class="topic">Focus of Functional Programming.</span> What makes functional programming so different from other programming paradigms? In functional programming, the focus is on <span class="italicsText">functions</span> and <span class="italicsText">values</span>, rather than <span class="italicsText">assignments</span> and <span class="italicsText">pointers</span>. In imperative programming languages like C, the most important statement is assignment &mdash; binding values to variables &mdash; storing values at a memory address &mdash; and changing the contents of those memory addresses. These values are then organized to form large data structures by way of pointers.</p>

					<p>In pure functional programming languages like Haskell, there is no assigment, and there are no pointers. We think <span class="underlineText">entirely</span> in functions. Changing our thinking to the functional approach can vastly improve our programming skills &mdash; we stop focusing on what the computer <span class="italicsText">should</span> do, and focus instead on what the computer <span class="italicsText">will</span> do. This is accomplished by the defining characteristic of functional programming: the absence of <span class="italicsText">side effects</span>. Good functional code does not rely on any data outside the current function, and it will not change data that exists outside the current function. Here is a Python example:</p>

					<p>Here is a function that is not functional:</p>

					<pre class="language-python"><code>
						a = 0
						def increment():
							a
							a += 1
					</code></pre>

					<p>And here is a function that <span class="underlineText">is</span> functional:</p>

					<pre class="language-python"><code>
						def increment(a):
							return a + 1
					</code></pre>

					<p>In functional programming, we write <span class="italicsText">declarative statements</span> &mdash; statements only stating a fact, what we want, but not necessarily <span class="italicsText">how</span> to obtain what we want &mdash; rather than imperative statements &mdash; statements expressing <span class="italicsText">how</span> to obtain what we want, step-by-step.</p>
					
					<div class="compare">
						<div>
							<p class="subheading">Declarative Programming</p>
							<p>Give me everything in this list that is even.</p>
						</div>

						<div>
							<p class="subheading">Imperative Programming</p>
							<p>Step through this list. Look at the element. If <span class="monoText">element % 2 == 0</span>, include it in the results list. Give me the results list when you are done.</p>
						</div>
					</div>

				</section>

				<section id="variable_declarations" class="grid-item">
					<p><span class="topic">Variable Declarations.</span> The following is a variable declaration in Haskell:</p>
					<pre class="language-haskell"><code>
						x :: int
					</code></pre>
					<p>The above is just a declaration &mdash; let there be an <span class="monoText">x</span> of type <span class="monoText">int</span>. We can then define <span class="monoText">x</span> in the next line:</p>
					<pre class="language-haskell"><code>
						x :: int
						x = 5
					</code></pre>
					<p>The variable <span class="monoText">x</span> now has the value <span class="monoText">5</span> <span class="italicsText">forever</span>. It will never be changed. This is a critical point to understand. In Haskell, once a variable has been defined, it <span class="underlineText">never</span> changes. Anywhere in the program <span class="monoText">x</span> appears, it <span class="underlineText">will</span> be <span class="monoText">5</span>. This is very different from languages like Java and C:</p>
					<pre class="language-java"><code>
						int x = 5;
						x = x + 1;
					</code></pre>
					<p>The code above will compile just fine in Java or C. Haskell, however, prohibits precisely this behavior.</p>

					<p><span class="topic">Haskell Functions.</span> Here is a function in Haskell:</p>
					<pre class="language-haskell"><code>
						f :: Int -> Int -> Int
						f x y = 2*x + y

						f 42 16 // returns 100, always
					</code></pre>
					<p>The code above says, <span class="monoText">f</span> is a function that takes an <span class="monoText">Int</span> (the first <span class="monoText">Int</span>), then it returns a function that takes <span class="monoText">Int</span>, and then it returns an <span class="monoText">Int</span>.</p>
					<p>The next line, <span class="monoText">f x y = 2*x + y</span>, is the <span class="italicsText">definition</span> of <span class="monoText">f</span>.</p>
					<p>Thus, <span class="monoText">f 42 16</span> will always be <span class="monoText">100</span>. Whenever we see <span class="monoText">f <span class="monoText">int</span> <span class="monoText">int</span></span>, we can <span class="italicsText">always</span> replace it with the function definition above.</p>
					<p>As we can see, in Haskell, the return value of a function <span class="underlineText">only</span> depends on its inputs, nothing else.</p>

					<p><span class="topic">Lazy Computation.</span> Haskell is a lazy programming language &mdash; it does not evaluate an expression until it is absolutely necessary. If <span class="monoText">x</span> is some function that performs a resource-intensive computation, Haskell will execute <span class="monoText">x</span> if, and only if, we ourselves use <span class="monoText">x</span>.</p>
					<p>This is in contrast to languages like Java. If we write something like <span class="monoText">x = intenseComputation</span>, Java will evaluate <span class="monoText">intenseComputation</span> and store it in memory. In contrast, all that Haskell does is &#8220;remember&#8221; that <span class="monoText">x</span> is some <span class="monoText">intenseComputation</span>. In other words, Haskell takes a look at it, notes it, and moves on. If, and only if, we explicitly require <span class="monoText">x</span>, does Haskell recall <span class="monoText">x</span> and actually perform the computation.</p>
				</section>

				<section id="lambda_calculus" class="grid-item">
					<h3>Lambda Calculus, Functions</h3>
					<p>A <span class="term">calculus</span> is a method of calculation or reasoning. <span class="term">Lambda calculus</span> is one such calculus; it is a method of reasoning about <span class="italicsText">computation</span>. We start with the bedrock concept for this method of reasoning&mdash;the <span class="term">function</span>.</p>

					<p>In functional programming, we rely on <span class="italicsText">only</span> functions. Programming functions are similar to mathematical functions, with a few key differences we will see later. </p>

					<p>Functional programs, at their core, are a combination of <span class="boldText">expressions</span>. An <span class="italicsText">expression</span> is a syntactic entity that can be evaluated to determine its value. For example, values, variables, and functions are all expressions. Some expressions are <span class="term">reducible expressions</span> (commonly called <span class="term">redex</span>) &mdash; expressions that can be broken down into smaller expressions. Others are in <span class="term">normal form</span>, meaning they cannot be broken down any further.</p>

					<p>Functions, however, are a special kind of expression &mdash; they are expressions applied to an argument, or input, and once applied, can be <span class="italicsText">reduced</span> and <span class="italicsText">evaluated</span>.</p>

					<p>In functional programming languages like Haskell, functions are <span class="term">first-class</span>: they can be used as values and passed as inputs, called <span class="term">arguments</span>, to other functions. Haskell itself is the epitome of functional programming &mdash; it is a <span class="term">pure functional language</span>. The word <span class="italicsText">pure</span> in computer science describes the level of a language's <span class="term">referential transparency</span>. This is the property where, given a function, the function will always output the same result for the same inputs.</p>

					<p><span class="topic">Functions.</span> Mathematically, a function is a relation between a set of elements, called the <span class="italicsText">domain</span>, to another set of elements, called the <span class="italicsText">codomain</span>. Alternatively, from a computer science perspective: A function is a procedure that takes inputs and mapes those inputs to outputs. For example, addition can be seen as a function: it takes two inputs, and maps the two inputs to an output &mdash; the sum of the two inputs. Here is another example:</p>

					<figure class="math-display">
						<div>
							<p>${f(0) \mapsto a}$</p>
							<p>${f(1) \mapsto b}$</p>
							<p>${f(2) \mapsto c}$</p>
						</div>
					</figure>

					<p>In the function ${f}$ above, the input set is ${\{ 1, 2, 3 \},}$ and the output set is ${\{ a, b, c \}.}$ A crucial point: The function ${f}$ <span class="underlineText">will always</span> return exactly one output for one input, no exceptions. The core idea is: one output per input. The following is not a function:</p>

					<figure class="math-display">
						<div>
							<p>${v(1) \mapsto x}$</p>
							<p>${v(1) \mapsto y}$</p>
							<p>${v(1) \mapsto z}$</p>
						</div>
					</figure>

					<p>This harkens back to the rule of referential transparency &mdash; given the same input, the output should be predictable. However, do not confuse the idea of one output per input with the idea one one <span class="italicsText">unique</span> output per input. The function ${f}$ might have a set of inputs, ${\{ 3, 4, 5 \},}$ that map to the same output ${d.}$ For example, the following is a function:</p>

					<figure class="math-display">
						<div>
							<p>${h(1) \mapsto w}$</p>
							<p>${h(2) \mapsto w}$</p>
							<p>${h(3) \mapsto w}$</p>
						</div>
					</figure>

					<p>It is perfectly valid for a function's different inputs to return the same output. It is never valid for a function's input to return more than one output. The controlling question: Is the relationship predictable? To be predictable, every input must have one, and only one, output.</p>

					<p>The function itself defines the relationship between the inputs and the outputs. In the previous example, we gave no such relationship. When we explicitly provide that relationship, we <span class="italicsText">define</span> the function:</p>

					<figure class="math-display">
						<div>
							<p>${f(x) = x^2}$</p>
						</div>
					</figure>

					<p>If we pass the inputs ${\{ 1, 2, 3, 4 \}:}$</p>

					<figure class="math-display">
						<div>
							<p>${f(1) \mapsto  1^2 = 1}$</p>
							<p>${f(2) \mapsto  2^2 = 4}$</p>
							<p>${f(3) \mapsto  3^2 = 9}$</p>
							<p>${f(4) \mapsto  4^2 = 16}$</p>
						</div>
					</figure>
				</section>

				<section id="lambda_terms" class="grid-item">
					<h4>Lambda Terms</h4>
					<p>There are three basic components, called <span class="term">lambda terms</span>, to a lambda function:</p>

					<ul>
						<li><span class="italicsText">expressions</span>,</li>
						<li><span class="italicsText">variables</span>, and</li>
						<li><span class="italicsText">abstractions</span></li>
					</ul>

					<p><span class="term">Expressions</span> is the superset of all the components &mdash; expressions, variables, and abstractions. The simplest expression is a single variable. A <span class="term">variable</span> has no meaning or value; a variable is simply a name for potential inputs to functions.</p>

					<p>An <span class="term">abstraction</span> is a function. The function itself has two components:</p>
					<ul>
						<li>a <span class="italicsText">head</span>, and</li>
						<li>a <span class="italicsText">body</span>.</li>
					</ul>

					<p>A function's head is a lambda, ${\lambda,}$ followed by a variable name. The body of a function is another expression. Here is a simple function in lambda terms:</p>
					<figure class="math-display">
						<div>
							<p>${\lambda x.x}$</p>
						</div>
					</figure>
					<p>The variable named in the head, ${x,}$ is called the <span class="italicsText">parameter</span>. It <span class="italicsText">binds</span> all instances of ${x}$ in the function's body. Variables inside the body that are not bound in the head are called <span class="term">free variables</span> (more on this later). What does <span class="italicsText">bind</span> mean? It means that when we pass an argument into the function, each ${x}$ in the function's body will have the value of the argument. Separating the head from the body is a dot.</p>
					<figure><img src="images/lambda_terms.svg" alt="lambda terms" class="twenty-p" loading="lazy"></figure>
					<p>When we write ${f(x) = x^2,}$ the function has a name &mdash; ${f.}$ We call such functions <span class="term">named functions</span>. In contrast, the function ${\lambda x.x}$ has no name; it is an <span class="term">anonymous function</span>. The difference? We can call named functions by referencing its name, but we cannot do the same with anonymous functions.</p>
					<!-- Alpha Equivalence -->
						<p><span class="topic">Alpha Equivalence.</span> The variable ${x}$ has no meaning other than its role in a single expression. Because of this, the actual variable used is irrelevant when comparing functions similarly structured. For example, ${\lambda x.x}$ is the same function as:</p>
						<figure class="math-display">
							<div>
								<p>${\lambda a.a}$</p>
								<p>${\lambda g.g}$</p>
								<p>${\lambda w.w}$</p>
							</div>
						</figure>
						<p>The functions above are all <span class="italicsText">alpha equivalent</span>.</p>
					<!-- Beta Reduction -->
						<p><span class="topic">Beta Reduction.</span> The expression we input to a function is called an <span class="term">argument</span>. Once an argument is input to a function, the function is <span class="italicsText">applied</span> to the argument &mdash; all instances of the bound variables (the parameters) are substituted with the input expression inside the function's body. When these bound variables are substituted, they become bound to the input expression. Because they are now bound to the input expressions, the function's head is eliminated, since its only purpose was to bind a variable. We call this process <span class="term">beta reduction</span>.</p>
						<p>For example:</p>
						<figure class="math-display">
							<ul class="syntax">
								<li>${\lambda x.x}$</li>
								<li>${\darr}$</li>
								<li>${(\lambda x.x) 2}$</li>
								<li>${\darr}$</li>
								<li>${2}$</li>
							</ul>
						</figure>
						<p>Here, there is only one bound variable, ${x,}$ so applying the function to the input expression 2 returns 2. We call this the <span class="term">identity function</span> &mdash; a function that consumes a single argument ${x,}$ and returns the same argument ${x.}$</p>
						<p>In lambda calculus, we use parentheses to clarify the function's lambda terms. Here is another lambda function:</p>
						<figure class="math-display">
							<div>
								<p>${(\lambda x.x+1)}$</p>
							</div>
						</figure>
						<p>Passing the input expression 2:</p>
						<figure class="math-display">
							<ul class="syntax">
								<li>${(\lambda x.x+1) 2}$</li>
								<li>${\darr}$</li>
								<li>${2 + 1}$</li>
								<li>${\darr}$</li>
								<li>${3}$</li>
							</ul>
						</figure>
						<p>Beta reduction continues as long as there are (1) heads or (b) lambdas (i.e., abstractions). Once there are no more heads and no more lambdas, beta reduction ceases.</p>
					<!-- Lambda abstractions as arguments -->
					<p><span class="topic">Abstractions as Arguments.</span> We can also pass lambda abstractions as inputs:</p>
					<figure class="math-display">
						<div>
							<p>${(\lambda x.x)(\lambda y.y)}$</p>
						</div>
					</figure>
					<p>When we pass a lambda abstraction as an input, we substitute ${x}$ with the lambda abstraction, just as we would with numbers. We can denote this process with ${[x \coloneqq z,]}$ meaning, ${z}$ will substitute all occurrences of ${x.}$ In this case, ${z}$ is the abstraction ${\lambda y.y.}$ The beta reduction looks like:</p>
					<figure class="math-display">
						$$
							\begin{aligned}
								(\lambda x.x)(\lambda y.y)& \\
								[x \coloneqq (\lambda y.y)]& \\
								\lambda y.y& 
							\end{aligned}
						$$
					</figure>
					<!-- Additional arguments -->
					<p><span class="topic">Additional Arguments.</span> A lambda abstraction can take additional arguments:</p>
					<figure class="math-display">
						<div>
							<p>${(\lambda x.x)(\lambda y.y)z}$</p>
						</div>
					</figure>
					<p>How do we reduce the lambda abstraction above? By following this rule: Applications are <span class="underlineText">left-associative</span>. This means, if there are no parentheses, then the abstractions group to the left. Thus, the abstraction above is evaluated as:</p>
					<figure class="math-display">
						<div>
							<p>${((\lambda x.x)(\lambda y.y))z}$</p>
						</div>
					</figure>
					<p>The beta reduction is thus:</p>
					<figure class="math-display">
						$$
							\begin{aligned}
								((\lambda x.x)(\lambda y.y))z& \\
								[x \coloneqq (\lambda y.y)]& \\
								(\lambda y.y)z& \\
								[y \coloneqq z]& \\
								z&
							\end{aligned}
						$$
					</figure>

					<!-- Free Variables -->
					<p><span class="topic">Free Variables.</span> The body of a function may sometimes contain a variable that is not defined in the function's head. For example, the general form of a logarithmic function:</p>
					<figure class="math-display">
						<div>
							<p>${t(x) = \log_{b}(x)}$</p>
						</div>
					</figure>
					<p>The only variable defined in the head is ${x,}$ but ${b}$ is another variable, denoting the <span class="italicsText">base</span>. In lambda terms, we might have a function:</p>
					<figure class="math-display">
						<div>
							<p>${\lambda x.xy}$</p>
						</div>
					</figure>
					<p>As we briefly mentioned in a previous section, such variables &mdash; those not defined in the function's head &mdash; are called <span class="italicsText">free variables</span>. When we reduce the abstraction above, there is nothing we can do to the free variable ${y;}$ it is <span class="term">irreducible</span>. Suppose we encountered the lambda abstraction ${(\lambda x.xy)z.}$ The beta reduction:</p>
					<figure class="math-display">
						$$
							\begin{aligned}
								(\lambda x.xy)z& \\
								(\lambda[x \coloneqq z].xy)& \\
								zy&
							\end{aligned}
						$$
					</figure>
					<p>The second step in the reduction above merits careful attention. Since ${x}$ is a bound variable, all instances of ${x}$ in the body are substituted with ${z.}$ Hence the inclusion of ${[x \coloneqq z]}$ inside the function's head. Only then do we proceed to the third step, where we replace all instances of ${x}$ in the body with ${z,}$ and eliminate the head.</p>
					<p>Of note, the rule of alpha equivalence does not apply to lambdas with free variables. In other words, ${(\lambda x.xz)}$ is not equivalent to ${\lambda x.xy.}$ This is because ${z}$ and ${y}$ are not bound in the head, and as such, are both capable of meaning different things. If, however, we wrote ${\lambda xz.xz}$ and ${\lambda xy.xy}$ (binding ${y}$ and ${z}$ in the function's head), then alpha equivalence applies, since ${y}$ and ${z}$ are no longer free variables. But, the lambdas ${\lambda x.xy}$ and ${\lambda z.zy}$ are alpha equivalent, because both lambdas leave the free variables alone.</p>

					<!-- Multiple Arguments -->
					<p><span class="topic">Multiple Arguments.</span> A lambda can bind one, and only one parameter, and can only accept one, and only one, argument. If a function requires multiple arguments, then its corresponding lambda must have <span class="underlineText">multiple and nested</span> heads. How are such lambdas evaluated? By eliminating the first (leftmost) head, then the next, then the next, etc. We call this process <span class="term">currying</span>. Here is a lambda that represents a function consuming multiple arguments:</p>
					<figure class="math-display">
						<div>
							<p>${\lambda x.(\lambda y.xy)}$</p>
						</div>
					</figure>
					<p>As a matter of short-hand syntax, we write the lambda above more concisely as:</p>
					<figure class="math-display">
						<div>
							<p>${\lambda xy.xy}$</p>
						</div>
					</figure>
					<p>Do not confuse this short-hand syntax as implying a lambda whose head binds multiple parameters. The expression above should always be read as a lambda with multiple, nested heads: ${\lambda x(\lambda y.xy).}$ Now, when we evaluate the argument, we first bind ${x,}$ the variable bound by the outermost lambda. For example, suppose the lambda ${(\lambda xy.xy) 1 \space 2}$ The beta reduction:</p>
					<figure class="math-display">
						$$
							\begin{aligned}
								(\lambda xy.xy) 1 \space \space 2& \\
								(\lambda x (\lambda y.xy)) 1 \space \space 2& \\
								[x \coloneqq 1]& \\
								(\lambda y.1y) \space 2& \\
								[y \coloneqq 2]& \\
								1 \space \space 2&
							\end{aligned}
							
						$$
					</figure>
					<p>Here is another example:</p>
					<div class="mproof">
						<div class="premises">
							<ul>
								<li>${\lambda xy.xy}$</li>
								<li>the lambda</li>
							</ul>
							<ul>
								<li>${(\lambda xy.xy)(\lambda z.a) \space 1}$</li>
								<li>arguments ${(\lambda z.a)}$ and ${1}$ passed</li>
							</ul>
							<ul>
								<li>${(\lambda x (\lambda y.xy)) (\lambda z.a) 1}$</li>
								<li>rewrite as multiple, nested heads</li>
							</ul>
							<ul>
								<li>${[x \coloneqq (\lambda z.a)]}$</li>
								<li>bind ${x}$</li>
							</ul>
							<ul>
								<li>${(\lambda y.(\lambda z.a)y) 1}$</li>
								<li>eliminate first head</li>
							</ul>
							<ul>
								<li>${[y \coloneqq 1]}$</li>
								<li>bind ${y}$</li>
							</ul>
							<ul>
								<li>${(\lambda z.a) 1}$</li>
								<li>eliminate second head</li>
							</ul>
							<ul>
								<li>${[z \coloneqq 1]}$</li>
								<li>bind ${z}$</li>
							</ul>
							<ul>
								<li>${a}$</li>
								<li>no ${z}$ in the body of the function, so there is nowhere to place 1; eliminate the head, and this is the final result</li>
							</ul>
						</div>
					</div>
					<p>Below are some exercises. For each of the lambdas, perform a beta reduction.</p>
					<div class="compare">
						<div>
							<p><span class="exh">Exercise.</span> ${(\lambda xyz.xz(yz))(\lambda mn.m)(\lambda p.p)}$</p>
							<details class="answer">
								<summary>Solution</summary>
								<div class="mproof">
									<div class="premises">
										<ul>
											<li>${(\lambda xyz.xz(yz))(\lambda mn.m)(\lambda p.p)}$</li>
											<li>the lambda with arguments passed</li>
										</ul>
										<ul>
											<li>${(\lambda x.\lambda y.\lambda z.xz(yz))(\lambda m.\lambda n.m)(\lambda p.p)}$</li>
											<li>currying made explicit</li>
										</ul>
										<ul>
											<li>${[x \coloneqq (\lambda mn.m) = (\lambda m. \lambda n.m)]}$</li>
											<li>bind ${x}$</li>
										</ul>
										<ul>
											<li>${(\lambda y.\lambda z.(\lambda m. \lambda n.m)z(yz))(\lambda p.p)}$</li>
											<li>eliminate first head</li>
										</ul>
										<ul>
											<li>${[y \coloneqq (\lambda p.p)]}$</li>
											<li>bind ${y}$</li>
										</ul>
										<ul>
											<li>${\lambda z.(\lambda m. \lambda n.m)(z)((\lambda p.p)z)}$</li>
											<li>eliminate second head; ${\lambda z}$ cannot be reduced any further, because it has no arguments to apply to; now we go inside and reduce one layer at a time</li>
										</ul>
										<ul>
											<li>${m \coloneqq z}$</li>
											<li>bind ${m}$</li>
										</ul>
										<ul>
											<li>${\lambda z.(\lambda n.z)((\lambda p.p)z)}$</li>
											<li>eliminate head</li>
										</ul>
										<ul>
											<li>${[n \coloneqq ((\lambda p.p)z)]}$</li>
											<li>bind ${n}$</li>
										</ul>
										<ul>
											<li>${\lambda z.z}$</li>
											<li>there is no variable ${n}$ for substitution; this is the final result, an irreducible lambda expression</li>
										</ul>
									</div>
								</div>
							</details>
						</div>
					</div>
				</section>
			</article>
		</main>

		<!-- Scripts -->
			<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
			<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js " integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
			<script>
				document.addEventListener("DOMContentLoaded", function () {
					renderMathInElement(document.body, {
						// customised options
						// • auto-render specific keys, e.g.:
						delimiters: [
							{ left: "$$", right: "$$", display: true },
							{ left: "$", right: "$", display: false },
							{ left: "\\(", right: "\\)", display: false },
							{ left: "\\[", right: "\\]", display: true },
						],
						// • rendering keys, e.g.:
						throwOnError: false,
					});
				});
			</script>
			<!-- <script src="https://unpkg.com/function-plot@1.22.2/dist/function-plot.js"></script> -->
			<script src="js/csfoundations.js"></script>
			<script src="js/prism.js"></script>
	</body>
</html>
