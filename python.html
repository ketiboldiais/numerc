<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>python</title>
	<link rel="stylesheet" href="css/csfoundations.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous" />
</head>

<body>
	<header>
		<h1>numerc</h1>
	</header>

	<main>
		<nav class="section-nav">
			<ul>
				<li>Preface</li>
				<li>Programming Languages in General</li>
				<li>Computability</li>
				<li>Programs in Python</li>
				<li>Library Imports</li>
				<li>Data Objects</li>
				<li>Converting Types</li>
				<li>Arithmetic Operators</li>
				<li>Changing Variable Bindings</li>
				<li>Swapping Variables</li>
				<li>Comparison Operators</li>
				<li>Boolean Operators</li>
				<li>Branching Programs</li>
				<li>Strings</li>
				<li>Input and Output</li>
				<li>Loops</li>
				<li>Iterating over a String</li>
				<li>Iteration in General</li>
				<li>Guess &amp; Check</li>
				<li>Loops</li>
				<li>Simple Algorithms</li>
				<li>Bisection Search</li>
				<li>Floats &amp; Fractions</li>
				<li>Newton-Raphson Algorithm</li>
				<li>Decomposition &amp; Abstraction</li>
				<li>Functions</li>
				<li>Control</li>
				<li>Calling Functions &amp; Scope</li>
				<li>Keyword Arguments</li>
				<li>Specification</li>
				<li>Iteration v. Recursion</li>
				<li>Inductive Reasoning</li>
				<li>Towers of Hanoi</li>
				<li>Recursion: Multiple Base Cases</li>
				<li>Recurring over Strings</li>
				<li>Python Files</li>
				<li>Structured Types</li>
				<li>Tuples</li>
				<li>Lists</li>
				<li>Operations on Lists</li>
				<li>Mutating, Aliasing, &amp; Cloning</li>
				<li>Functions as Objects</li>
				<li>Dictionaries</li>
				<li>Using Dictionaries</li>
				<li>Testing &amp; Debugging</li>
				<li>Classes of Tests</li>
				<li>Testing Approaches</li>
				<li>Bugs</li>
				<li>Debugging</li>
				<li>Exceptions &amp; Assertions</li>
				<li>Object-Oriented Programming Generally</li>
				<li>Python Classes</li>
				<li>Creating Sets</li>
				<li>The Power of OOP</li>
				<li>Hierarchies</li>
				<li>Class Variables</li>
			</ul>
		</nav>

		<article id="python-language" class="grid" data-colcade="columns: .grid-col, items: .grid-item">
			<div class="grid-col grid-col--1"></div>
			<div class="grid-col grid-col--2"></div>
			<div class="grid-col grid-col--3"></div>
			<div class="grid-col grid-col--4"></div>
			<section class="grid-item">
				<h2>Computational Thinking with Python</h2>
				<p>In these next few sections, we switch from C to Python. Going from C to Python is like living in the Alaskan wild and suddenly being thrust into New York City. So much of what we want to do in terms of programming is already taken care of for us &mdash; things like memory management; being careful with types; where we place our code; it's all handled for us by Python. Nevertheless, just as the skills we might learn from living in the wilderness are useful anywhere we live, the skills we learned in C &mdash; methodical thinking, resourcefulness, and case considerations &mdash; remain useful as we cover Python.</p>
				<p>As we saw, C is a very low level language, sitting close to the computer's actual hardware. This makes it a useful language for learning cost-benefit analysis, a critical skill in computer science, as well as understanding how computers work at their core. The downside: For every hour we spend studying cost-benefit analyses and exploring how computers work, that's an hour taken away from other aspects of computer science. To spend time on those other aspects, we need a language that abstracts away all of the lower level details so we don't have to worry about them. That language is python.</p>
				<p>In the sections on C, we focused on a variety of topics &mdash; basic programming concepts like conditions and loops, to more complex topics like pointers and linked lists. Now we must go even further up the layers of abstraction, and focus on <span class="boldItalics">computational methods</span> &mdash; the techniques used to solve problems <span class="italicsText">computationally</span>.</p>
				<p>Before we proceed, a quick review of rudimentary computer science terms and concepts: An <span class="italicsText">algorithm</span> is a concept, and a program is a concrete implementation of that algorithm. The <span class="italicsText">computational approach</span> is a problem solving philosophy resting on the premise that every problem can be viewed in terms of mathematics, and can be solved with numbers and formulas. The field of <span class="italicsText">computer science</span> is the study of how to build efficient machines &mdash; physical or abstract &mdash; that run programs.</p>
			</section>

			<section id="computers_are_machines" class="grid-item">
				<h3>Computers Are Machines</h3>
				<p>Programs can be captured in two ways: through <span class="boldItalics">fixed program computers</span> or <span class="boldItalics">stored program computers</span>. A <span class="italicsText">fixed program computer</span> is a machine that executes just one particular program. There are numerous fixed programs, both today and in history &mdash; the sun dial; the abacus; the handheld calculator; Alan Turing's <span class="italicsText">Bombe</span>; these are all fixed program computers.</p>
				<p>A <span class="italicsText">stored program computer</span> is a machine stores and executes multiple. Most of what we think of as a "computer" falls into this category. But, do not confuse a "computer" with a "laptop." The latter is purely marketing parlance. Stored program computers come in many forms &mdash; laptops; mobile phones with apps; servers; missile defense dashboards; these are all fixed program computers.</p>
				<p>The stored program computer consists of numerous parts. Inside the computer is an <span class="italicsText">interpreter</span>. That <span class="italicsText">interpreter</span> directs the computer, based on <span class="italicsText">our</span> instructions. Many of those instructions are embodied in programs that could be stored in a fixed program computer (e.g., a calculator program, the time displayed in our menu bar, etc.). Thus, a stored program computer can be thought of as simply emulating multiple fixed program computers.</p>

				<p><span class="topic">Values.</span> The word <span class="term">value</span> in computer science refers to the data we want to manipulate. <span class="term">Data</span> are the computer entities that we use to represent real world <span class="italicsText">information</span>. Some values are represented with primitive types, others with more complex and elaborate types. At the end of the day, however, every data has structure. A significant part of programming is coming up with ways to come up with <span class="term">data structures</span> &mdash; how do we represent real world information in terms of entities that the a computer can understand?</p>

				<p><span class="topic">Computations.</span> Where one aspect of programming is coming up with ways to represent information, another deals with ways we can work with those representations. To do so, we perform <span class="italicsText">computations</span> on values with <span class="term">expressions</span>.</p>
				<p>Those expressions can be bundled together to form <span class="term">functions</span>. A <span class="italicsText">function</span> is a value that performs computations on values. Because functions are values, they can be passed as values into a function, from which another function returns. The integral and the derivative, for example, are examples of functions that take functions.</p>
			</section>

			<section id="programming_languages" class="grid-item">
				<h3>Programming Languages</h3>
				<p>A programming language provides a set of <span class="boldItalics">primitive operations</span>. With those primitive operations, we can write <span class="boldItalics">expressions</span>. Expressions are what we use to perform computations. In all programming languages, expressions and computations have a <span class="boldItalics">value</span> &mdash; their <span class="italicsText">meaning</span>.</p>
				<p>More explicitly, any programming language will have the following properties:</p>
				<ol>
					<li>primitives;</li>
					<li>a means of combination &mdash; how primitives are arranged to form expressions; and</li>
					<li>a means of abstraction &mdash; a way of taking an expression and treating it as a primitive.</li>
				</ol>
				<p>In most programming languages, there are several primitives: booleans, numbers, strings (or sequences of characters), and simple arithmetic operations (addition, subtraction, comparison, etc.). These primitives can be arranged and combined to form newer things, just as bricks of legos can be connected to form grand structures.</p>
				<p>Unlike legos, however, there are rules about how we can connect and arrange primitives. These rules fall into two categories: (1) <span class="boldItalics">syntax</span> and (2) <span class="boldItalics">semantics</span>. This is similar to English. Syntax is the set of rules that defines what is a valid arrangement of primitives (an expression) in a given programming language. In English, the word arrangement "a plane head fly" is not a valid sentence, but the arrangement "a plane flies overhead" is. Programming languages have similar rules. In Python, the arrangement <span class="monoText">2.9"12"</span> is not a valid expression. But the arrangement <span class="monoText">2.9 * 12</span> is. When an expression satisfies all of a programming language's syntax rules, we say that the expression is <span class="boldItalics">syntatically valid</span>.</p>
				<p>Just as sentences in English have meaning, so too do expressions in programming languages. In computer science, an expressions meaning is governed by <span class="boldItalics">semantics</span> &mdash; the set of all rules that define <span class="italicsText">when</span> an expression has meaning, and what that meaning is. Within semantics, there are two subsets: (a) <span class="boldItalics">static semantics</span> and (b) <span class="boldItalics">full semantics</span>.</p>
				<p>Static semantics is the set of all rules determining <span class="italicsText">when</span> a syntactically valid expression has meaning. In English, for example, "me call Ishmael" is a syntactically valid arrangement of words &mdash; it has a subject and a predicate. But semantically, it does not make sense. The arrangement "call me Ishmael," however, is both syntactically and semantically valid. The same goes for programming languages. In Python, the expression <span class="monoText">2.9 * "12"</span> is syntactically valid, but semantically invalid. The expression <span class="monoText">2.9 * 12</span>, however, is both syntactically and semantically valid. The rules determining why the second expression is semantically valid are the programming language's <span class="italicsText">static semantics</span>.</p>
				<p>Even if an expression is both syntactically and static semantically valid, it is still subject to the programming language's <span class="boldItalics">full semantics</span> &mdash; the rules determining <span class="italicsText">what</span> an expression means. In English, there is room for ambiguity. For example, consider the famous headline: "The British left Waffles on Falklands." The sentence could mean, (a) the British left a beloved breakfast food made of batter on the Falklands, or (b) the political British left couldn't decide on what do with the Falklands. We call this phenomenon <span class="boldItalics">syntactic ambiguity</span>. In programming languages, there is no such thing. The foundational rule of full semantics is that expressions have <span class="underlineText">only one</span> meaning. This is always the case, whether or not we expect it (a crucial point to remember when we execute code and get back strange results).</p>
			</section>

			<section id="computability" class="grid-item">
				<h4>Computability</h4>
				<p>Mathematics can be viewed as a <span class="boldItalics">formal system</span> &mdash; a set of meaningless symbols that can be manipulated according to a set of fixed rules, so as to produce meaning. For example, the game of chess is a formal system. The symbols are the pieces &mdash; king, rook, bishop, etc. &mdash; and the fixed set of rules consists of those governing how the pieces move. These pieces and rules do not have any meaning outside of chess. Philsophers and mathematicians like David Hilbert argued that mathematics should be viewed in this way.</p>
				<p>Hilbert's arguments responded to a lingering philosophical question at the very heart of mathematics &mdash; Is mathematics invented or discovered? By viewing mathematics as a formal system, the question could be addressed without shaking the foundations of all of mathematics.</p>
				<p>To construct a formal system, however, Hilbert needed <span class="italicsText">foundational axioms</span> &mdash; the rules that provide what is allowed and prohibited in creating the formal system. To construct these foundational axioms, Hilbert focused on the three things most valued in mathematics:</p>
				<ol>
					<li>consistency;</li>
					<li>completeness; and</li>
					<li>decidability</li>
				</ol>
				<p><span class="topic">Consistency.</span> The property of consistency provides that no contradictions can be proven within the system. For example, if you prove that ${1 + 1 = 2,}$ you cannot then prove that ${1 + 1 \neq 2.}$ Without consistency, the entire formal system is useless; we would never be certain of our results. This property was largely unchallenged at the time, but recent work in logical pluralism has raised some questions.</p>
				<p><span class="topic">Completeness</span>. The property of completeness provides that there is a proof demonstrating that all true statements in the formal system can be proven within the system. I.e., for any given true statement in the formal system, we do not need to go outside the system to prove that it is true. As an aside, Hilbert's work on this particular property was largely demolished by the German logician Kurt Gödel (see Gödel's <span class="italicsText">incompleteness theorems</span>).</p>
				<p><span class="topic">Decidability.</span> Decidability provides that there exists an <span class="italicsText">effective procedure</span> for deciding whether any particulary statement in the formal system is true or false.</p>
				<p>It is this final property, decidability, that caught the attention of a young computer scientist named Alan Turing. Turing's question was straightforward in statement: Is there an <span class="italicsText">effective procedure</span> for deciding whether any mathematical statement is true or false? It was this notion of an &#8220;effective procedure&#8221; that Turing was particularly interested in.</p>
				<p>Today, we know these effective procedures as <span class="boldItalics">algorithms</span>. During Turing's time, however, there was no such parlance. Back then, "computers" were humans, most often women, given a set of instructions on what and how to compute a particular result. These were mindless, mechanical tasks. Turing saw the process as an "effective procedure," consisting of a series of steps:</p>
				<ol>
					<li>The human reads the instructions;</li>
					<li>the human reads and writes symbols on a piece of paper in response to reading the instructions;</li>
					<li>the human occassionally erases a symbol and replaces it with a new symbol; and</li>
					<li>the human stops working when the computation is complete.</li>
				</ol>
				<p>The breakthrough was Turing's realization that all of the steps above could be performed by a theoretical machine. Instead of a human, there's a scanner. The scanner sees, erases, and writes one symbol at a time. Instead of a piece of paper, the scanner works with an infinitely long piece of tape lined with squares, each square containing one symbol (<span class="monoText">0</span>, <span class="monoText">1</span>, or blank).</p>
				<p>But what about the instructions? How does the scanner know what to do? Indeed, the scanner has no brain. To solve this problem, Turing looked to the instructions and what humans were doing. The instructions were largely routine, mechanical tasks. As such, if the instructions were reduced to conditional statements (i.e., statements that can be ascribed the values true or false), we can translate the instructions into a form where the machine (a) sees if it's a <span class="monoText">1</span>, a <span class="monoText">0</span>, or a blank, and write something in response. In doing so, we provide the machine with <span class="boldItalics">internal states</span> &mdash; what the machine should do when a particular condition (e.g., seeing a <span class="monoText">0</span>, <span class="monoText">1</span>, or a blank) is true. And if we can provide internal states, we can also provide internal states leading to other internal states &mdash; the machine can perform much more complex computations.</p>
				<p>In sum, Turing's machine &mdash; what we now refer to as a <span class="boldItalics">Turing Machine</span> &mdash; could accept as input <span class="monoText">0</span>s and <span class="monoText">1</span>s and output <span class="monoText">0</span>s and <span class="monoText">1</span>s to perform computations. Better yet, the machine could perform computations endlessly, as it was not subject to the same human limitations of physical and mental exhaustion. Turing had constructed one definition for an effective procedure &mdash; an effective procedure is any procedure that can be computed by a Turing Machine in a finite amount of time.</p>
				<p>Turing machines lead to the <span class="boldItalics">Church-Turing thesis</span>: If a function is computable, then a Turing Machine can be programmed to compute it. Unfortunately for David Hilbert, not all problems have computational solutions. Turing proved that it was impossible to write an internal state for a Turing Machine that takes any arbitrary program as input, and prints <span class="monoText">true</span> if, and only if, the program will run forever. This is known as the <span class="boldItalics">halting problem</span>.</p>
				<p>While we lend sympathy to Hilbert's failed project, the Church-Turing thesis yields a bedrock principle in computer science: <span class="boldItalics">Turing completeness</span>. A programming language is said to be Turing complete if it can be used to simulate a Turing Machine. And if a programming language is Turing complete, then <span class="italicsText">anything</span> that can be programmed in that language can be programmed in any other Turing complete programming language. Of course, some programs are easier to implement in one language over the other; Piet, Brainfuck, CSS3+HTML5, and Whitespace are all Turing complete, but it would be odd to choose them over Matlab when implementing Fourier transforms. Nevertheless, as a matter of pure theory, all Turing complete languages are equal with respect to computational ability.</p>
			</section>

			<section id="programs_in_python" class="grid-item">
				<h4>Programs in Python</h4>
				<p>A Python <span class="boldItalics">program</span> is a sequence of <span class="italicsText">definitions</span> and <span class="italicsText">commands</span>. Definitions are <span class="italicsText">evaluated</span>, and commands are <span class="italicsText">executed</span> in a <span class="boldItalics">shell</span> &mdash; a window where we can type expressions to be passed to the Python interpreter. Commands are also called <span class="italicsText">statements</span> &mdash; they are expressions that tell the interpreter to do something.</p>
				<p>Both commands and expressions can be typed directly into a shell, or they can be stored in a Python file (files with the extension <span class="monoText">.py</span>), which is then <span class="italicsText">read</span> into a shell and evaluated.</p>
				<p>As we study Python, we'll likely notice how concise it is as a language. Without doubt, programs in Python are largely much shorter than programs in languages like C. Conciseness, readability, and user-friendliness, however, comes at a cost &mdash; speed. C is simply a much faster language when it comes to handling large data structures. This is largely because of how close the language is to the computer's hardware.</p>
				<p>Where C is a <span class="boldItalics">low-level language</span>, Python is a <span class="boldItalics">high-level language</span> &mdash; a language that abstracts away the low-level details we normally must handle. In C, we manage memory ourselves. If we find a more efficient approach, we can implement. If we see memory leaks, we can go straight to the source. In Python, we have no business handling memory. Instead, we are forced to use Python's general-purpose approach to memory management. This can be costly. Because memory management is not a one-size-fits-all issue, there will be instances were Python's approach is inefficient.</p>
				<p>Additionally, using a high-level language incurs overhead costs in memory consumption. In contrast to C code &mdash; which is handled directly by the <span class="italicsText">compiler</span> &mdash; Python code is handled by the Python <span class="italicsText">interpreter</span>. This distinction evidences two categories of programming languages: (1) <span class="boldItalics">compiled languages</span>, and (2) <span class="boldItalics">interpreted languages</span>.</p>
				<p>Interpreted languages are essentially programs themselves. The clearest evidence of this is when we execute Python code via our terminal:</p>
				<pre class="command-line language-bash" data-output=""><code>
					python foo.py
				</code></pre>
				<p>That keyword, <span class="monoText">Python</span>, is a call to a program. More specifically, it is a call to the Python <span class="boldItalics">interpreter</span>, a program that translates our source code into 0s and 1s <span class="underlineText">on</span> execution, <span class="underlineText">without</span> compiling. This is different from C, where our source code must be translated into 0s and 1s &mdash; compiling &mdash; <span class="underlineText">before</span> execution. This difference is akin to analyzing a poem written in German when we only understand English. We can either (1) go to the first line, translate into English, analyze, then move to the second line and repeat, then the third line, the fourth, fifth, etc., or (2) translate the entire poem into English first, then analyze. The second approach is clearly faster. With the first approach, we have to translate each word one at a time, then put them all together, then analyze (likely changing our analysis because of previous lines), then move to the next line. In sum, whenever we execute Python code, we aren't just executing our code, we are also executing the interpreter's code. This incurs a certain amount of overhead in memory use and time.</p>
			</section>

			<section id="importing_libraries_in_python" class="grid-item">
				<h4>Importing Libraries/Modules in Python</h4>
				<p>Recall how we import libraries in C:</p>
				<pre class="language-c"><code>
					#include &lt;library.h&gt;
				</code></pre>
				<p>The same operation exists in Python for <span class="boldItalics">modules</span> (Python's term for "libraries"). In C, libraries are indicated by the <span class="monoText">.h</span> extension; modules, and all Python files, simply use the <span class="monoText">.py</span> extension. Importing modules in Python is done with the following syntax:</p>
				<pre class="language-pseudo"><code>
					import module
				</code></pre>
				<p>Where <span class="monoText">module</span> is the module's name (e.g., <span class="monoText">module.py</span>). For example, suppose we wanted to import the <span class="monoText">math</span> module, a popular library for mathematical functions. With <span class="monoText">math.py</span> in our current directory, we write:</p>
				<pre class="language-python"><code>
					import math
				</code></pre>
				<p>Suppose we want to import just a specific function rather than the entire module. For example, the <span class="monoText">cos()</span> function provided by the <span class="monoText">math</span> module:</p>
				<pre class="language-python"><code>
					import math cos  
				</code></pre>
				<p>If we wanted multiple functions:</p>
				<pre class="language-python"><code>
					from math import cos, sin, log10
				</code></pre>
				<p>A word of caution: If we use the first syntax, <span class="monoText">import module</span>, calls to functions from that module must be be written in the following syntax:</p>
				<pre class="language-pseudo"><code>
					import module
					... module.definition ... 
				</code></pre>
				<p>The ellipses indicate code using the module definition; <span class="monoText">module</span> is the module's name; and <span class="monoText">definition</span> is the particular data object, like a function, we want to import. Thus, if we used <span class="monoText">import math</span>, calls to the <span class="monoText">cos()</span> definition inside the <span class="monoText">math</span> module must be written as:</p>
				<pre class="language-python"><code>
					import math
					x = math.cos()
				</code></pre>
				<p>The code above effectively tells Python, "Go inside the module <span class="monoText">math</span>, and call the function <span class="monoText">cos()</span>. This syntax must be used because of <span class="boldItalics">namespacing</span> &mdash; a language feature allowing programs to have identically-named data objects. This feature works only if the data objects exist in two different <span class="boldItalics">namespaces</span> within the program. A <span class="italicsText">namespace</span> is simply a system ensuring that all names in a program are <span class="italicsText">unique</span>, so as to avoid collisions. Writing <span class="monoText">math.cos()</span> tells Python that the data object <span class="monoText">cos()</span> exists in a single namespace &mdash; in Python, a <span class="italicsText">dictionary</span> &mdash; inside the module named <span class="monoText">math</span>.</p>
			</section>

			<section id="data_objects_in_python" class="grid-item">
				<h4>Objects in Python</h4>
				<p>The fundamental primitives in a programming language are more broadly called <span class="boldItalics">data objects</span>. Programs manipulate data objects to extract parts of those objects or to do something with those objects.</p>
				<p>Every data object has a <span class="boldItalics">type</span>. A <span class="italicsText">type</span> is the set of all rules that defines what we can and cannot do with the data objects of that type. For example, C has the data type <span class="monoText">char</span>. If a program expects a <span class="monoText">char</span> type data object, and we give it instead an <span class="monoText">int</span> or <span class="monoText">double</span>, our program usually will not do anything with the data object, because the rules prevent it.</p>
				<p>Types themselves fall into two categories: (1) <span class="boldItalics">scalar</span> or (2) <span class="boldItalics">non-scalar</span>. If a data object's type is scalar, then the data object cannot be subdivided. If a data object's type is non-scalar, then the data object has an <span class="italicsText">internal structure</span> composed of smaller parts, and we can access that internal structure to extract those parts.</p>
				<p>In Python, there are four scalar type objects:</p>
				<ol>
					<li><span class="monoText">int</span> &mdash; representing <span class="italicsText">integers</span></li>
					<li><span class="monoText">float</span> &mdash; representing <span class="italicsText">real numbers</span></li>
					<li><span class="monoText">bool</span> &mdash; representing the Boolean values <span class="monoText">True</span> and <span class="monoText">False</span></li>
					<li><span class="monoText">NoneType</span> &mdash; a special type of only one value, <span class="monoText">None</span></li>
				</ol>
				<p>We can test what the type of a data object is with <span class="monoText">type()</span>. For example, let's write the following code in a shell:</p>
				<pre class="language-bash"><code>
					In [1]: 2.8
					Out[1]: 2.8
					In [2]: type(2.8)
					Out[2]: float
					In [3]: 2 
					Out[3]: 2 
					In [4]: type(2) 
					Out[4]: int 
				</code></pre>
			</section>

			<section id="converting_types_in_python" class="grid-item">
				<h4>Casting</h4>
				<p>We can convert an object of one type to another. This is called <span class="boldItalics">casting</span>. For example, writing <span class="monoText">float(2)</span> converts the integer <span class="monoText">2</span> to the float <span class="monoText">2.0</span>. Writing <span class="monoText">int(7.2)</span> truncates the float <span class="monoText">7.2</span> to the integer <span class="monoText">7</span>.</p>
				<pre class="command-line language-bash" data-output=""><code>
					In [1]: float(5)
					Out[1]: 5.0
					In [2]: int(4.9)
					Out[2]: 4
				</code></pre>
				<p>Notice that when Python converts a <span class="monoText">float</span> into an <span class="monoText">int</span>, it performs no rounding. It simply chops off the fractional part of the number.</p>
			</section>

			<section id="arithmetic_operators" class="grid-item">
				<h4>Arithmetic Expressions</h4>
				<p>With the scalar data types, we can begin constructing expressions. Expressions in Python must follow a particular syntax:</p>
				<pre class="language-pseudo"><code>
					&lt;object&gt; &lt;operator&gt; &lt;object&gt;  
				</code></pre>
				<p>Any expression of the above form has a value. That value itself is a data object, so it has a type. Here are the general expressions of <span class="italicsText">operators</span> on <span class="monoText">int</span>s and <span class="monoText">float</span>s:</p>
				<figure>
					<table>
						<thead>
							<th>Expression</th>
							<th>Meaning</th>
						</thead>
						<tbody>
							<tr>
								<td><span class="monoText">i+j</span></td>
								<td>Return the sum; ${i + j;}$  if <span class="monoText">i</span> and <span class="monoText">j</span> are <span class="monoText">int</span>s, then the result is an <span class="monoText">int</span>; if <span class="monoText">i</span> or <span class="monoText">j</span> is a <span class="monoText">float</span>, then the result is a <span class="monoText">float</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">i-j</span></td>
								<td>Return the difference; ${i - j}$; if <span class="monoText">i</span> and <span class="monoText">j</span> are <span class="monoText">int</span>s, then the result is an <span class="monoText">int</span>; if <span class="monoText">i</span> or <span class="monoText">j</span> is a <span class="monoText">float</span>, then the result is a <span class="monoText">float</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">i*j</span></td>
								<td>Return the product; ${i \times j}$; if <span class="monoText">i</span> and <span class="monoText">j</span> are <span class="monoText">int</span>s, then the result is an <span class="monoText">int</span>; if <span class="monoText">i</span> or <span class="monoText">j</span> is a <span class="monoText">float</span>, then the result is a <span class="monoText">float</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">i**j</span></td>
								<td>Return <span class="monoText">i</span> to the power to <span class="monoText">j</span>; ${i^j.}$</td>
							</tr>
							<tr>
								<td><span class="monoText">i/j</span></td>
								<td>Return the quotient; ${\dfrac{i}{j};}$ result is a <span class="monoText">float</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">i//j</span></td>
								<td>Return the quotient; ${\dfrac{i}{j};}$ result is an <span class="monoText">int</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">i%j</span></td>
								<td>Return the remainder from <span class="monoText">i</span> divided by <span class="monoText">j</span>; ${i \mod j;}$ result is an <span class="monoText">int</span>.</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>For example:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: 1+7
					out[1]: 8 
				</code></pre>
				<p>We can also output things in the shell with <span class="monoText">print()</span>:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: print(1+7)
					8
				</code></pre>
				<p>Notice the difference in output. There's not "<span class="monoText">out[]</span>" prompt. There's no <span class="monoText">out[]</span> because no value is returned. When we use <span class="monoText">print()</span>, we get back an object of type <span class="monoText">NoneType</span>.</p>
				<p>Why do we use <span class="monoText">print()</span> then? We use <span class="monoText">print()</span> when we want to show the <span class="italicsText">output</span> of our code to a user. If we use anything else, a value is returned. This increases the risk of the value being used by other parts of program when we don't intend it to be used.</p>
			</section>

			<section id="operator_precedence" class="grid-item">
				<h4>Operator Precedence</h4>
				<p>Like real world arithmetic, arithmetic expressions in Python are evaluated according to operator precedence:</p>
				<ol>
					<li>Python will always first look at parentheses. E.g., <span class="monoText">3*5+1</span> evaluates to <span class="monoText">16</span>, but <span class="monoText">3*(5+1)</span> evaluates to <span class="monoText">18</span>.</li>
					<li>Within or after parentheses, exponentiation is evaluated first (<span class="monoText">i**j</span>)</li>
					<li>Multiplication is evaluated second (<span class="monoText">i*j</span>)</li>
					<li>Division is evaluated third (<span class="monoText">i/j</span>)</li>
					<li>Addition and substraction are evaluated last (<span class="monoText">i-j</span>, <span class="monoText">i+j</span>)</li>
					<li>All of the steps above are done <span class="italicsText">left to right</span>. E.g., the expression <span class="monoText">6+12-3</span> evaluates to <span class="monoText">15</span>.</li>
				</ol>
				<p>Here are some example arithmetic evaluations:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: 6+12-3
					out[1]: 15
					in [2]: 2*3.0
					out[2]: 6.0
					in [3]: --4
					out[3]: 4
					in [4]: 10/3
					out[4]: 3.3333333333333335
					in [5]: 10.0/3.0
					out[5]: 3.3333333333333335
					in [6]: (2+3)*4
					out[6]: 20
					in [7]: 2+3*4
					out[7]: 14
					in [8]: 2**3+1
					out[8]: 9
					in [9]: 2.1**2.0
					out[9]: 4.41
					in [10]: 2.2*3.0
					out[10]: 6.6
				</code></pre>
			</section>

			<section id="variables_in_python" class="grid-item">
				<h4>Variables in Python</h4>
				<p>The way we've connected primitives and operators constitute Python's <span class="italicsText">means of combination</span>. Now we cover Python's <span class="italicsText">means of abstraction</span>.</p>
				<p>One means of abstraction is storing values in <span class="boldItalics">variables</span>. A single equal sign (<span class="monoText">=</span>) denotes <span class="boldItalics">assignment</span> of <span class="boldItalics">value</span> to a <span class="boldItalics">variable name</span> (also called an <span class="boldItalics">identifier</span>). For example, the following are all assignments in a <span class="monoText">.py</span> file:</p>
				<pre class="language-python"><code>
					pi = 3.14159
					pi_approx = 22/7
				</code></pre>
				<p>Python is an example of a <span class="boldItalics">loosely-typed language</span>. This is in contrast to C, which is a <span class="boldItalics">strongly-typed language</span>. C itself is in contrast to languages like Ada and Pascal, which are often said to be <span class="boldItalics">stringently-typed languages</span>. Pascal in particular has been criticized as having too strong of a type system, making many programming tasks too difficult. On the other end of the spectrum, Python is in contrast to Assembly and Forth, which are <span class="boldItalics">untyped languages</span> &mdash; there are no types, and everything is left to the programmer to ensure that appropriate data types are used.</p>
				<p>These distinctions are all based on two factors: (a) whether the language has types, and (b) how much the programmer must use the types explicitly. In C, for example, every variable declaration must be prefaced with the type of data object the variable will store. This is a common characteristic of strongly-typed languages. In languages like Python and JavaScript, however, types do not have to be explicitly used. The types exist, but the programmer is not required to explicitly state them. In other words, the programmer does not bear the burden of specifying what data type is to be used; the language's interpreter or compiler will infer it.</p>
				<p>When we assign a value to an identifier, we effectively <span class="italicsText">bind</span> the value to a particular <span class="italicsText">name</span>. In doing so, we store that value in computer memory, which we can access by referencing that value's name:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: pi = 3.14159
					out[1]: 3.14159
					in [2]: pi
					out[2]: 3.14159
				</code></pre>
				<p>Although the ability to store values in variables may not seem impressive, its benefits cannot be understated. It allows us make our programs <span class="italicsText">modular</span>, treating sections of code like Lego bricks we can use over and over again. We can reuse names, instead of values. This provides two benefits. First, it gives us a short cut: instead of rewriting a computation over and over again, we can just reference that computation's name. Second, it makes our programs easier to read. And when programs are easier to read, changing or debugging them is both faster and less painful. Of course, the second benefit only applies if we give our variables <span class="italicsText">descriptive</span> and <span class="italicsText">concise</span> names. Here is one complex expression in Python:</p>
				<pre class="language-python"><code>
					pi = 3.14159
					radius = 2.2
					# area of a circle
					area = pi*(radius**2)
				</code></pre>
				<p>In the code above, we've created a complex expression that computes the area of a circle (${A = \pi r^2}$). The pound symbol (<span class="monoText">#</span>) is the way we denote a comment in Python. Notice that the variable names are both descriptive <span class="italicsText">and</span> concise (<span class="monoText">pi</span>, <span class="monoText">radius</span>, and <span class="monoText">area</span>). The variable names could be more concise (e.g., <span class="monoText">p</span>, <span class="monoText">r</span>, and <span class="monoText">a</span>), but doing so would not be descriptive. In general, when we write variable names, we should follow a guideline: <span class="italicsText">Variable names should be descriptive and concise, erring on the side of descriptive.</span></p>
				<p>Sidebar: In Python, variable names with spaces are pothole_spaced (using underscores to indicate spaces). This is in contrast to languages like C and Java, where the prevailing convention is camelCasing.</p>
				<p>If we wanted to change the radius, say increase it by 1, we would write:</p>
				<pre class="language-python"><code>
					radius = radius+1
				</code></pre>
				<p>The code above has a shorthand in Python:</p>
				<pre class="language-python"><code>
					radius += 1
				</code></pre>
			</section>

			<section id="changing_variable_bindings" class="grid-item">
				<h5>Changing Variable Bindings</h5>
				<p>Name-value bindings are not permanent. We can re-bind variable names using new assignment statements. If we re-bind a variable name using a new assignment statement, the previous value bound to that particular name will no longer be bound to that name. It's probably still stored in memory, but we can no longer access it with the name we gave it. For example:</p>
				<pre class="language-python"><code>
					radius = 2.2
					radius += 1
				</code></pre>
				<p>The value bound to <span class="monoText">radius</span> was originally <span class="monoText">2.2</span>. When we wrote <span class="monoText">radius += 1</span>, the value <span class="monoText">2.2</span> is no longer associated with <span class="monoText">radius</span>. Here is a shell session encapsulating these ideas:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: a = 3
					in [2]: a+2.0
					out[2]: 5.0
					in [3]: a = a+1.0
					in [4]: a
					out[4]: 4.0
					in [5]: a = 3
					in [6]: a
					out[6]: 3
					in [7]: b
					NameError: name 'b' is not defined
				</code></pre>
			</section>

			<section id="swapping_variables" class="grid-item">
				<h5>Swapping Variables</h5>
				<p>We must be careful about assigning values to names already bound to values. For example, suppose we wanted to swap certain variables:</p>
				<pre class="language-python"><code>
					x = 0
					y = 1
					y = x
					x = y
				</code></pre>
				<p>What exactly does the code above do? We first assigned the integer <span class="monoText">0</span> to the name <span class="monoText">x</span>. Then we assigned the integer <span class="monoText">1</span> to the name <span class="monoText">y</span>. Next, we assigned the variable <span class="monoText">x</span> to the name <span class="monoText">y</span>. The variable <span class="monoText">y</span> now stores the data object <span class="monoText">x</span>, which stores the integer <span class="monoText">0</span>. Thus, <span class="monoText">y = 0</span>. Finally, we assigned the variable <span class="monoText">y</span> to the name <span class="monoText">x</span>. Because <span class="monoText">y = x = 0</span>, we haven't actually swapped anything &mdash; <span class="monoText">x = y = x = 0</span>.</p>
				<p>This exercise reveals a crucial point: Assignment is read <span class="underlineText">left to right</span>, and statements are read <span class="underlineText">top to bottom</span> <span class="italicsText">one at a time</span>. A better way to swap the variables above is with the following:</p>
				<pre class="language-python"><code>
					x = 1
					y = 2
					temp = y
					y = x
					x = temp
				</code></pre>
				<p>The sequence above goes as such:</p>
				<ol>
					<li>We store the integer <span class="monoText">1</span> to in a variable named <span class="monoText">x</span>.</li>
					<li>We store the integer <span class="monoText">2</span> to in a variable named <span class="monoText">y</span>.</li>
					<li>We store the variable <span class="monoText">y</span> to a temporary variable named <span class="monoText">temp</span> (<span class="monoText">temp = y = 2</span>).</li>
					<li>We store the variable <span class="monoText">x</span> to the variable <span class="monoText">y</span> (<span class="monoText">x = y = 2</span>).</li>
					<li>We store the variable <span class="monoText">temp</span> to the variable <span class="monoText">x</span> (<span class="monoText">x = temp = y = 2</span>).</li>
					<li>The conclusion:</li>
					<ul>
						<li><span class="monoText">y = x = 1</span></li>
						<li><span class="monoText">x = temp = y = 2</span></li>
					</ul>
				</ol>
			</section>

			<section id="python_comparison_operators" class="grid-item">
				<h4>Comparison Operators</h4>
				<p>With just arithmetic operators and variables, we can only perform arithmetic computations. But, there's more to computation than arithmetic. A cornerstone to computation is the ability to address <span class="italicsText">cases</span>. We don't perform the same computation for every single thing. In fact, what computation we perform depends on whether certain <span class="italicsText">conditions</span> are met. To determine whether those conditions are met, we need the ability to <span class="italicsText">compare</span> values. Below are the comparison operators for the types <span class="monoText">int</span> and <span class="monoText">float</span>:</p>
				<figure>
					<table>
						<thead>
							<th>Comparison Operator</th>
							<th>Meaning</th>
						</thead>
						<tbody>
							<tr>
								<td><span class="monoText">i > j</span></td>
								<td>Tests whether <span class="monoText">i</span> is greater than <span class="monoText">j</span>; ${i > j.}$</td>
							</tr>
							<tr>
								<td><span class="monoText">i >= j</span></td>
								<td>Tests whether <span class="monoText">i</span> is greater than OR equal to <span class="monoText">j</span>; ${i \geq j.}$</td>
							</tr>
							<tr>
								<td><span class="monoText">i < j</span></td>
								<td>Tests whether <span class="monoText">i</span> is less than <span class="monoText">j</span>; ${i < j.}$</td>
							</tr>
							<tr>
								<td><span class="monoText">i <= j</span></td>
								<td>Tests whether <span class="monoText">i</span> is less than OR equal to <span class="monoText">j</span>; ${i \leq j.}$</td>
							</tr>
							<tr>
								<td><span class="monoText">i == j</span></td>
								<td>Tests whether <span class="monoText">i</span> is equal to <span class="monoText">j</span>; ${i = j.}$</td>
							</tr>
							<tr>
								<td><span class="monoText">i != j</span></td>
								<td>Tests whether <span class="monoText">i</span> is NOT equal to <span class="monoText">j</span>; ${i \neq j.}$</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>The expressions using the operators above are called <span class="boldItalics">logical expressions</span>. Logical expressions return objects of type <span class="monoText">bool</span>: the values <span class="monoText">True</span> or <span class="monoText">False</span>. To use logical expressions, we need another set of operators called <span class="italicsText">Boolean operators</span>.</p>
			</section>

			<section id="python_boolean_operators" class="grid-item">
				<h4>Boolean Operators</h4>
				<p>The <span class="italicsText">Boolean operators</span> are what allow us to connect, or link, particular conditions. These operators are the following:</p>
				<figure>
					<table>
						<thead>
							<th>Boolean operator</th>
							<th>Meaning</th>
						</thead>
						<tbody>
							<tr>
								<td><span class="monoText"><span class="redText">not</span> a</span></td>
								<td>If <span class="monoText">a</span> evaluates to <span class="monoText">True</span>, then <span class="monoText">not a</span> evaluates to <span class="monoText">False</span>; if <span class="monoText">a</span> evaluates to <span class="monoText">False</span>, then <span class="monoText">not a</span> evaluates to <span class="monoText">True</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">a <span class="redText">and</span> b</span></td>
								<td>If, and only if, <span class="monoText">a</span> evaluates to <span class="monoText">True</span> <span class="italicsText">and</span> <span class="monoText">b</span> evaluates to <span class="monoText">True</span>, then <span class="monoText">a and b</span> evaluates to <span class="monoText">True</span>; otherwise, <span class="monoText">a and b</span> evaluates to <span class="monoText">False</span>.</td>
							</tr>
							<tr>
								<td><span class="monoText">a <span class="redText">or</span> b</span></td>
								<td>If <span class="monoText">a</span> evaluates to <span class="monoText">True</span>, <span class="monoText">b</span> evaluates to <span class="monoText">True</span>, <span class="italicsText">or</span> both <span class="monoText">a</span> and <span class="monoText">b</span> evaluate to <span class="monoText">True</span>, then <span class="monoText">a or b</span> evaluates to true; if, and only if, <span class="monoText">a</span> evaluates to <span class="monoText">False</span> <span class="italicsText">and</span> <span class="monoText">b</span> evaluates <span class="monoText">False</span>, then <span class="monoText">a or b</span> evaluates to <span class="monoText">False</span>.</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>Note that the <span class="italicsText">equality operator</span> (<span class="monoText">==</span>) and the <span class="italicsText">nonequality operator</span> (<span class="monoText">!=</span>) <span class="underlineText">do not</span> test for equality of type. They only test for equality of value:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: 5/2 == 5/2.0
					out[1]: True
					in [2]: 5*2 == 5.0*2.0
					out[2]: True
				</code></pre>
				<p>If we wanted to check for equality of type, we would write:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: type(5*2) == type(5.0*2.0)
					out[1]: False
				</code></pre>
			</section>

			<section id="boolean_operator_precedence" class="grid-item">
				<h5>Boolean Operators: Order of Precedence</h5>
				<p>Like the arithmetic operators, Boolean operators in Java follow an order of precedence:</p>
				<ol>
					<li>Python always looks at expressions inside parentheses first.</li>
					<li>Inside the parentheses, or once the parentheses have been evaluated, <span class="monoText">NOT</span> statements are evaluated first.</li>
					<li><span class="monoText">AND</span> statements evaluated second.</li>
					<li><span class="monoText">OR</span> statements are evaluated last.</li>
				</ol>
			</section>

			<section id="branching_programs" class="grid-item">
				<h4>Branching</h4>
				<p>To use the comparison and Boolean operators, we need <span class="italicsText">branching statements</span>. Branching statements are what allow to write <span class="boldItalics">branching programs</span> &mdash; programs that consist of three parts:</p>
				<ol>
					<li>A <span class="boldItalics">test</span> &mdash; a Boolean expression;</li>
					<li>A <span class="boldItalics">block</span> &mdash; a specified section, or sequence, of code to execute if the <span class="italicsText">test</span> returns <span class="monoText">True</span>;</li>
					<li>An <span class="boldItalics">optional block</span> &mdash; an (optional) <span class="italicsText">block</span> to execute if the test is <span class="monoText">False</span>.</li>
				</ol>
				<p>The general structure of a branching program looks like:</p>
				<figure><img src="images/branching_program.svg" alt="branching" class="fifty-p"></figure>
				<p>With branching, we can write much more interesting programs:</p>
				<pre class="language-python"><code>
					x = int(input('Enter an integer: '))
					if x%2 == 0:
						print('')
						print('Even')
					else:
						print('')
						print('Odd')
					print('Done with conditional')
				</code></pre>
				<p>As we can likely guess, the code above takes an <span class="monoText">int</span> input from the user, and outputs to the console whether the <span class="monoText">int</span> is an even or odd number. The word <span class="monoText">if</span> indicates a true block &mdash; "execute the following code if this test return <span class="monoText">True</span>. The word <span class="monoText">else</span> indicates a false block &mdash; "execute the following code if the test returns <span class="monoText">False</span>. Note the difference between Python and many other languages like C or Java. We do not need additional characters to indicate a block. The fact that the lines below the <span class="monoText">if</span> and <span class="monoText">else</span> are indented tells Python that the indented code is a block.</p>
				<p>We can create more complex tests by <span class="boldItalics">nesting</span> conditionals:</p>
				<pre class="language-python"><code>
					if x%2 == 0:
						if x%3 == 0:
							print('Divisible by 2 and 3')
						else:
							print('Divisible by 2 but not 3')
					elif x%3 == 0:
						print('Divisible by 3 but not 2')
				</code></pre>
				<p>Notice the word <span class="monoText">elif</span>. This is the Python equivalent of <span class="monoText">else if</span> in many other languages. It is what we use to introduce a <span class="italicsText">second</span> true block. We can make our tests even more complex with <span class="boldItalics">compound Boolean expressions</span>:</p>
				<pre class="language-python"><code>
					if x < y and x < z:
						print('x is least')
					elif x < z:
						print('y is least')
					else:
						print('z is least')
				</code></pre>
				<p>In the code above, we have two true blocks (introduced by <span class="monoText">if</span> and <span class="monoText">elif</span>) and one false block (introduced by <span class="monoText">else</span>).</p>
				<p>Caution: When using <span class="monoText">if ... elif ... else</span>, the program will exit out of all of the branches the moment it executes exactly one true or false block. Thus:</p>
				<pre class="language-python"><code>
					temp = 120
					if temp > 85:
						print("Hot")
					elif temp > 100:
						print("Scorching")
					elif temp > 60:
						print("Tepid")
					else:
						print("Cold")
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					'Hot'
				</code></pre>
				<p>The above code outputs <span class="monoText">'Hot'</span> because the very first test evaluates to true, so Python executes its code block and continues outside the branches.</p>
			</section>

			<section id="strings_in_python" class="grid-item">
				<h4>Strings in Python</h4>
				<p>In Python, letters, special characters, spaces, and digits <span class="italicsText">enclosed in quotation marks or single quotes</span> are data objects of type <span class="monoText">str</span> (strings). The data type <span class="monoText">char</span>, a type present in languages like C and Java, does not exist in Python. All textual data fall under the type <span class="monoText">str</span>. For example:</p>
				<pre class="language-python"><code>
					hi = "hello world"
					greeting = 'hello'
				</code></pre>
				<p>We can combine strings in Python by <span class="boldItalics">concatenating</span> them:</p>
				<pre class="language-python"><code>
					hi = "hello"
					name = "torvald"
					greet = hi + name # returns "hitorvald" 
					greeting = hi + " " + name # returns "hi torvald"
				</code></pre>
				<p>Alternatively, we can <span class="boldItalics">format</span> strings in Python with curly braces:</p>
				<pre class="language-python"><code>
					name = "torvald"
					greeting = f"hi {name}"
					print(greeting)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					hi torvald
				</code></pre>
				<p>In the code above, the string bound to <span class="monoText">greeting</span> is called an <span class="boldItalics">f-string</span> ("format string") &mdash; a string containing initialized variables. When we create strings in this way (embedding variables inside the string) we are <span class="boldItalics">interpolating</span> a string. Variables in formatted strings are enclosed in curly braces, and the string is preceded by the character <span class="monoText">f</span>. By prefacing with <span class="monoText">f</span>, we tell Python, "Hey, this is not just any string, it's a formatted string, so treat it as such."</p>
				<p>We can perform a number of operations on strings in addition to concatenating them. We can <span class="boldItalics">successively concatenate</span> strings:</p>
				<pre class="language-python"><code>
					3* 'sam' # returns 'samsamsam'
				</code></pre>
				<p>We can find obtain a string's <span class="boldItalics">length</span>. This returns a data object of type <span class="monoText">int</span>.</p>
				<pre class="language-python"><code>
					len('sam') # returns 3 (this includes spaces)
				</code></pre>
				<p>Strings are our first example of a <span class="boldItalics">non-scalar data object</span>. Strings have an internal structure that we can access. As we saw in C, strings are arrays of characters, so we can obtain a particular character in a string with its index:</p>
				<pre class="language-python"><code>
					'sam'[1] # returns 'a'
					'sam'[0] # returns 's'
				</code></pre>
				<p>Note, however, that strings are an <span class="boldItalics">immutable type</span>. Data objects of immutable type are objects that <span class="italicsText">cannot</span> be modified:</p>
				<pre class="language-python"><code>
					s = "hello"
					s[0] = 'y' # returns an error
					s = 'y' + s[1:len(s)] # this is ok; s is a new data object
				</code></pre>
				<p>Passing a negative number into the array brackets returns the character starting from last to first, with the number <span class="monoText">-1</span> indicating the last:</p>
				<pre class="language-python"><code>
					'hello'[-1] # returns 'o'
					'hello'[-2] # returns 'l'
					'hello'[-3] # returns 'l'
					'hello'[-4] # returns 'e'
					'hello'[-5] # returns 'h'
				</code></pre>
				<p>Note that since <span class="monoText">len()</span> returns a data object of type <span class="monoText">int</span>, we can also pass <span class="monoText">len()</span> into array brackets:</p>
				<pre class="language-python"><code>
					str = 'hello'
					str[len(str)-1] # returns o
				</code></pre>
				<p>We can <span class="boldItalics">slice</span> a string:</p>
				<pre class="language-python"><code>
					'eric'[1:3] # returns 'ri'
				</code></pre>
				<p>Thus, slicing a string takes the following form:</p>
				<pre class="language-pseudo"><code>
					string[i:j]

					returned string is: 
						string[i]+string[j-1] 
				</code></pre>
				<p>More explicitly, in the Python example above, the number <span class="monoText">1</span> indicates the starting point for the slice, and the number <span class="monoText">3</span> indicates the ending point for the slice. The slice includes the character at the starting point, but excludes the character at ending point. But, we do not have to include both numbers for the slice.</p>
				<pre class="language-python"><code>
					'eric'[:3] # returns 'eri'
					'eric'[1:] # returns 'ric'
				</code></pre>
				<p>If we omit the starting index, Python assumes our slice starts at index 0. If we omit the ending index, Python assumes we want our slice to end at the end of the string.</p>
				<p>We can also make a <span class="italicsText">copy</span> of the string:</p>
				<pre class="language-python"><code>
					'eric'[:] # returns 'eric'
				</code></pre>
				<p>We can also pass a third number:</p>
				<pre class="language-pseudo"><code>
					string[i:j:k]
				</code></pre>
				<p>The <span class="monoText">k</span> represents the <span class="boldItalics">step size</span> for the slice. For example:</p>
				<pre class="language-python"><code>
					s = 'Python is fun!'
					s[1:12:2] # returns 'yhni u'
				</code></pre>
				<p>If we pass a negative number into the step parameter, we count backwards:</p>
				<pre class="language-python"><code>
					str = 'helloworld'
					str[::-1] # returns 'dlrowolleh'
					palindrome = 'racecar'
					palindrome[::-1] # returns 'racecar'
				</code></pre>
				<p>Finally, we can also check whether a particular <span class="boldItalics">substring</span> is inside a string with the following syntax:</p>
				<pre class="language-pseudo"><code>
					element <span class="redText">in</span> colctn
					element <span class="monoText">not in</span> colctn
				</code></pre>
				<p>The word <span class="monoText">in</span> asks, "Is this element inside this collection?" The question returns either <span class="monoText">True</span> or <span class="monoText">False</span>. The same goes for the word <span class="monoText">not in</span>: "Is this element NOT inside this collection?" The words <span class="monoText">in</span> and <span class="monoText">not in</span> are what we use to test whether a particular data object is a member of a particular <span class="italicsText">collection</span> of data objects. Strings are an example of a collection of data objects.</p>
				<pre class="language-python"><code>
					str = 'world'
					'a' in str # returns False
				</code></pre>
				<p>Building off of this idea, suppose we ask for a user to vote yes or no, and output back confirmation. Suppose the user might input <span class="monoText">'y'</span>, <span class="monoText">'Y'</span>, <span class="monoText">'yes'</span>, <span class="monoText">'Yes'</span>, or <span class="monoText">'YES'</span>. Assume that abstaining counts as a no vote. One way to implement this would be to write:</p>
				<pre class="language-python"><code>
					ans = input('Do you support this proposition: ')
					if ans == 'y' or ans == 'Y' or ans == 'yes' or ans == 'Yes' or ans == 'YES':  
						print('You voted yes')
					else
						print('You voted no')
				</code></pre>
				<p>The above is unwiedly and long. We can use the previous idea of testing for whether a data objection is in a particular collection:</p>
				<pre class="language-python"><code>
					if ans in ['y', 'Y' 'yes', 'Yes', 'YES']:
						print('You voted yes')
					else
						print('You voted no')
				</code></pre>
			</section>

			<section id="input_and_output_in_python" class="grid-item">
				<h4>Input and Output in Python</h4>
				<p>The keyword <span class="monoText">print()</span> in Python <span class="italicsText">outputs</span> data objects to the console. When we use <span class="monoText">print()</span>, we can pass in multiple arguments. </p>
				<pre class="language-python"><code>
					x = 1
					print(x) # output: 1
					x_str = str(x) # cast x into a string
					print("The loneliest number is", x, ".") 
					# output: "The loneliest number is 1 ."
					print("The loneliest number is" + x_str + ".")
					# output: "The loneliest number is 1."
				</code></pre>
				<p>Notice the spacing. When we used commas, we passed in multiple arguments, so each output is separated by one space. When we used the addition operator (<span class="monoText">+</span>), we <span class="italicsText">concatenated</span> multiple strings to form a single string to output.</p>
				<p>To obtain user input in Python, we use the keyword <span class="monoText">input()</span>. Once the user enters that input, we can bind the input's value to a name (store it inside a variable) for later reference. For example:</p>
				<pre class="language-python"><code>
					user_hometown = input("Please enter your hometown: ")
					print(user_hometown)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					Please enter your hometown: Palo Alto
					Palo Alto
				</code></pre>
				<p>The code above takes the user's input after being prompted <span class="monoText">"Please enter your hometown: "</span>. On enter, that input's value, say <span class="monoText">"Oconomowoc"</span> is stored in the variable <span class="monoText">user_hometown</span>.</p>
				<p><span class="monoText">input()</span> will <span class="underlineText">always return a string</span> value. This means that if we ask for number inputs from a user and seek to use those inputs as numbers, we must cast them:</p>
				<pre class="language-python"><code>
					age = int(input("Please enter your age: "))
					print(age)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					Please enter your age: 30
					30
				</code></pre>
				<p>Failing to cast when we want particular data types can lead to unusual results:</p>
				<pre class="language-python"><code>
					x = input("x: ")
					y = input("y: ")
					print(x + y)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					x: 8
					y: 9
					89
				</code></pre>
				<p>Note, however, that we also do not want to cast strings when we actually expect strings:</p>
				<pre class="language-python"><code>
					x = int(input("x: "))
					y = int(input("y: "))
					print(x + y)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					x: hot
					Traceback (most recent call last):
						File "example.py", line 1, in &lt;module&gt;
					ValueError: invalid literal for int() with base 10
				</code></pre>
				<p>The error above tells us that we've attempted to cast a non-numeric data object into a data object of type <span class="monoText">int</span>. We cannot do so.</p>
			</section>

			<section id="python_loops" class="grid-item">
				<h3><span class="monoText">while</span> &amp; <span class="monoText">for</span> Loops in Python</h3>
				<p>With the code we've written so far, our programs run in only one direction &mdash; they can only go down, we cannot go back up and repeat code. To do so, we need <span class="boldItalics">loops</span>.</p>

				<p class="subheading">The <span class="monoText">while</span> Loop</p>
				<p>Suppose that we want to <span class="underlineText">always</span> perform some action $x$ if, and only if, the condition $n$ is true. To do so, we would use a <span class="boldText monoText">while</span> loop. In Python, the <span class="monoText">while</span> loop takes the form:</p>
				<pre class="language-pseudo"><code>
					<span class="purpleText">while</span> <span class="greenText">condition-x</span>:
						<span class="blueText">expression-n</span>
						<span class="redText">expression-y</span>
				</code></pre>
				<p>In the code above,</p>
				<ul>
					<li><span class="monoText greenText">condition-x</span> ${\coloneqq}$ the condition that must always be <span class="monoText">True</span> for the <span class="monoText">while</span> loop to continue.</li>
					<li><span class="monoText blueText">expression-n</span> ${\coloneqq}$ the expression(s) executed when <span class="monoText">x</span> is <span class="monoText">True</span>.</li>
					<li><span class="monoText redText">expression-y</span> ${\coloneqq}$ code that either returns <span class="monoText">x</span> <span class="monoText">True</span> or <span class="monoText">False</span>. </li>
				</ul>
				<p>We want to make sure that <span class="monoText">m</span> will at some point cause <span class="monoText">x</span> to be <span class="monoText">False</span>; otherwise, the loop will never end. Here is an actual example:</p>
				<pre class="language-python"><code>
					n = 0
					while n < 5:
						print(n)
						n = n + 1
				</code></pre>
				<p>Notice the way the code above is structured. We initialize a variable to be used by the test <span class="italicsText">outside</span> the <span class="monoText">while</span> loop. Then, we include in the loop's <span class="boldItalics">body</span> the code we want to execute if the test returns <span class="monoText">True</span>. At the very last line, we include an expression that changes the variable we declared &mdash; this ensures that the <span class="monoText">while</span> loop's test condition eventually returns <span class="monoText">False</span>. Running the code in a shell:</p>
				<pre class="language-bash" data-output=""><code>
					in [1]: while(n < 5):
					...: print(n)
					...: n = n+1
					...:
					0
					1
					2
					3
					4
				</code></pre>
				<p>Suppose we wanted to sum numbers starting from <span class="monoText">1</span> to some number <span class="monoText">end</span>. A <span class="monoText">while</span> loop is ideal:</p>
				<pre class="language-python"><code>
					summation = 0
					current = 1
					end = 8
					while current <= end:
						summation += current
						current += 1
					print(summation)
				</code></pre>
				<p>There are two problems with the <span class="monoText">while</span> loop: (1) We can forget to initialize <span class="monoText">n</span> before the <span class="monoText">while</span> loop, in which case we get an error; or (2) we can forget to include the expressions that change the value bound to <span class="monoText">n</span>, in which case our loop will run until our program crashes.</p>
				<p>Whenever we use a <span class="monoText">while</span> loop, or any loop for that matter, we must pay careful attention to the number of iterations:</p>
				<pre class="language-python"><code>
					n = 0
					while n <= 5:
						print(n)
						n += 1
					print("Outside of loop")
					print(num)
				</code></pre>
				<p>The code above outputs the following:</p>
				<pre class="command-line language-bash" data-output=""><code>
					0
					1
					2
					3
					4
					5
					'Outside of loop'
					6
				</code></pre>
				<p>The final value assigned to <span class="monoText">n</span> is <span class="monoText">6</span>, because the loop ran one more time. The same goes for this code:</p>
				<pre class="language-python"><code>
					n = 10
					while n > 3:
						n -= 1
						print(n)
				</code></pre>
				<p>Output:</p>
				<pre class="command-line language-bash" data-output=""><code>
					9
					8
					7
					6
					5
					4
					3
				</code></pre>

				<p class="subheading">The <span class="monoText">for</span> Loop</p>
				<p>A much more convenient loop is the <span class="monoText">for</span> loop. The <span class="monoText">for</span> loop has the following syntax:</p>
				<pre class="language-pseudo"><code>
					<span class="purpleText">for</span> <span class="blueText">n</span> <span class="purpleText">in</span> <span class="greenText">range(i)</span>:
						<span class="redText">expression-y</span>
				</code></pre>
				<p>The syntax above has several parts:</p>
				<ol>
					<li><span class="monoText purpleText">for</span> ${\coloneqq}$ a keyword telling Python this is a <span class="monoText">for</span> loop</li>
					<li><span class="monoText blueText">n</span> ${\coloneqq}$ the variable we use for the <span class="monoText">for</span> loop's test condition</li>
					<li><span class="monoText greenText">range(i)</span> ${\coloneqq}$ a range starting at <span class="monoText">0</span> and ending <span class="italicsText">before</span> <span class="monoText">i</span>, where <span class="monoText">i</span> is some <span class="monoText">int</span>. The number <span class="monoText">i</span> is also called the <span class="boldItalics">accumulator</span>.</li>
					<li><span class="monoText purpleText">in</span> ${\coloneqq}$ a keyword that tells Python to test whether <span class="monoText">n</span> is inside <span class="monoText">range(i)</span></li>
					<li><span class="monoText redText">expression-y</span> ${\coloneqq}$ the expression(s) to execute if <span class="monoText">n</span> is inside <span class="monoText">range(i)</span>.</li>
				</ol>
				<p>Thus, the <span class="monoText">while</span> loop example above can be simply written as:</p>
				<pre class="language-python"><code>
					for n in range(5):
						print(n)
				</code></pre>
				<p>As a shell session:</p>
				<pre class="command-line language-bash" data-output=""><code>
					in [1]: for n in range(5):
					...: print(n)
					...:
					0
					1
					2
					3
					4
				</code></pre>
				<p>Alternatively, <span class="monoText">for</span> loops in Python can be written by providing a list of numbers:</p>
				<pre class="language-python"><code>
					for i in [0, 1, 2]:
						print('Hi')
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					Hi
					Hi
					Hi
				</code></pre>
				<p>The problem, of course, is that this method is inefficient and infeasible when it comes to large numbers of iterations. The example, however, reveals how <span class="monoText">range()</span> works. The output of <span class="monoText">range(3)</span> is <span class="monoText">[0, 1, 2]</span>. Thus, the code above is exactly the same as:</p>
				<pre class="language-python"><code>
					for i in range(3)
						print('Hi')
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					Hi
					Hi
					Hi
				</code></pre>
				<p>The use of <span class="monoText">range()</span> to determine iteration is perhaps the starkest example of <span class="italicsText">pythonic</span> syntax. The word <span class="italicsText">pythonic</span> is used to describe Python conventions so deeply rooted in the Python community that it would be odd not to follow.</p>

				<p class="subheading">Manipulating the <span class="monoText">range()</span></p>
				<p>We can manipulate how our range looks like with the following syntax:</p>
				<pre class="language-pseudo"><code>
					range(<span class="greenText">start</span>,<span class="redText">stop</span>,<span class="blueText">step</span>)
				</code></pre>
				<p>In the syntax above:</p>
				<ol>
					<li><span class="monoText greenText">start</span> ${\coloneqq}$ the start of the range; by default this is set to <span class="monoText">0</span></li>
					<li><span class="monoText redText">stop</span> ${\coloneqq}$ the end of the range; the loop will continue until <span class="monoText">stop-1</span></li>
					<li><span class="monoText blueText">step</span> ${\coloneqq}$ the difference between each element of the range; by default this is set to <span class="monoText">1</span>.</li>
				</ol>
				<p>For example, suppose we wanted to print the even numbers up to 10, then print out <span class="monoText">'Loop exited'</span>:</p>
				<pre class="language-python"><code>
					i = 0
					for i in range(0, 10, 2):
						i += 2
						print(i)
					print('Loop exited')
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					2
					4
					6
					8
					10
					'Loop exited'
				</code></pre>
				<p>We can also pass negative numbers as a <span class="monoText">step</span> argument to count down:</p>
				<pre class="language-python"><code>
					i = 12
					for i in range(12, 2, -2):
						i -= 2
						if i == 10:
							print('Countdown beginning')
						print(i)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					'Countdown beginning'
					10
					8
					6
					4
					2
				</code></pre>
				<p>Alternatively:</p>
				<pre class="language-python"><code>
					print('Countdown beginning')
					for i in range(10, 0, -2):
						print(i)
				</code></pre>
				<p>Using a <span class="monoText">for</span> loop for the summation program we wrote above with a <span class="monoText">while</span> loop:</p>
				<pre class="language-python"><code>
					summation = 0
					current = 1
					end = 8
					for current in range(1, end+1):
						total += current
						current += 1
					print(total)
				</code></pre>
				<p>Note that the variable we use in a <span class="monoText">for</span> loop as an incrementer will have its value changed. That changed value will remain the value bound to the incrementer after the <span class="monoText">for</span> loop has finished executing unless change it somewhere down the program:</p>
				<pre class="language-python"><code>
					i = 10
					for i in range(5) 
						print(i)
					print(i)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					0
					1
					2
					3
					4
					4
				</code></pre>


				<p class="subheading">The <span class="monoText">break</span> Statement</p>
				<p>Often, we want to immediately terminate a loop somewhere before the last expression in the loop's body. To do so, we use a <span class="monoText">break</span> statement:</p>
				<pre class="language-pseudo"><code>
					while <span class="greenText">condition-x</span>:
						while <span class="greenText">condition-y</span>:
							<span class="blueText">expression-n</span>
							<span class="redText">break</span>
							<span class="blueText">expression-m</span>
						<span class="blueText">expression-z</span>
				</code></pre>
				<p>When we include <span class="monoText">break</span> inside a <span class="monoText">while</span> loop's body, the loop will terminate at that point, exit out of the loop, continue going down the code. In the syntax above, once Python finishes execution <span class="monoText">expression-n</span>, it hits <span class="monoText">break</span> and gets out of the loop, never executing <span class="monoText">expression-m</span>. Here's an example:</p>
				<pre class="language-python"><code>
					sum = 0
					for i in range(5,11,2):
						sum += i
						if sum == 5:
							break
					print(sum)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					5
				</code></pre>
				<p>The output is <span class="monoText">5</span> in the code above because the loop terminated the moment <span class="monoText">i = 5</span>. Another example:</p>
				<pre class="language-python"><code>
					n = 10
					while True:
						if num < 7:
							print('Breaking now')
							break
						print(num)
						num -= 1
					print('Outside of loop')
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					10
					9
					8
					7
					'Breaking now'
					'Outside of loop'
				</code></pre>
				<p>If we do not use <span class="monoText">break</span> statements carefully, we can easily fall into an infinite loop:</p>
				<pre class="language-python"><code>
					n = 100
					while not False:
						if n < 0:
							break
					print('n = ' + str(n))
				</code></pre>
				<p>We never get to print our concatenated string because it <span class="monoText">100 < 0</span> is always <span class="monoText">False</span>. Since the <span class="monoText">if</span> condition is always <span class="monoText">False</span>, we never reach the <span class="monoText">break</span> statement, so the loop runs forever.</p>
				<p>The table below encapsulates when we might want to use a <span class="monoText">for</span> or <span class="monoText">while</span> loop:</p>
				<figure>
					<table class="heading_center">
						<thead>
							<th><span class="monoText">for</span> loop</th>
							<th><span class="monoText">while</span> loop</th>
						</thead>
						<tbody>
							<tr>
								<td>
									<ul>
										<li>We can iterate an exact amount of times.</li>
										<li>We can terminate early with <span class="monoText">break</span>.</li>
										<li>We can use a counter without having to initialize the counter before the loop.</li>
										<li>We can rewrite a <span class="monoText">while</span> loop as a <span class="monoText">for</span> loop.</li>
									</ul>
								</td>
								<td>
									<ul>
										<li>Ability to <span class="italicsText">always</span> iterate as long as a particular condition is true.</li>
										<ul>
											<li>Particularly useful if we want to run the loop <span class="italicsText">at least once</span>.</li>
										</ul>
										<li>We can terminate early with <span class="monoText">break</span>.</li>
										<li>We can use a counter, but it must be initialized before the loop, and it must be incremented inside the loop.</li>
										<li>We cannot always rewrite a <span class="monoText">while</span> loop as a <span class="monoText">for</span> loop.</li>
									</ul>
								</td>
							</tr>
						</tbody>
					</table>
				</figure>
			</section>

			<section id="iterating_a_string" class="grid-item">
				<h4>Iterating through a String in Python</h4>
				<p>Unlike many languages, Python allows us to easily iterate through a string:</p>
				<pre class="language-python"><code>
					for letter in 'hello':
						print(letter)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					'h'
					'e'
					'l'
					'l'
					'o'
				</code></pre>
				<p>The loop above works as such:</p>
				<ol>
					<li>Repeat this code until the last character is the current character (<span class="monoText">for</span>).</li>
					<li>First, declare a variable named <span class="monoText">letter</span> and assign it the current character in <span class="monoText">'hello'</span> (in this case 'h').</li>
					<li>Then, print <span class="monoText">letter</span>.</li>
					<li>Go back to step 1, and assign <span class="monoText">letter</span> to be next character in <span class="monoText">'hello'</span>.</li>
				</ol>
			</section>

			<section id="python_iteration" class="grid-item">
				<h4>The Value of Iteration</h4>
				<p>With <span class="monoText">for</span> and <span class="monoText">while</span> loops, significantly extends our ability to write programs. In particular, <span class="italicsText">iterative programs</span> are much more complex than <span class="italicsText">branching programs</span>, particularly when we nest loops or branches within loops.</p>
				<figure><img src="images/loop_flow.svg" alt="loop flow" class="thirty-p" loading="lazy"></figure>
				<p>Like branching programs, iterative programs start with a test. If the test returns <span class="monoText">True</span>, then Python proceeds to the loop body, executing the code therein. If the test returns <span class="monoText">False</span>, then Python skips or exits the loop's body, and continues outside the loop.</p>
				<p>To see how powerful iteration is, consider the following program:</p>
				<pre class="language-python"><code>
					x = 3
					square = 0
					iterations_left = x
					while (iterations_left != 0):
						square = square + x
						iterations_left = iterations_left - 1
					print(str(x) + '*' + str(x) + ' = ' + str(square))
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					3*3 = 9
				</code></pre>
				<p>The program computes ${x^2}$ by repeatedly adding ${x.}$ The program is structured based on a simple mathematical fact:</p>
				<figure class="math-display">
					<div>
						<p>${x^2 = (x + x) + (x + x)}$</p>
						<p>The pattern for this fact: Given ${x^2,}$ the result is the sum of adding $x$ for a total of ${x\text{-times.}}$</p>
					</div>
				</figure>
				<p>Thus, the code above is structured in the following order:</p>
				<ol>
					<li>Provide the value bound to $x$ (<span class="monoText">x = 3</span>).</li>
					<li>Initialize a variable to store our result in: <span class="monoText">square = 0</span>.</li>
					<li>Initialize a counter (to meet the requirement of adding ${n \text{-times;}}$ <span class="monoText">iterations_left = 0</span>).</li>
					<li>Then define the <span class="monoText">while</span> loop:</li>
					<ol>
						<li>Define the test: "Run this loop if, and only if, <span class="monoText">iterations_left != 0</span>.</li>
						<li>Define the truth block:</li>
						<ul>
							<li>Operation: <span class="monoText">square = square + x</span>.</li>
							<li>Counter increment: <span class="monoText">iterations_left = iterations_left - 1</span></li>
						</ul>
					</ol>
				</ol>
				<p>When the loop above executes, the iterations appear as such:</p>
				<figure>
					<table class="loop_table">
						<thead>
							<th>Iteration</th>
							<th>Computation</th>
							<th>Return</th>
						</thead>
						<tbody>
							<tr>
								<td>1</td>
								<td>
									<p><span class="monoText">square = 0 + 3</span></p>
									<p><span class="monoText">iterations_left = 3 - 1</span></p>
								</td>
								<td>
									<p><span class="monoText">square = 3</span></p>
									<p><span class="monoText">iterations_left = 2</span></p>
								</td>
							</tr>
							<tr>
								<td>2</td>
								<td>
									<p><span class="monoText">square = 3 + 3</span></p>
									<p><span class="monoText">iterations_left = 2 - 1</span></p>
								</td>
								<td>
									<p><span class="monoText">square = 6</span></p>
									<p><span class="monoText">iterations_left = 1</span></p>
								</td>
							</tr>
							<tr>
								<td>3</td>
								<td>
									<p><span class="monoText">square = 6 + 3</span></p>
									<p><span class="monoText">iterations_left = 1 - 1</span></p>
								</td>
								<td>
									<p><span class="monoText">square = 9</span></p>
									<p><span class="monoText">iterations_left = 0</span></p>
								</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>The example above demonstrates a difference between <span class="italicsText">branching structures</span> and <span class="italicsText">looping structures</span>: Branching structures allow us to move to different blocks of code based on a test, but only <span class="italicsText">once</span>. Thus, branching programs are in <span class="italicsText">constant time</span>. In contrast, looping structures allow us to <span class="italicsText">repeat</span> blocks of code over and over again until as long as a particular condition returns <span class="monoText">True</span>. This means that the amount of time a iterative, or looping, program takes depends on the values of the relevant variables, as well as the program's length. 
			</section>

			<section id="iteration_guess_and_check" class="grid-item">
				<h4>Iteration &amp; <span class="italicsText">Guess-and-check</span> Methods</h4>
				<p>Many computations involve repeating steps over and over again. Other computations are conducive to algorithms of the class <span class="boldItalics">guess-and-check</span>.</p>
				<p>The clearest example of a computation conducive to <span class="boldItalics">guess-and-check</span> is computing the square root of a number. The algorithm for computing square roots traces its origins all the way back to Heron of Alexandria. The algorithm works as such:</p>
				<ol>
					<li>Let $x$ be the number we want to square root.</li>
					<li>Make a guess; call it $g$.</li>
					<li>Improve the guess by averaging $g$ and ${x/g.}$</li>
					<li>Repeat step 3 until the difference between $g$ and the desired value is small enough.</li>
				</ol>
				<p>This algorithm only works if we have a means of generating guesses. <span class="italicsText">Guess-and-check</span> algorithms embody this concept &mdash; (1) generate a guess, (2) check the guess against some value, and (3) repeat the process over and over. Step (3) is precisely what we use loops for. Guess-and-check algorithms are also called <span class="boldItalics">exhausive enumerations</span> &mdash; they exhaust all of the possibilities to arrive at an output.</p>
				<p>Let's change the computation somewhat; instead of computing a square root, we will compute a cube root. Suppose we wanted to compute ${x^3}.$ First question: How do we generate a guess? Well, one way is to first try ${0^3.}$ Then we try ${1^3},$ then ${2^3,}$ then ${3^3,}$ and so on. We continue this process until we reach some number ${k,}$ where ${k^3 > x.}$ Obviously, this method only works for integers. The upside, however, is that there is a finite number of cases to test. Let's implement:</p>
				<pre class="language-python"><code>
					x = int(input('Enter an integer: '))
					cube = 0
					while cube**3 < x:
						cube = cube + 1
					if cube**3 != x:
						print(str(x) + ' is not a perfect cube')
					else:
						print('Cube root of ' + str(x) + ' is ' + str(cube))
				</code></pre>
				<p>In the code above, we first ask for input from the user. On entering, the input value is cast as an <span class="monoText">int</span>, and bound to the name <span class="monoText">x</span>. Then we initialized a variable named <span class="monoText">cube</span> with the value <span class="monoText">0</span>. Next, we proceed to the <span class="monoText">while</span> loop. The test condition here is <span class="monoText">cube**3 < x</span>. Thus, Python will test if <span class="monoText">cube**3 < x</span>: If the condition is true, <span class="monoText">cube</span> is incremented by <span class="monoText">1</span>, this continues until <span class="monoText">cube**3 >= x</span>.</p>
				<p>Then we test whether <span class="monoText">cube**3</span> is not equal to the value inputted by the user. If <span class="monoText">cube**3</span> is not equal to <span class="monoText">x</span>, we print the string therein. Otherwise, we return the cube root. Compiling the code above:</p>
				<pre class="command-line language-bash" data-output=""><code>
					Enter an integer: 27
					Cube root of 27 is 3
				</code></pre>
				<p>So, what happened above:</p>
				<figure>
					<table class="truth_table">
						<thead>
							<th>Iteration</th>
							<th>Test</th>
							<th>Computation</th>
							<th>Return</th>
						</thead>
						<tbody>
							<tr>
								<td>1</td>
								<td>0**3 < 27 == True</td>
								<td>cube = 0 + 1</td>
								<td>cube = 1</td>
							</tr>
							<tr>
								<td>2</td>
								<td>1**3 < 27 == True</td>
								<td>cube = 1 + 1</td>
								<td>cube = 2</td>
							</tr>
							<tr>
								<td>3</td>
								<td>2**3 < 27 == True</td>
								<td>cube = 2 + 1</td>
								<td>cube = 3</td>
							</tr>
							<tr>
								<td>4</td>
								<td>3**3 < 27 == False ; exit loop</td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td colspan="3">
									<p>Test: 3**3 != 3</p>
								</td>
								<td>False</td>
							</tr>
							<tr>
								<td colspan="4">
									<p>(print('Cube root of ' + str(x) + ' is ' + str(cube)))</p>
								</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>In sum, the code above used a loop to generate guesses, checking those guesses over and over again. An obvious shortcoming with our program is that it does not cover all cases. What if the user enters a negative integer? The fix:</p>
				<pre class="language-python"><code>
					x = int(input('Enter an integer: '))
					cube = 0
					while cube**3 < abs(x):
						cube = cube + 1
					if cube**3 != abs(x):
						print(str(x) + ' is not a perfect cube')
					else:
						if x < 0:
							cube = - cube
						print('Cube root of ' + str(x) + ' is ' + str(ans))
				</code></pre>
				<p>The fix above uses Python's built-in function <span class="monoText">abs()</span> to return the absolute value of <span class="monoText">x</span> (a positive number). When we output the result, we simply check whether <span class="monoText">x</span> is a negative number. If it is, we set <span class="monoText">cube</span> equal to the negative of the number.</p>
				<p>Whenever we work with <span class="monoText">while</span> loops, we need a loop variable. That <span class="italicsText">loop variable</span> must satisfy three criteria:</p>
				<ol>
					<li>The loop variable is initialized <span class="italicsText">outside</span> the loop;</li>
					<li>The loop variable changes <span class="italicsText">inside</span> the loop; and</li>
					<li>The loop's test condition depends on the variable's value.</li>
				</ol>
				<p>A helpful thought process when constructing loops is to come up with a <span class="boldItalics">decrementing function</span>. In the example above, the decrementing function is <span class="monoText">abs(x) - cube**3</span>. When Python first enters the loop, the value of <span class="monoText">abs(x) - cube**3</span> is a nonnegative number. Everytime Python goes through the loop, the value decreases over and over. Once the value of <span class="monoText">abs(x) - cube**3</span> is less than or equal to <span class="monoText">0</span>, the loop terminates. Thinking about loops through decrementing functions often yields a clearer understanding of when a loop ends.</p>
				<p>Failing the three criteria above can lead to disaster. If we fail to change the variable inside the loop, we enter an infinite loop. If we fail to initialize a variable we will most likely get back a <span class="monoText">NameError</span>. This error is returned because we're attempting to use a variable inside a loop that has not been defined before the loop. A far worse outcome results when we've used the variable somewhere outside the loop for some other purpose, and reuse it in our loop without assigning it a new value. This can cause the loop to initiate the computation and return unexpected results; far worse than a <span class="monoText">NameError</span> because we won't get any error messages from Python.</p>
				<p>Although guess-and-check algorithms are slow and prone to error, they are often easy to implement. Moreover, with advancements in computer processing speeds, many guess-and-check algorithms previously considered inefficient are becoming more common place.</p>
				<p>In the example above, we used a <span class="monoText">while</span> loop. We can be more efficient with a <span class="monoText">for</span> loop:</p>
				<pre class="language-python"><code>
					cube = int(input('Enter an integer: '))
					for guess in range(cube+1):
						if guess**3 == cube:
							print("Cube root of ", cube, " is ", guess)
				</code></pre>
				<pre class="command-line language-bash" data-output=""><code>
					Enter an integer: 8
					Cube root of 8 is 2
				</code></pre>
				<p>In the code above, we used a <span class="monoText">for</span> loop, premised on the fact that the cube root of a number must be less than the cube. Thus, we set <span class="monoText">range(cube+1)</span>, this generates all of the possibilities we want to check. In the shell, we entered <span class="monoText">8</span>, so <span class="monoText">cube = 8</span>, and the possiblities are <span class="monoText">0, 1, 2, 3, 4, 5, 6, 7,</span> and <span class="monoText">8</span>. The loop starts at <span class="monoText">guess = 0</span>, and continues up until <span class="monoText">guess = 8</span> (remember, the <span class="monoText">range()</span> does not include the <span class="monoText">stop</span> value). Inside the loop, we keep testing whether <span class="monoText">guess**3 == cube</span>. Once that test returns <span class="monoText">True</span>, we print out the relevant string.</p>
				<p>The problem with the code above: It will not print anything out if there is no cube root in the range of possibilities:</p>
				<pre class="command-line language-bash" data-output=""><code>
					Enter an integer: 17
				</code></pre>
				<p>There is no output. This is a case we did not think of with the code above. We revise:</p>
				<pre class="language-python"><code>
					cube = int(input('Enter an integer: '))
					for guess in range(abs(cube)+1):
						if guess**3 == abs(cube):
							break
					if guess**3 != abs(cube):
						print(cube, 'is not a perfect cube')
					else:
						if cube < 0:
							guess = -guess
						print('Cube root of' + str(cube) ' is ' + str(guess))
				</code></pre>
				<p>The code above accomplishes two things: (1) We allow for negative integers, and (2) we print out something if there is no cube root.</p>
				<pre class="command-line language-bash" data-output="2,3,5,6,8"><code>
					Enter an integer: -27 
					Cube root of -27 is -3

					Enter an integer: 27
					Cube root of 27 is 3

					Enter an integer: 28
					28 is not a perfect cube
				</code></pre>
				<p>The examples demonstrate a core principle in computer science and mathematics: You must consider all possible cases.</p>
			</section>

			<section id="loop_exercises">
				<p><span class="exh">Exercise.</span> Consider:</p>
					<pre class="language-python"><code>
						str = '6.00x'

						for char in str:
							print(char)
						print('done')
					</code></pre>
					<ol>
						<li>How many times does <span class="monoText">6</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">6</span> will print exactly 1 time.</p>
						</details>
						<li>How many times does <span class="monoText">.</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">.</span> will print exactly 1 time.</p>
						</details>
						<li>How many times does <span class="monoText">0</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">0</span> will print exactly 2 times.</p>
						</details>
						<li>How many times does <span class="monoText">x</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">x</span> will print exactly 1 time.</p>
						</details>
						<li>How many times does <span class="monoText">done</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">1</span> will print exactly 1 time.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Consider:</p>
					<pre class="language-python"><code>
						greeting = 'Hello!'
						count = 0

						for letter in greeting:
							count += 1
							if count % 2 == 0:
								print(letter)
							print(letter)
						
						print ('done')
					</code></pre>
					<ol>
						<li>How many times does <span class="monoText">H</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">count</span> has an initial value of <span class="monoText">0</span>. Then, in the loop, <span class="monoText">count</span> is incremented by <span class="monoText">1</span>. We are also looping through each of the characters in the string bound to <span class="monoText">greeting</span>, which is <span class="monoText">'Hello!'</span>, a total of 6 characters. Thus, <span class="monoText">count</span> is incremented a total of 6 times:</p>
							<figure>
								<table class="loop_table">
									<thead>
										<th>Iteration</th>
										<th>Computation</th>
										<th>Return</th>
									</thead>
									<tbody>
										<tr>
											<td>1; <span class="monoText">letter = 'H'</span></td>
											<td><span class="monoText">count = 0 + 1</span></td>
											<td>
												<p><span class="monoText">count = 1</span></p>
												<p><span class="monoText">print('H')</span></p>
											</td>
										</tr>
										<tr>
											<td>2; <span class="monoText">letter = 'e'</span></td>
											<td><span class="monoText">count = 1 + 1</span></td>
											<td>
												<p><span class="monoText">count = 2</span></p>
												<p><span class="monoText">print('e')</span> (since 2 is divisible by 2)</p>
												<p><span class="monoText">print('e')</span></p>
											</td>
										</tr>
										<tr>
											<td>3; <span class="monoText">letter = 'l'</span></td>
											<td><span class="monoText">count = 2 + 1</span></td>
											<td>
												<p><span class="monoText">count = 3</span></p>
												<p><span class="monoText">print('l')</span></p>
											</td>
										</tr>
										<tr>
											<td>4; <span class="monoText">letter = 'l'</span></td>
											<td><span class="monoText">count = 3 + 1</span></td>
											<td>
												<p><span class="monoText">count = 4</span></p>
												<p><span class="monoText">print('l')</span> (since 4 is divisible by 2)</p>
												<p><span class="monoText">print('l')</span></p>
											</td>
										</tr>
										<tr>
											<td>5; <span class="monoText">letter = 'o'</span></td>
											<td><span class="monoText">count = 4 + 1</span></td>
											<td>
												<p><span class="monoText">count = 5</span></p>
												<p><span class="monoText">print('o')</span></p>
											</td>
										</tr>
										<tr>
											<td>6; <span class="monoText">letter = '!'</span></td>
											<td><span class="monoText">count = 5 + 1</span></td>
											<td>
												<p><span class="monoText">count = 6</span></p>
												<p><span class="monoText">print('!')</span> (since 6 is divisible by 2)</p>
												<p><span class="monoText">print('!')</span></p>
											</td>
										</tr>
									</tbody>
								</table>
							</figure>
							<p>From the table above, the character <span class="monoText">'H'</span> prints exactly 1 time.</p>
						</details>
						<li>How many times does <span class="monoText">'e'</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">e</span> prints exactly 2 times.</p>
						</details>
						<li>How many times does <span class="monoText">l</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">l</span> prints exactly 3 times.</p>
						</details>
						<li>How many times does <span class="monoText">o</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">'o'</span> prints exactly 1 time.</p>
						</details>
						<li>How many times does <span class="monoText">'!'</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">'!'</span> prints exactly 2 times.</p>
						</details>
						<li>How many times does <span class="monoText">'done'</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The string <span class="monoText">'done'</span> prints exactly 1 time; it is outside of the loop.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Consider:</p>
					<pre class="language-python"><code>
						school = 'Massachusetts Institute of Technology'
						numVowels = 0
						numCons = 0

						for char in school:
							if char == 'a' or char == 'e' or char == 'i' \
								or char == 'o' or char == 'u':
									numVowels += 1
							elif char == 'o' or char == 'M':
								print(char)
							else:
								numCons -= 1
						print('numVowels is: ' + str(numVowels))
						print('numCons is: ' + str(numCons))
					</code></pre>
					<ol>
						<li>How many times does <span class="monoText">'o'</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The character <span class="monoText">'o'</span> prints exactly 0 times (it never prints). The line <span class="monoText">print(char)</span> never occurs when <span class="monoText">char == 'o'</span> because the condition is satisfied in the previous true block. Remember, Python will not execute any further code if a condition is satisfied.</p>
						</details>
						<li>How many times does <span class="monoText">'M'</span> print?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>Here, <span class="monoText">'M'</span> prints exactly 1 time.</p>
						</details>
						<li>What will the value of the variable <span class="monoText">numVowels</span> be?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">numVowels == 11</span>. The character <span class="monoText">'I'</span> is never counted because the test is only for the characters <span class="monoText">a, e, i, o, u</span>. Upper and lower case characters are different characters!</p>
						</details>
						<li>What will the value of the variable <span class="monoText">numCons</span> be?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">numCons == -25</span>. Counting all of the consonants, there are a total of 22 consonants. But, we must subtract the character <span class="monoText">'M'</span>, because when the loop ran and <span class="monoText">char == 'M'</span>, the previous truth block was executed, so <span class="monoText">numCons -= 1</span> was never executed. This brings us down to 21. But, we must include the character <span class="monoText">'I'</span>, since <span class="monoText">char == 'I'</span> was never tested. This brings us back to 22. The remaining 3 "consonants" result from the spaces. Remember, spaces are characters. This brings us up to 25, as there are 3 spaces in the string <span class="monoText">'Massachussetts Institute of Technology'</span>. Note that the incrementer for <span class="monoText">numCons</span> is negative, so the final value is negative.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Consider:</p>
					<pre class="language-python"><code>
						iteration = 0
						count = 0
						while iteration < 5:
							for letter in "hello, world":
								count += 1
							print("Iteration " + str(iteration) + "; count is: " + str(count))
							iteration += 1
					</code></pre>
					<ol>
						<li>Does the following code output the same result?</li>
						<pre class="language-python"><code>
							for iteration in range(5):
								count = 0
								while True:
									for letter in "hello, world":
										count += 1
									print("Iteration " + str(iteration) + "; count is: " + str(count))
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>First, let's think about what the first sample code does. There, we have <span class="monoText">iteration = 0</span> and <span class="monoText">count = 0</span>. Next, we have a <span class="monoText">while</span> loop. The <span class="monoText">while</span> loop's test condition is <span class="monoText">iteration < 5</span>. So, as long as that condition is true, the code block in the <span class="monoText">while</span> loop's body will execute. Inside the <span class="monoText">while</span> loop, we have a <span class="monoText">for</span> loop. That <span class="monoText">loop</span> iterates through each character in the string <span class="monoText">"hello, world"</span>. There are 12 characters in that string, so the <span class="monoText">for</span> loop iterates at most 12 times. For each of those iterations, we increment <span class="monoText">count</span> by <span class="monoText">1</span>. This brings <span class="monoText">count</span> all the way up to 12 (we stay in the <span class="monoText">for</span> loop until we've iterated through the entire string <span class="monoText">"hello, world"</span>). Once we've looped through the entire string, we print out the relevant string inside <span class="monoText">print()</span>. Finally, we increment <span class="monoText">iteration</span> by <span class="monoText">1</span>, and continue over and over.</p>
							<p>Putting this process together:</p>
							<figure>
								<table class="loop_table">
									<thead>
										<th>Iteration</th>
										<th>Return</th>
									</thead>
									<tbody>
										<tr>
											<td>1</td>
											<td>
												<p><span class="monoText">count = 12</span></p>
												<p><span class="monoText">"Iteration 0; count is 12</span></p>
											</td>
										</tr>
										<tr>
											<td>2</td>
											<td>
												<p><span class="monoText">count = 24</span></p>
												<p><span class="monoText">"Iteration 1; count is 24</span></p>
											</td>
										</tr>
										<tr>
											<td>3</td>
											<td>
												<p><span class="monoText">count = 36</span></p>
												<p><span class="monoText">"Iteration 2; count is 36</span></p>
											</td>
										</tr>
										<tr>
											<td>4</td>
											<td>
												<p><span class="monoText">count = 48</span></p>
												<p><span class="monoText">"Iteration 3; count is 48</span></p>
											</td>
										</tr>
										<tr>
											<td>5</td>
											<td>
												<p><span class="monoText">count = 60</span></p>
												<p><span class="monoText">"Iteration 4; count is 60</span></p>
											</td>
										</tr>
									</tbody>
								</table>
							</figure>
							<p>The count ends at <span class="monoText">60</span>, because the moment <span class="monoText">iteration = 5</span>, the <span class="monoText">while</span> loop's test condition returns <span class="monoText">False</span>, and the loop's body is never executed. Bearing all of this in mind, we can now compare the remaining sample code.</p>
							<p>In this first sample, the output is not the same. Here, we use a <span class="monoText">for</span> loop, with iterations <span class="monoText">0, 1, 2, 3, 4</span>. On each iteration, <span class="monoText">count = 0</span>, and a <span class="monoText">while</span> loop is executed. That <span class="monoText">while</span> loop is never exited, because there is no code that causes the <span class="monoText">while</span> loop's test condition to return <span class="monoText">False</span>.</p>
						</details>
						<li>Does the following code output the same result?</li>
						<pre class="language-python"><code>
							for iteration in range(5):
								count = 0
								while True:
									for letter in "hello, world":
										count += 1
									print("Iteration " + str(iteration) + "; count is:" + str(count))
									break
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>Here, another <span class="monoText">for</span> loop is used, with iterations of <span class="monoText">0 1 2 3 4</span>. For each iteration, <span class="monoText">count = 0</span>, and a <span class="monoText">while</span> loop is executed. Inside that <span class="monoText">while</span> loop, we iterate through each letter in the string <span class="monoText">"hello, world"</span>, a total of 12 iterations. Once that loop is exited, the string contained in <span class="monoText">print()</span> is printed. Then a <span class="monoText">break</span> statement is executed. The problem, however, is that we have not updated <span class="monoText">iteration</span> anywhere inside the <span class="monoText">while</span> loop. This does not return the same output as the original code.</p>
						</details>
						<li>Does the following code output the same result?</li>
						<pre class="language-python"><code>
							count = 0
							phrase = "hello, world"
							for iteration in range(5): 
								index = 0
								while index < len(phrase):
									count += 1
									index += 1
								print("Iteration " + str(iteration) + "; count is: " + str(count))
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>Here, we set <span class="monoText">count = 0</span> first, then we assigned the string <span class="monoText">"hello, world"</span> to a unique variable. Next, we use a <span class="monoText">for</span> loop, iterating through <span class="monoText">range(5)</span>. This yields a total of <span class="monoText">0, 1, 2, 3, 4</span> iterations. At each iteration, we set <span class="monoText">index = 0</span>. Then we execute a <span class="monoText">while</span> loop. As long as <span class="monoText">index</span> is less than the length of <span class="monoText">"hello, world"</span> (24), we stay inside the loop, executing its body. In this case, <span class="monoText">count</span> is incremented by <span class="monoText">1</span>, and <span class="monoText">index</span> is incremented by <span class="monoText">1</span>. The problem, however, is that the <span class="monoText">print()</span> statement is contained inside the <span class="monoText">for</span> loop. Instead of just one output statement, we obtain multiple. The output is not the same.</p>
						</details>
						<li>Does the following code output the same result?</li>
						<pre class="language-python"><code>
							count = 0
							phrase = "hello, world"
							for iteration in range(5): 
								while True:
										count += len(phrase)
										break
								print("Iteration " + str(iteration) + "; count is: " + str(count))
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>Here we set <span class="monoText">count = 0</span> and <span class="monoText">phrase = "hello, world"</span>. Then, we used a <span class="monoText">for</span> loop, iterating through <span class="monoText">range(5)</span>; a total of <span class="monoText">0, 1, 2, 3, 4</span> iterations. Inside the <span class="monoText">for</span> loop, we increment <span class="monoText">count</span> by the length of <span class="monoText">"hello, world"</span> (24). Then we break and output the result. This is not the same output.</p>
						</details>
						<li>Does the following code output the same result?</li>
						<pre class="language-python"><code>
							count = 0
							phrase = "hello, world"
							for iteration in range(5): 
								count += len(phrase)
								print("Iteration " + str(iteration) + "; count is: " + str(count))
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>Here, we set <span class="monoText">count = 0</span>. Then we assigned <span class="monoText">"hello, world"</span> to the variable <span class="monoText">phrase</span>. Next, we enter a <span class="monoText">for</span> loop, iterating through <span class="monoText">range(5)</span>; a total of <span class="monoText">0, 1, 2, 3, 4</span> iterations. In each iteration, we add to <span class="monoText">count</span> the length of <span class="monoText">phrase</span> (24). This is not the same output.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Write a program that counts up the number of vowels contained in a string inputted by the user. Prompt the user to enter a string of lower case letters.</p>
					<details class="answer">
						<summary>Answer</summary>
						<pre class="language-python"><code>
							s = str(input('Enter a string of lower case letters: '))
							vowels = 0
							for letters in s:
								if letter == 'a' or 
									letter == 'e' or 
									letter == 'i' or 
									letter == 'o' or 
									letter == 'u':
										vowels += 1
							print('Number of vowels: ' + str(vowels))
						</code></pre>
						<pre class="command-line language-bash" data-output=""><code>
							Enter a string of lower case letters: hi
							Number of vowels: 1

							Enter a string of lower case letters: tamago
							Number of vowels: 3

							Enter a string of lower case letters: iorana
							Number of vowels: 4

							Enter a string of lower case letter: liliuokalani
							Number of vowels: 7
						</code></pre>
					</details>
				<p><span class="exh">Exercise.</span> Consider the following:</p>
					<pre class="language-python"><code>
						iteration = 0
						count = 0
						while iteration < 5:
							for letter in 'hello, world':
								count += 1
							print("Iteration " + str(iteration) + "; count is: " + str(count))
							iteration += 1
					</code></pre>
					<ol>
						<li>What is the value of <span class="monoText">count</span> that is printed out at the <span class="monoText">print()</span> when <span class="monoText">iteration = 0</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>Examine the follwing whiteboard:</p>
							<figure><img src="images/whiteboard1.svg" alt="solution" loading="lazy"></figure>
							<p>At <span class="monoText">iteration = 0</span>, the value of <span class="monoText">count</span> printed is <span class="monoText">12</span>.</p>
						</details>
						<li>What is the value of <span class="monoText">count</span> that is printed out at the <span class="monoText">print()</span> when <span class="monoText">iteration = 1</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>At <span class="monoText">iteration = 1</span>, the value of <span class="monoText">count</span> printed is <span class="monoText">24</span>.</p>
						</details>
						<li>What is the value of <span class="monoText">count</span> that is printed out at the <span class="monoText">print()</span> when <span class="monoText">iteration = 2</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>At <span class="monoText">iteration = 2</span>, the value of <span class="monoText">count</span> printed is <span class="monoText">36</span>.</p>
						</details>
						<li>What is the value of <span class="monoText">count</span> that is printed out at the <span class="monoText">print()</span> when <span class="monoText">iteration = 3</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>At <span class="monoText">iteration = 3</span>, the value of <span class="monoText">count</span> printed is <span class="monoText">48</span>.</p>
						</details>
						<li>What is the value of <span class="monoText">count</span> that is printed out at the <span class="monoText">print()</span> when <span class="monoText">iteration = 4</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>At <span class="monoText">iteration = 4</span>, the value of <span class="monoText">count</span> printed is <span class="monoText">60</span>.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Consider the following:</p>	
					<pre class="language-python"><code>
						iteration = 0
						while iteration < 5:
							count = 0
							for letter in "hello, world":
								count += 1
							print("Iteration " + str(iteration) + "; count is: " + str(count))
							iteration += 1
					</code></pre>
					<ol>
						<li>At <span class="monoText">iteration = 0</span>, what is the value of <span class="monoText">count</span> printed out?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>Whiteboard:</p>
							<figure><img src="images/whiteBoard2.svg" alt="whiteboard" loading="lazy"></figure>
							<p><span class="monoText">count</span>'s value is <span class="monoText">12</span> when printed.</p>
						</details>
						<li>At <span class="monoText">iteration = 1</span>, what is the value of <span class="monoText">count</span> printed out?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">count</span>'s value is <span class="monoText">12</span> when printed.</p>
						</details>
						<li>At <span class="monoText">iteration = 2</span>, what is the value of <span class="monoText">count</span> printed out?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">count</span>'s value is <span class="monoText">12</span> when printed.</p>
						</details>
						<li>At <span class="monoText">iteration = 3</span>, what is the value of <span class="monoText">count</span> printed out?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">count</span>'s value is <span class="monoText">12</span> when printed.</p>
						</details>
						<li>At <span class="monoText">iteration = 4</span>, what is the value of <span class="monoText">count</span> printed out?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p><span class="monoText">count</span>'s value is <span class="monoText">12</span> when printed.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Consider the following:</p>	
					<pre class="language-python"><code>
						iteration = 0
						while iteration < 5:
							count = 0
							for letter in "hello, world":
								count += 1
								if iteration % 2 == 0:
									break
							print("Iteration " + str(iteration) + "; count is: " + str(count))
							iteration += 1
					</code></pre>
					<ol>
						<li>How many times is <span class="monoText">print()</span> executed?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>Whiteboard:</p>
							<figure><img src="images/whiteBoard3.svg" alt="whiteboard"></figure>
							<p><span class="monoText">print()</span> executes a total of 5 times.</p>
						</details>

						<li>What is the largest value of <span class="monoText">iteration</span> to be printed by <span class="monoText">print()</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The largest value of <span class="monoText">iteration</span> to be printed is <span class="monoText">4</span>.</p>
						</details>

						<li>What is the largest value of <span class="monoText">count</span> to be printed by <span class="monoText">print()</span></li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The largest value of <span class="monoText">count</span> to be printed is <span class="monoText">12</span>.</p>
						</details>

						<li>What is the smallest value of <span class="monoText">count</span> to be printed by <span class="monoText">print()</span>?</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>The smallest value of <span class="monoText">count</span> to be printed is 1.</p>
						</details>
					</ol>
				<p><span class="exh">Exercise.</span> Write this program. The user enters an integer. Then, using a loop, print to the console the following snail mountain whose height equals the user's input integer:</p>	
				<figure><img src="images/snail_tower.svg" alt="snail tower" class="forty-p" loading="lazy"></figure>
					<details class="answer">
						<summary>Solution</summary>
						<p>Here is one possible implementation:</p>
						<pre class="language-python"><code>
							height = int(input("Height: "))
							for i in range(1, height+1, 1):
									if i == 1:
										print(' ' * (height-1) + '@')
									else:
										print(' ' * (height-i) + '@' * i + '@' * (i-1))
						</code></pre>
					</details>
			</section>

			<section id="simple_algorithms_in_python" class="grid-item">
				<h3>Simple Algorithms in Python</h3>
				<p>In our previous square root program, we could only compute the cube root of an integer. What if we wanted to compute the ${nth\text{-root}}$ of any nonnegative number? Clearly, we cannot generate all possible guesses &mdash; there are infinitely many.</p>
				<p>What we can do, however, is generate an <span class="boldItalics">approximate solution</span>. We won't get an exact answer, but we will obtain a result that is close enough. The find this result, we use exhaustive enumeration. We generate a guess, check, if it's not close enough, we repeat over and over until we arrive at something close enough.</p>
				<p>We start with a guess, then we incremenent by a small value. For example, we might start with <span class="monoText">1</span>. If it's close enough, great. Otherwise, we'll increment by <span class="monoText">0.0001</span>; the guess is now <span class="monoText">1.0001</span>. </p>
				<p>However, we need to define what &#8220;close enough&#8221; means. For cube roots, we might use the following definition:</p>
				<figure class="math-display">
					<div>
						<p>${\lvert g^3 \rvert - r \leq \varepsilon}$</p>
						<ul class="def">
							<li class="where">${g \coloneqq \text{our guess}}$</li>
							<li>${r \coloneqq \text{the cube root}}$</li>
							<li>${\varepsilon \coloneqq \text{some very small number}}$</li>
						</ul>
					</div>
				</figure>
				<p>There are tradeoffs to be cognizant of when we implement the definition above. Given an increment ${i,}$ when ${\lim\limits_{i \to 0},}$ (as the increment gets very small), the program grows slower. When ${\lim\limits_{\varepsilon \to +\infty},}$ (the more accepting we are of larger differences) the less accurate our answer is. Bearing these costs in mind, we can implement the algorithm as such:</p>
				<pre class="language-python"><code>
					cube = int(input('Enter integer to cubic root: '))
					epsilon = 0.01
					guess = 0.0
					increment = 0.0001
					guess_count = 0
					while abs(guess**3 - cube) >= epsilon:
						guess += increment
						guess_count += 1 
					print('Number of guesses =', guess_count)
					if abs(guess**3 - cube) >= epsilon:
						print('Failed on cube root of', cube)
					else:
						print(guess, 'is close to the cube root of', cube)
				</code></pre>
				<pre class="command-line language-bash" data-output="2-4"><code>
					Enter integer to cubic root: 27
					Number of guesses = 29997
					2.999700000001906 is close to the cube root of 27
				</code></pre>
				<p>Carefully consider what this code is doing. It starts with a <span class="monoText">guess</span>, <span class="monoText">0.0</span>, then cubes it. Then it subtracts from the result the integer the user entered. If that result is greater than or equal to <span class="monoText">0.01</span> (<span class="monoText">epsilon</span>), it increments the <span class="monoText">guess</span> by <span class="monoText">0.0001</span>, counts the iteration, and repeats the test again. The code does this over and over again until ${\left(\texttt{guess}^3 - \texttt{cube}\right) \geq 0.001.}$</p>
				<p>Other things to note: It took almost 30,000 iterations before Python reached the closest guess. This is because we incremented by 0.0001 each time. Although this code is slow, it does allow us to compute the cubic root for non-perfect cubes:</p>
				<pre class="command-line language-bash" data-output="2-3"><code>
					Enter integer to cubic root: 31
					Number of guesses = 31411
					3.1411000000022042 is close to the cube root of 31
				</code></pre>
				<p>Suppose we made our <span class="monoText">increment = 0.001</span> instead of <span class="monoText">0.0001</span>:</p>
				<pre class="command-line language-bash" data-output="2-3"><code>
					Enter integer to cubic root: 29
					Number of guesses = 3072
					3.0719999999997727 is close to the cube root of 29
				</code></pre>
				<p>This guess is different, but this time it only took roughly 3,000 iterations. Let's change it again, <span class="monoText">guess = 0.01</span>:</p>
				<pre class="command-line language-bash" data-output="2"><code>
					Enter integer to cubic root: 29

				</code></pre>
				<p>Why is there no output? Our loop has gone infinite. Our code is only checking if our guess is close enough, and our guess has been incremented right past the cube root. Python is checking over and over again with no end in sight.</p>
				<p>To avoid this problem, we must ensure that our guess does not go out of bounds (i.e., it is not too big). This means we need to make add an additional test condition to terminate the <span class="monoText">while</span> loop:</p>
				<pre class="language-python"><code>
					cube = int(input('Enter integer to cubic root: '))
					epsilon = 0.01
					guess = 0.0
					increment = 0.0001
					guess_count = 0
					while abs(guess**3 - cube) >= epsilon and guess <= cube:
						guess += increment
						guess_count += 1 
					print('Number of guesses =', guess_count)
					if abs(guess**3 - cube) >= epsilon:
						print('Failed on cube root of', cube)
					else:
						print(guess, 'is close to the cube root of', cube)
				</code></pre>
				<p>The additional test condition checks to make sure that <span class="monoText">guess</span> is not greater than <span class="monoText">cube</span>. If it is, the loop terminates.</p>
				<pre class="command-line language-bash" data-output="2,3"><code>
					Enter integer to cubic root: 29
					Number of guesses = 2900
					Failed on cube root of 29
				</code></pre>
				<p>The output tells us that Python could not find a solution, but at least it isn't running an infinite loop. This is a crucial lesson in implementing algorithms: We must always consider the tradeoffs. Too large of a step, and we miss the answer. Too small of a step, and the program will be too slow.</p>
			</section>

			<section id="bisection_search" class="grid-item">
				<h4>Bisection Search</h4>
				<p>Our previous algorithm came with tradeoffs: Increase accuracy, and the program slows; Increase speed, and the program risks inaccuracy. A possibly better solution is to use a <span class="boldItalics">bisection search</span>.</p>
				<p>We know that given ${\texttt{guess} = \sqrt{x},}$ where ${x \in \Z,}$ <span class="monoText">guess</span> lies somewhere between 1 and ${x.}$ In the previous algorithm, we initialized <span class="monoText">guess</span> to <span class="monoText">1</span>. But if ${1 \leq \texttt{guess} \leq x,}$ why should we start with ${\texttt{guess} = 1?}$ Indeed, there is nothing stopping us from initializing ${\texttt{guess} = n,}$ where ${1 \leq n \leq x.}$ If we're lucky, <span class="monoText">guess</span> is close enough. If <span class="monoText">guess</span> is not close enough, we ask, Is the guess too big or too small?</p>
				<p>If ${\texttt{guess}^2 > x,}$ then we know it's too big. Let's call that guess ${\texttt{guess}_0}$ and the more accurate guess ${\texttt{guess}_1.}$ If ${\texttt{guess}_0}$ is too big, then it must be the case that ${1 \leq \texttt{guess}_1 \leq \texttt{guess}_0.}$ What that means is, we can toss out all of the possible guesses where ${\texttt{guess}_0 \leq \text{guess} \leq x.}$ By tossing all of those possible guesses out, we do not have to bother looking at those values and checking.</p>
				<p>The beauty of this method is we can do the same thing again for the new range. Pick something halfway between, call it ${\texttt{guess}_2.}$ If ${{\texttt{guess}_2}}$ is close enough, we're done. If ${{\texttt{guess}_2}^2 > x,}$ it's too big, so we cut out the upper half. If ${{\texttt{guess}_2}^2 < x,}$ then we know it's too small, so we toss out the lower half. We repeat this process over and over until we arrive at some ${{\texttt{guess}_n}^2}$ that is close enough. This algorithm is called a <span class="boldItalics">bisection search</span>.</p>
				<p>Implementing:</p>
				<pre class="language-python"><code>
					radicand = int(input("Enter the integer to square root: "))
					deviation = 0.01
					guess_count = 0
					minGuess = 1.0
					maxGuess = radicand
					square_root = (maxGuess + minGuess)/2.0

					while abs(square_root**2 - radicand) >= deviation:
						print(f'minGuess = {minGuess}; maxGuess = {maxGuess}; square_root = {square_root}')
						guess_count += 1
						if square_root**2 < radicand:
							minGuess = square_root
						else:
							maxGuess = square_root 
						square_root = (maxGuess + minGuess) / 2
					print(f'Number of guesses: {guess_count}')
					print(f'{square_root} is close to square root of {radicand}')
				</code></pre>
				<pre class="language-bash"><code>
					Enter the integer to square root: 25

					minGuess = 1.0; maxGuess = 25; square_root = 13.0
					minGuess = 1.0; maxGuess = 13.0; square_root = 7.0
					minGuess = 1.0; maxGuess = 7.0; square_root = 4.0
					minGuess = 4.0; maxGuess = 7.0; square_root = 5.5
					minGuess = 4.0; maxGuess = 5.5; square_root = 4.75
					minGuess = 4.75; maxGuess = 5.5; square_root = 5.125
					minGuess = 4.75; maxGuess = 5.125; square_root = 4.9375
					minGuess = 4.9375; maxGuess = 5.125; square_root = 5.03125
					minGuess = 4.9375; maxGuess = 5.03125; square_root = 4.984375
					minGuess = 4.984375; maxGuess = 5.03125; square_root = 5.0078125
					minGuess = 4.984375; maxGuess = 5.0078125; square_root = 4.99609375
					minGuess = 4.99609375; maxGuess = 5.0078125; square_root = 5.001953125
					Number of guesses: 12
					4.9990234375 is close to square root of 25
				</code></pre>
				<p>The program above computed the square root very very quickly. It computed ${\sqrt{25}}$ in 13 guesses. Compare that to using our previous method:</p>
				<pre class="language-python"><code>
					radicand = int(input('Enter integer to square root: '))
					deviation = 0.01
					square_root = 0.0
					increment = 0.0001
					guess_count = 0
					while abs(square_root**2 - radicand) >= deviation:
						square_root += increment
						guess_count += 1 
					print(f'Number of guesses = {guess_count}')
					print(f'{square_root} is close to the square root of {radicand}')
				</code></pre>
				<pre class="language-bash"><code>
					Enter integer to square root: 25

					Number of guesses = 49990
					4.999000000001688 is close to the square root of 25
				</code></pre>
				<p>The previous approach computed ${\sqrt{25}}$ in almost 50,000 guesses. Take that in for a moment. 12 guesses versus 50,000. A bisection search for this particular computation is over 4,000 times faster. Let's try it with a cube root. This time, we'll omit the <span class="monoText">print()</span> statement for the individual computations.</p>
				<pre class="language-python"><code>
					radicand = int(input("Enter the integer to cube root: "))
					deviation = 0.01
					guess_count = 0
					minGuess = 1.0
					maxGuess = radicand
					cube_root = (maxGuess + minGuess)/2.0

					while abs(cube_root**3 - radicand) >= deviation:
						guess_count += 1
						if cube_root**3 < radicand:
							minGuess = cube_root
						else:
							maxGuess = cube_root 
						cube_root = (maxGuess + minGuess) / 2
					print(f'Number of guesses: {guess_count}')
					print(f'{cube_root} is close to cube root of {radicand}')
				</code></pre>
				<pre class="language-bash"><code>
					Enter the integer to cube root: 27

					Number of guesses: 14
					3.00030517578125 is close to cube root of 27
				</code></pre>
				<p>The program computed ${\sqrt{27}}$ in 14 guesses. Compare that to our previous approach, which took a whopping 30,000 guesses:</p>
				<pre class="language-python"><code>
					radicand = int(input('Enter integer to cube root: '))
					deviation = 0.01
					cube_root = 0.0
					increment = 0.0001
					guess_count = 0
					while abs(cube_root**3 - radicand) >= deviation:
						cube_root += increment
						guess_count += 1 
					print(f'Number of guesses = {guess_count}')
					print(f'{cube_root} is close to the cube root of {radicand}')
				</code></pre>
				<pre class="language-bash"><code>
					Enter integer to cube root: 27

					Number of guesses = 29997
					2.999700000001906 is close to the cube root of 27
				</code></pre>
				<p>Bisection search is so much faster because we're reducing the number of steps it takes to reach the most accurate guess. This is because we're tossing out half of the possible guesses at each iteration. In other words, where ${n}$ is the number of possible values to check, we're cutting ${n}$ by half every time.</p>
				<figure class="math-display">
					<div>
						<p>${\texttt{guess}_1 = \dfrac{n}{2}}$</p>
						<p>${\texttt{guess}_2 = \dfrac{n}{4}}$</p>
						<p>${\texttt{guess}_3 = \dfrac{n}{8}}$</p>
						<p>$$\vdots$$</p>
						<p>${\texttt{guess}_i = \dfrac{n}{2^i}}$</p>
						<p>${i = \log_{2}n = \log n}$</p>
					</div>
				</figure>
				<p>This means it takes ${\log n}$ steps to reach the final <span class="monoText">guess</span>. Thus, this algorithm works in logarithmic time &mdash; a much faster time, compared to the previous algorithm, which took ${n}$ steps to reach the final guess.</p>
				<p>Importantly, this algorithm will work if, and only if, the relevant problem is solvable by checking <span class="italicsText">ordered</span> values. More specifically, it only works for <span class="boldItalics">monotonic functions</span> &mdash; functions where, as their inputs increase in value, the corresponding outputs also increase in value. In this case, ${\texttt{guess}^n}$, where ${n \in \N,}$ grows as ${\texttt{guess}}$ grows.</p>
			</section>

			<section id="bisection_search_exercise" class="grid-item">
				<details>
					<summary>Bisection Search Exercise</summary>
					<ol>
						<li>Write a program that guesses a user's inputted integer. The program should prompt the user to enter an integer between 0 (inclusive) and 100 (not inclusive). The computer makes a guess, and asks the user if the guess is too high or too low. If the guess is too high, prompt the user to enter the character <span class="monoText">'h'</span>. If the guess is too low, prompt the user to enter the character <span class="monoText">'l'</span>. If the guess is correct, prompt the user to enter the character <span class="monoText">'c'</span>, upon which the user is informed of the guess, along with how many guesses it took. Be sure to address the case where the user fails to input a number between 0 and 100, along with when the user fails to enter <span class="monoText">'c'</span>, <span class="monoText">'h'</span>, or <span class="monoText">'l'</span>. Use bisection search!</li>
						<details class="answer">
							<summary>Answer</summary>
							<p>Here is one possible implementation:</p>
							<pre class="language-python"><code>
								target_number = int(input("Enter an integer between 0 and 100: "))
								if target_number < 0 or target_number >= 100:
									target_number = int(input("Invalid input. Enter an integer between 0 and 100: "))
								
								min_guess = 1
								max_guess = 100
								guess_count = 0
								guess = (max_guess + min_guess) // 2
								
								while guess < 100:
										guess_count += 1 
										feedback = input(f"Is your number {guess}? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': ")
										while feedback != 'l' and feedback != 'h' and feedback != 'c':
											feedback = input(f"Invalid input. Guess was {guess}. Enter 'l', 'h', or 'c': ")
										if feedback == 'l':
											max_guess = guess
										elif feedback == 'h':
											min_guess = guess
										elif feedback == 'c':
											break
										guess = (max_guess + min_guess) // 2
										
								print(f'Correctly guessed {guess} in {guess_count} guesses.')
							</code></pre>
							<pre class="language-bash"><code>
								Enter an integer between 0 and 100: 120

								Invalid input. Enter an integer between 0 and 100: 12
								
								Is your number 50? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': x
								
								Invalid input. Guess was 50. Enter 'l', 'h', or 'c': n
								
								Invalid input. Guess was 50. Enter 'l', 'h', or 'c': l
								
								Is your number 25? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': l
								
								Is your number 13? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': l
								
								Is your number 7? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': h
								
								Is your number 10? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': h
								
								Is your number 11? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': h
								
								Is your number 12? If number is lower - enter 'l'; higher - enter 'h'; correct - enter 'c': c
								Correctly guessed 12 in 7 guesses.
							</code></pre>
						</details>
					</ol>
				</details>
			</section>

			<section id="floats_and_fractions" class="grid-item">
				<h4>Floats and Fractions</h4>
				<p>When we write programs that output certain numbers, we might notice that we're given some number like <span class="monoText">3.00001</span> when we expected the whole number <span class="monoText">3</span> or the floating point number (&#8220;float&#8221;) <span class="monoText">3.0</span>. To understand why this occurs, we must study how floating point numbers are represented by computers.</p>
				<p>Computers can only <span class="underlineText">approximate</span> real numbers. Real numbers, by definition, have an infinite number of fractional components, or decimal points. But, because computers have a finite amount of memory, it follows that they cannot store every decimal point. Thus, they must approximate. As such, the float we're getting back is an approximation. But how does the computer approximate?</p>
				<p>Recall how real numbers are represented in the decimal system:</p>
				<figure class="math-display">
					<div>
						<p>${302 = (3 \cdot 10^2) + (0 \cdot 10^1) + (2 \cdot 10^0)}$</p>
					</div>
				</figure>
				<p>As seen above, we &mdash; humans &mdash; represent numbers in base-10. Computers, however, represent numbers in <span class="italicsText">binary</span> &mdash; base-2:</p>
				<figure class="math-display">
					<div>
						<p>${19 = (1 \cdot 2^4) + (0 \cdot 2^3) + (0 \cdot 2^2) + (1 \cdot 2^1) + (1 \cdot 2^0)}$</p>
						<p>${\phantom{19} = 16 + 2 + 1}$</p>
						<p>${\phantom{19} = 10011}$</p>
					</div>
				</figure>
				<p>Because computers represent, and can only represent, numbers in binary, every decimal number must be converted into binary. How do we convert from decimal to binary? First, note that if we computed ${19 \bmod 2,}$ we get the last binary bit:</p>
				<figure class="math-display">
					<div>
						$$ 
						\begin{array}{r} 9 \\
							2{\overline{\smash{\big)}\,19}} \\
							-18 \\
							\hline
							1
							\end{array}
						$$
					</div>
					<div>${19 = (2 \cdot 9) + \texttt{1}}$</div>
				</figure>
				<p>If we then divide 19 by 2, then all the bits get shifted right:</p>
				<figure class="math-display">
					<div>
						<p>${\dfrac{19}{2} = (1 \cdot 2^3) + (0 \cdot 2^2) + (0 \cdot 2^1) + (1 \cdot 2^0)}$</p>
						<p>${\phantom{\dfrac{\frac{19}{2}}{2}} = 1001}$</p>
					</div>
				</figure>
				<p>If we keep doing successive divisions, the remainder becomes the next bit, then the next bit, then the next bit, and so on. This effectively allow us to quickly convert from decimal to binary. We can perform this conversion with Python code:</p>
				<pre class="language-python"><code>
					num = int(input('Enter an integer: ')) # get num
					if num < 0:
						isNeg = True # if num is negative, indicate with isNeg flag
						num = abs(num) # if num is negative, use absolute value
					else:
						isNeg = False # otherwise make isNeg flag false
					result = '' # accumulate results and store it in result
					if num == 0:
						result = '0'
					while num > 0: # keep doing this as long as num is bigger than 0
						result = str(num%2) + result # add remainder to the result
						num = num//2 # do the division to shift right
					if isNeg:
						result = '-' + result
					print(result)
				</code></pre>
				<pre class="command-line language-bash" data-output="2,3,5"><code>
					Enter an integer: 3
					11

					Enter an integer: 19
					10011
				</code></pre>
				<p>Ok, so we can convert integers into binary. How do we handle fractions? We can do <span class="italicsText">almost</span> the same procedure. Consider the fraction ${3/8:}$</p>
				<figure class="math-display">
					<div>
						<p>${\dfrac{3}{8} = 0.375 = (3 \cdot 10^{-1}) + (7 \cdot 10^{-2}) + (5 \cdot 10^{-3})}$</p>
					</div>
				</figure>
				<p>Observing the bases, we can see that if we multiply by a power of 2 large enough to convert into a whole number, we can then convert to binary, and divide by the same power of 2:</p>
				<figure class="table">
					<table class="proof_table">
						<tbody>
							<tr>
								<td>${0.375 \cdot (2^{3}) = 3}$</td>
								<td><p>The decimal representation</p></td>
							</tr>
							<tr>
								<td>${3 = (1 \cdot 2^{1}) + (1 \cdot 2^{0})}$</td>
								<td><p>Convert 3 to binary</p></td>
							</tr>
							<tr>
								<td>${\dfrac{3}{2^{3}} = 0.011}$</td>
								<td><p>Shift right</p></td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>We can implement this with Python code:</p>
				<pre class="language-python"><code>
					x = float(input('Enter a decimal number between 0 and 1: '))
					p = 0
					while ((2**p)*x)%1 != 0:
						print(f'Remainder {(2**p)*x - int((2**p)*x)}')
						p += 1
					num = int(x*(2**p))
					result = ''
					if num == 0:
						result = '0'
					while num > 0:
						result = f'{num%2}{result}'
						num = num//2
					for i in range(p - len(result)):
						result = f'0{result}'
					result = result[0:-p] + '.' + result[-p:]
					print(f'The binary representation of the decimal {x} is {result}')
				</code></pre>
				<pre class="command-line language-bash" data-output="2-5"><code>
					Enter a decimal number between 0 and 1: 0.375
					Remainder 0.375
					Remainder 0.75
					Remainder 0.5
					The binary representation of the decimal 0.375 is .011
				</code></pre>
				<p>This all shows why we get unexpected numbers at the end of floating point numbers. The computer can get close to a particular decimal point, but it will never get there. This leads to a core rule in computation:</p>
				<div class="rule">
					<p><span class="topic">Theorem</span>. Given ${x \in \R,}$ if there is no integer $p$ such that ${x \cdot 2^p \in \Z,}$ then the internal representation of ${x}$ is <span class="underlineText">always</span> an approximation.</p>
				</div>
				<p>This theorem has a huge implication in practice. If we want to test the equality of floating point numbers, say ${\texttt{x}}$ and ${\texttt{y,}}$ then we must test for their difference, rather than strict equality:</p>
				<figure class="math-display">
					<div>
						<p>Never test floats with: ${\texttt{x == y}}$.</p>
						<p>Always test with: ${\texttt{abs(x - y) < n} }$, where ${\texttt{n}}$ is some small number</p>
					</div>
				</figure>
				<p>Testing floats with ${\texttt{x == y}}$ can occassionally lead to correct comparisons, but it is never assured. This is why we never compare floats in this way.</p>
			</section>

			<section id="newton_raphson_method" class="grid-item">
				<h4>The Newton-Raphson Method</h4>
				<p>The <span class="boldItalics">Newton-Raphson Method</span> is an algorithm for finding the roots of polynomials in one variable:</p>
				<figure class="math-display">
					<div>
						<p>${p(x) = a_{n}x^n + a_{n-1}x^{n-1} + \ldots + a_{1}x + a_{0}}$</p>
					</div>
				</figure>
				<p>The algorithm allows us to compute an ${r}$ such that ${p(r) = 0.}$ We can state the method as follows:</p>
				<div class="rule">
					<p><span class="topic">Newton-Raphson Method</span>. Let ${p}$ be some polynomial in one variable. Then the approximation $n$ is a better approximation, provided by:</p>
					<figure class="math-display">
						<div>
							<p>${n = g - \dfrac{p(g)}{p^{\prime}(g)}}$</p>
							<ul class="def">
								<li class="where">${g}$ is an approximation of the root, and</li>
								<li>${p^{\prime}}$ is a derivative of ${p.}$</li>
							</ul>
						</div>
					</figure>
				</div>
				<p>What the Newton-Raphson method means is, if we wanted to compute, say, ${\sqrt{24},}$ we can do so by finding the root of:</p>
				<figure class="math-display">
					<div>
						<p>${p(x) = x^{2} - 24}$</p>
					</div>
				</figure>
				<p>Let's apply the Newton-Raphson method for the simplest case: ${r(x) = cx^2 + k,}$ where ${c}$ and ${k}$ are some constants. The first derivative then is ${r^{\prime} = 2ck.}$ Thus, given a polynomial ${p(x) = x^2 + k,}$ ${p^{\prime} = 2x.}$ Following the Newton-Raphson method, given a guess ${g}$ for the root of ${p(x),}$ a better guess ${n}$ is:</p>
				<figure class="math-display">
					<div>
						<p>${n = g - \left( \dfrac{g^2 - k}{2g} \right)}$</p>
					</div>
				</figure>
				<p>We can implement this algorithm with a loop. Suppose we want to compute ${\sqrt{24}:}$</p>
				<pre class="language-python"><code>
					epsilon = 0.01
					radicand = 24.0
					guess = radicand/2.0
					numGuesses = 0

					while abs(guess*guess - radicand) >= epsilon:
						numGuesses += 1
						guess = guess - (((guess**2) - radicand) / (2*guess))
					print(f'Number of guesses: {numGuesses}')
					print(f'Square root of {radicand} is about {guess}')
				</code></pre>
				<pre class="language-bash"><code>
					Number of guesses: 4
					Square root of 24.0 is about 4.8989887432139305
				</code></pre>
			</section>

			<!-- Functions -->
			<section id="decomp_and_abstraction" class="grid-item">
				<h3>Decomposition and Abstraction</h3>
				<p>So far, the programs we've written have been contained in a single file, called a <span class="boldItalics">script</span>. Each file contains a piece of code, and each code is a sequence of instructions. This is fine for small problems.</p>
				<p>The problem, however, is that designing and programs in this way can easily lead to messy, disorganized, and confusing work with large problems. By large problems, we mean problems that require thousands of lines of code. Once our programs start spanning thousands of lines, it becomes extraordinarly difficult to keep track of every detail. Where is this code's output going? Where is this code's input coming from? What does this piece of code do? These are all difficult questions when our programs just run in a linear fashion in a single file.</p>
				<p>Because of this hurdle, we need a better way to <span class="italicsText">structure</span> our code. Good programming is concise and efficient &mdash; more code is not necessarily a good thing. Great programming, however, is <span class="italicsText">functional</span>. Whether a program is great or horrid comes down to functionality. One way to ensure our code is functional is to use <span class="boldItalics">functions</span>.</p>
				<p>Functions provide us a way to "box up" pieces of computation. More generally, functions provide a means of achieving two critical concepts in computational thinking:</p>
				<ol>
					<li>decomposition (also called modularity); and</li>
					<li>abstraction.</li>
				</ol>
				<p>We can think of abstraction by way of analogy. Consider the modern printer. Most individuals do not know how it actually works. How does this box like entity take inputs from my phone or computer and output paper with pictures or various glyphs? But, the fact that we do not know how it works does not prevent us from using it. Most of us can quickly set up a new printer and print away. This is the essence of abstraction &mdash; we do not need to know how a particular piece of code works to use it.</p>
				<p>Abstraction is the approach of suppressing detail &mdash; we want to perform a particular computation without having to see or write long pieces of code. Much like how using a printer does not require us to understand how it works, we want to have the ability to use pieces of code freely, without worrying about the low level details.</p>
				<p>To abstract these low level details, we must <span class="italicsText">decompose</span> problems &mdash; we break the problem down into different, self-contained pieces, then address each of those pieces individually.</p>
				<p><span class="topic">How do we decompose?</span> To decompose a problem, we must first isolate the problem into smaller problems. These smaller problems are targeted by code unique to those problems. We call such code <span class="boldItalics">modules</span>. These modules are effectively divisions of code, and they must meet the following criteria:</p>
				<ul>
					<li>the module is self-contained;</li>
					<li>used to break up code;</li>
					<li>hides tedious details;</li>
					<li>the module's details are in fact hidden;</li>
					<li>does not require us to see the details;</li>
					<li>intended to be <span class="underlineText">reusable</span>;</li>
					<li>keeps code organized;</li>
					<li>keeps code coherent</li>
				</ul>
				<p>For the next few sections, we will decompose with <span class="italicsText">functions</span>. In later sections, we will decompose with <span class="italicsText">classes</span>.</p>
			</section>

			<section id="python_functions" class="grid-item">
				<h4>Python Functions</h4>
				<p>Functions are reusable chunks of code. Importantly, they do not run unless we explicitly tell Python to run them. When we do so, we <span class="boldItalics">call</span> or <span class="boldItalics">invoke</span> the function. Functions have the following characteristics:</p>
				<ul>
					<li>a <span class="italicsText">name</span>;</li>
					<li><span class="italicsText">parameters</span>;</li>
					<li>a <span class="italicsText">docstring</span>; and</li>
					<li>a <span class="italicsText">body.</span></li>
				</ul>
				<p><span class="topic">Name</span>. It goes without saying that functions must have names. How else would we refer to them? Like variable names, function names should be descriptive and concise. By convention, function names should be in lowercase, with words separated by underscores. When we encounter classes, the convention is camelCase.</p>
				<p><span class="topic">Parameters</span>. Because functions are pieces of code, they usually take inputs. <span class="italicsText">Parameters</span> are what specify what those inputs are, and the inputs actually passed into the function are called <span class="italicsText">arguments</span>. Note, a function does not always <span class="italicsText">need</span> to take arguments. They can have 0 or more parameters.</p>
				<p><span class="topic">docstring</span>. Every function must have a <span class="italicsText">docstring</span> &mdash; documentation that informs the reader what the function does.</p>
				<p><span class="topic">Body</span>. Every function has a <span class="italicsText">body</span> &mdash; the actual chunk of code we want to execute when we use the function.</p>
				<p>With these definitions in mind, let's see an example:</p>
				<pre class="language-python"><code>
					# here we define a function
					def is_even(num):
						'''

						Input: num, a positive integer
						Output: Returns True if num is even, otherwise False

						'''
						print("hi")
						return num%2 == 0
					
					# here we call the function
					is_even(3)
				</code></pre>
				<p>There are several pieces in the example above:</p>
				<ul>
					<li><span class="boldText monoText">def</span> This is a keyword in Python. It tells Python that we are about to define a function. Following <span class="monoText">def</span>, we have the function's <span class="italicsText">name</span> &mdash; <span class="monoText">is_even</span>.</li>
					<li><span class="topic"><span class="italicsText">name</span>.<span class="monoText">()</span></span> Following the function's name, there are parentheses. These parentheses are where we indicate the function's <span class="italicsText">parameters</span>. We give those parameters a name. In this case, the name <span class="monoText">num</span>.</li>
					<li><span class="boldText monoText">'''</span> Immediately below this definition, we have a comment, in triple quotes (we can also use triple double quotes). This is a <span class="boldItalics">docstring</span>. This specifies what the function does. Traditionally, a docstring is written with two states: (1) what are the function's inputs, and (2) what are the function's outputs.</li>
					<li><span class="topic">Body</span>. Immediately below the docstring is the <span class="boldItalics">body</span>. This the chunk of code we want to execute when the function is called. Inside the body, we have the keyword <span class="monoText boldText">return</span>. This keyword indicates the output of the function; it tells Python, "Output this value."</li>
					<li><span class="topic">Invokation</span>. The very last line &mdash; <span class="monoText">is_even(3)</span> &mdash; is where we call, or invoke, the function.</li>
				</ul>
				<p>As an aside, if we want an arbitrary number of parameters, we can write <span class="monoText">*vals</span>. For example:</p>
				<pre class="language-python"><code>
					def foo(*vals):
						return 1
				</code></pre>

				<!-- Anonymous Functions -->
					<p><span class="topic">Anonymous Functions.</span> The functions above are an example of <span class="term">named functions</span>. We can also have <span class="term">anonymous functions</span> &mdash; functions that do not have names. For those familiar with lambda calculus, this is a particularly useful feature when we want to think about functions in lambda terms:</p>
					<pre class="language-python"><code>
						lambda a, x, b: a * x + b
					</code></pre>
					<p>The function above is the same as the following <span class="monoText">def</span>, the difference being a name is given:</p>
					<pre class="language-python"><code>
						def saxb (a, x, b):
							return a * x + b
					</code></pre>

				<!-- Pure v. Impure Functions -->
					<p><span class="topic">Pure v. Impure Functions.</span> Functions fall into two categories: (1) Pure and (2) Impure. <span class="term">Pure functions</span> are functions whose output depends only its input. In other words, a pure function is one that takes one or more inputs, and returns one, and only one, output. For example, this is a pure function:</p>
					<pre class="language-python"><code>
						def increment(a):
							return a + 1
					</code></pre>
					<p>In contrast, <span class="term">impure functions</span> are functions with <span class="italicsText">side-effects</span> &mdash; additional outputs unrelated to the actual inputs. For example:</p>
					<pre class="language-python"><code>
						print(-5)
					</code></pre>
					<p>The built-in function <span class="monoText">print()</span> is a special function in Python. It outputs the special value <span class="monoText">None</span>, <span class="underlineText">and</span> it displays to the console the value passed in as an argument. By allowing impure functions, Python is not a member of the <span class="italicsText">pure functional language</span> family (e.g., Haskell, Curry, Purescript, Mercury, and Miranda).</p>
					<p>Side effects are most often used in the context of changing the value of some variable. For example, consider the random number generator from the <span class="monoText">random</span> module:</p>
					<pre class="language-python"><code>
						from random import randint
						randint(0, 100) # random number from 0 to 100
						randint(0, 100) # a different random number from 0 to 100
					</code></pre>
					<p>Because there are different outputs from the function invocation above, we can determine that there is some variable out there being changed every time we call <span class="monoText">randint</span>. As a matter of practice, the use of side effects should always be treated with great suspicion. This is because they have the potential for unpredictability.</p>

					<!-- Function Evaluation Model -->
					<p><span class="topic">Function Evaluation Model.</span> How are function calls evaluated? First, suppose we had the following function call:</p>
					<figure class="math-display">
						<ul class="syntax"><li>funcName(${o_1}$, ${o_2}$)</li></ul>
					</figure>
					<p>In the call above, ${o_1}$ and ${o_2}$ are arguments passed into the argument, the <span class="italicsText">operands</span>, and <span class="monoText">funcName</span> is the <span class="italicsText">operator</span>. These are subexpressions to the larger expression, <span class="monoText">funcName(${o_1,}$ ${o_2}$)</span>. Each of <span class="monoText">funcName</span>, ${o_1,}$ and ${o_2}$ are expressions. So, to evaluate the function call, Python evaluates each subexpression.</p>
					<p>First, it evaluates <span class="monoText">funcName</span>, and returns some value ${f}$ (a function). Next, it evaluates ${o_1,}$ and returns some value ${v_1.}$ Then if evaluates ${o_2,}$ and returns some value ${v_2.}$ With each subexpression evaluated, Python calls the function ${f,}$ the value evaluated from <span class="monoText">funcName</span>, with the arguments ${v_1}$ and ${v_2.}$ Here is an explicit example. In Python, <span class="monoText">0x</span> represents a number in base-16, and <span class="monoText">0o10</span> represents a number in base-8.</p>
					<pre class="language-pseudo"><code style="font-size: 0.65rem">
						mul(add (2,mul(0x10,0o10)), add(0x3,5))
						func mul(x,y) (add (2, mul(0x10,0o10)), add(0x3,5))
						func mul(x,y) (func add(x,y) (2, mul(0x10,0o10)), add(0x3,5))
						func mul(x,y) (func add(x,y) (2, func mul(x,y) (0x10,0o10)), add(0x3,5))
						func mul(x,y) (func add(x,y) (2, func mul(x,y) (16,0o10)), add(0x3,5))
						func mul(x,y) (func add(x,y) (2, func mul(x,y)(16,8)), add(0x3,5))
						func mul(x,y) (func add(x,y) (2, 128), add(0x3,5))
						func mul(x,y) (func add(x,y) (2, 128), func add(x,y)(0x3,5))
						func mul(x,y) (func add(x,y) (2, 128), func add(x,y)(3,5))
						func mul(x,y) (func add(x,y) (2, 128), func add(x,y)(3,5))
						func mul(x,y) (func add(x,y) (2, 128), 8)
						func mul(x,y) (130, 8)
						1040
					</code></pre>
					<p>Now, what happens when there are side effects? Suppose we called <span class="monoText">print(print(1), print(2)):</span></p>
					<pre class="language-pseudo"><code>
						print(print(1), print(2))
						func print(*vals) (print(1), print(2))
						func print(*vals) (print(*vals) (1), print(2))
						func print(*vals) (None, print(2)) <span class="italicsText">and print '1'</span>
						func print(*vals) (None, print(*vals) (2)) 
						func print(*vals) (None, None) <span class="italicsText">and print '2'</span>
						None <span class="italicsText">and print 'None None'</span>
					</code></pre>
					<p>Literals are simple to evaluate. The value 2 evaluates to 2 (a helpful way to understand this point is to think of the distinction between the numeral 2 and the number 2; the Hindu-Arabic numeral 2 is just one way to represent the number 2&mdash;the Chinese numeral is ニ).</p>
					<p>But what about names? How are these evaluated? There are two ways, (1) Through substitution and (2) through the environment. In Python, there are several ways to define names: <span class="term">assignment</span>, <span class="term">function definitions</span>, and <span class="term">parameter passing</span>.</p>
					<p><span class="topic">Assignment.</span> When we write <span class="monoText">x = 2</span>, we <span class="italicsText">assign</span> the literal 2 to the variable <span class="monoText">x.</span> By assigning a literal to a variable, subsequent usage of the variable employs the assigned value. For example:</p>
					<pre class="language-python"><code>
						x = 3
						y = x * 2
						z = y ** x
					</code></pre>
					<p>These expressions are evaluated as such:</p>
					<figure class="math-display">
						<ul class="syntax">
							<li>x = 3</li>
							<li>y = x * 2 ${\implies}$ y = 3 * 2 ${\implies }$ y = 6</li>
							<li>z = y ** x ${\implies}$ z = 6 ** x ${\implies}$ z = 6 ** 3 ${\implies}$ z = 216</li>
						</ul>
					</figure>
					<p><span class="topic">Function Definitions.</span> To evaluate <span class="italicsText">function names</span>, we use the function definition approach. Suppose a function <span class="monoText">f</span> is defined as such:</p>
					<pre class="language-python"><code>
						def f(x,y):
							return (x * y) ** x
					</code></pre>
					<p>Now suppose we called <span class="monoText">f(3,2)</span>:</p>
					<figure class="math-display">
						<pre class="language-pseudo"><code>
							f(3,2)
							func f(x,y): return (x * y) ** x
							func f(x,y): return (x * y) ** x (3,2)
							return (3 * 2) ** 3
							return 6 ** 3
							return 216
							216
						</code></pre>
					</figure>
					<p>We can think of the parameter substitution as if it were <span class="italicsText">simultaneous assignment</span>. We assigned to <span class="monoText">x</span> the literal <span class="monoText">3</span>, and to <span class="monoText">y</span> the literal <span class="monoText">2.</span> Now consider the following definition:</p>
					<pre class="language-python"><code>
						def incr(n):
							def f(x):
								return n + x
							return f

						incr(5)(6)
					</code></pre>
					<p>How does <span class="monoText">incr(5)(6)</span> evaluate? The <span class="monoText">incr</span> functions returns a function, <span class="monoText">f</span>, rather than a number. We then call this function on <span class="monoText">6</span>. This is an example of a <span class="term">nested function</span>.</p>
					<p>To evaluate a nested function, we first evaluate the outermost function. In thise case, <span class="monoText">incr</span>:</p>
					<figure class="math-display">
						<pre class="language-pseudo"><code>
							incr(5)(6)
							(func incr(n) : ( (def f(x) : return n + x) return f)) (5)(6)
							(func f(x) : return 5 + x) (6)
							return 5 + 6
							return 11
							11
						</code></pre>
					</figure>
					<p>What if instead we had the following:</p>
					<pre class="language-python"><code>
						def f(x):
							def g(x):
								return x
							return g
						
						f(5)(6)
					</code></pre>
					<p>To evaluate <span class="monoText">f(5)(6)</span>, the arguments are used respectively.</p>
					<figure class="math-display">
						<pre class="language-pseudo"><code>
							f(5)(6)
							(func f(x) : ( (def g(x) : return x) return g) (5)(6)
							(func g(x) : return x) (6)
							return 6
							6
						</code></pre>
					</figure>
					<p>Why does this occur? Because the argument assigned to the <span class="monoText">x</span> in <span class="monoText">def f(x)</span> substitutes only thoses <span class="monoText">x</span>s inside the body of <span class="monoText">f</span>. It does not substitute the <span class="monoText">x</span> inside the body of <span class="monoText">def g(x)</span>, because the <span class="monoText">x</span> inside the <span class="monoText">def g(x)</span> is bound in the head of <span class="monoText">g(x)</span>. Because the <span class="monoText">x</span> inside <span class="monoText">def g(x)</span> is bound to the head of <span class="monoText">g</span>, the argument <span class="monoText">5</span> does not substitute any <span class="monoText">x</span> inside <span class="monoText">g</span>.</p>

					<p><span class="topic">Environment.</span> The problem with substitution, however, is that it does not explain every situation. For example, consider the following:</p>
					<pre class="language-python"><code>
						x = 4
						x = 9
						print(x)
					</code></pre>
					<pre class="language-bash"><code>
						9
					</code></pre>
					<p>However, if we instead wrote:</p>
					<pre class="language-python"><code>
						x = 4
						print(x)
						x = 9
					</code></pre>
					<pre class="language-bash"><code>
						4
					</code></pre>
					<p>Substitution doesn't clearly address this situation. Is it 4 or is it 9? It depends on the <span class="term">environment</span>. In Python, an <span class="italicsText">environment</span> is a mapping from names to values. We say that <span class="italicsText">name</span> is <span class="italicsText">bound to</span> a <span class="italicsText">value</span> in its environment. The simplest environment is the <span class="term">global environment frame</span>. For example, consider the following code:</p>
					<pre class="language-python"><code>
						from math import pi

						radius = 10

						def circumference(r):
							return 2*pi*abs(r)

						print(circumference(radius))
					</code></pre>
					<pre class="language-bash"><code>
						62.83185307179586
					</code></pre>
					<p>The name <span class="monoText">radius</span> is bound to the value 10 in the <span class="italicsText">global environment frame</span>. The same goes for the function name <span class="italicsText">circumference</span>. The function <span class="monoText">circumference</span> itself has an environment, the <span class="monoText">func circumference(r)</span> environment. There, we have several values. The name <span class="monoText">pi</span> is bound to <span class="monoText">3.1415926</span> in the <span class="monoText">import</span> frame (which comes from some frame in the <span class="monoText">math</span> module). The name <span class="monoText">abs</span> is predefined.</p>
					<p>The main point: Every expression in Python is evaluated in an environment frame, which supplies the meanings of any names inside the expression. If the expression contains subexpressions, the interpreter first evaluates the subexpressions using the same environment as the expression that contains them. Once the subexpressions are evaluated, calls to user-defined functions must evaluate the expressions and statements from the definitions of those functions. To reinforce these ideas, compare the following:</p>
					<div class="compare">
						<div>
							<pre class="language-python"><code>
								x = 10
								def f(x):
									return x + 1
								print( f(1) )
							</code></pre>
							<pre class="language-bash"><code>
								2
							</code></pre>
						</div>

						<div>
							<pre class="language-python"><code>
								x = 10
								def f(y):
									return x + y
								print( f(1) )
							</code></pre>
							<pre class="language-bash"><code>
								11
							</code></pre>
						</div>

						<div>
							<pre class="language-python"><code>
								x = 10
								def f(y):
									x = 3
									return x + y
								print( f(1) )
							</code></pre>
							<pre class="language-bash"><code>
								4
							</code></pre>
						</div>
					</div>
					<p>All environments in Python fall into one of two categories: (1) the <span class="term">global environment frame</span> (of which there is only one member, the global environment) and (2) a <span class="term">local environment frame</span> chained to a <span class="term">parent environment frame</span>. All environment frames lead to the global frame.</p>
					<p>For example, in the left-most example above, there are two <span class="monoText">x</span>s. There is an <span class="monoText">x</span> bound to the global environment frame, <span class="monoText">x = 10</span>, and an <span class="monoText">x</span> bound to a value in the local environment frame, <span class="monoText">f</span>. When we pass the <span class="monoText">1</span> as an argument, that value is bound to the <span class="monoText">x</span> in the local environment frame, and is used in evaluating <span class="monoText">x + 1</span>. On the other hand, in the middle example, the <span class="monoText">x</span> is bound to the value <span class="monoText">10</span> in the global environment frame, so <span class="monoText">10</span> is used in evaluating <span class="monoText">x + y</span>. These two ideas are reinforced in the rightmost example. The value of a name in an environment is the vale it is bound to in the first frame &mdash; in this case <span class="monoText">f</span> &mdash; and if there is none, then the value bound in the parent frame &mdash; in this case, the global environment frame. Now, the <span class="monoText">f</span> frame can itself containing rebindings:</p>
					<pre class="language-python"><code>
						x = 10
						def f(y):
							y = 2
							x = 3
							return x + y
						print( f(1) )
					</code></pre>
					<pre class="language-bash"><code>
						5
					</code></pre>
					<p>In this case, <span class="monoText">y</span> was previously bound to <span class="monoText">1</span> in the <span class="monoText">f</span> frame, but once we get into the body, <span class="monoText">y</span> is then bound to <span class="monoText">2</span>. All of this occurs in the <span class="monoText">f</span> frame. This raises yet another point: a function frame, here the frame <span class="monoText">f</span>, is not created until we actually <span class="italicsText">call</span> the function. In the example above, the function definition is an object that exists in the global frame. This speaks to a broader notion: There is a distinction between a function's definition and the function's invocation.</p>
					<p>The concept of environment frames explains why we saw the earlier output. When we write <span class="monoText">x = 4</span> then subsequently write <span class="monoText">x = 8</span>, we have created a new binding for the name <span class="monoText">x</span> in the current evaluation frame.</p>
					<div class="compare">
						<div>
							<p><span class="exh">Exercise.</span> What does the code below output to the console:</p>
							<pre class="language-python"><code>
								def f(x):
									return x
								print(f(f)(f(1)))
							</code></pre>
							<details class="answer">
								<summary>Solution</summary>
								<p>We can envision the evaluation as the following:</p>
								<pre class="language-pseudo"><code>
									print( f(f)(f(1)) )
									func print(*vals) ( f(f)(f(1)) )
									( f(f)(f(1)) )
									( func f(x) (f)(f(1)) )
									( func f( return x ) (f)(f(1)) )
									( func f( return f ) (f)(f(1)) )
									( func f(x) (f(1)) )
									( func f( return x ) (f(1)) )
									( func f( return f ) (f(1)) )
									( func f(x) (f(1)) )
									( func f( return x ) (f(1)) )
									( func f( return f(1) ) (f(1)) )
									( func f(x) (1) )
									( func f( return x ) (1) )
									( return 1 )
									1
								</code></pre>
							</details>

							<p><span class="exh">Exercise.</span> How does the code below evaluate:</p>
							<pre class="language-python"><code>
								def incr(n):
									def f(x):
										return n + x
									return f
	
								incr(5)(6)
							</code></pre>
							<details class="answer">
								<summary>Solution</summary>
								<pre class="language-pseudo"><code>
									incr(6)(5)
									func incr(n) (6)(5)
									func incr(n = 6; return f) (5)
									n = 6; func f(x) (5)
									n = 6; func f(return n + x) (5)
									n = 6; x = 5; return n + x 
									return 6 + 5 
									11
								</code></pre>
							</details>
						</div>

						<div>
							<p><span class="exh">Exercise.</span> How does the code below evaluate:</p>
							<pre class="language-python"><code>
								def incr(n):
									def f(x):
										return n + x
									return f
								g = incr(5)
								print( g(6) )
							</code></pre>
							<details class="answer">
								<summary>Solution</summary>
								<pre class="language-pseudo"><code>
									g(6)
									func incr(n) (5) (6)
									incr(5)(6)
									n = 5; return f (6) 
									n = 5; func f(x) (6)
									n = 5; x = 6; return n + x
									return 5 + 6
									return 11
									11
								</code></pre>
							</details>
						</div>
					</div>



			</section>

			<section id="control" class="grid-item">
				<h4>Control</h4>
				<p>Expressions can be evaluated in the order they're written, and that is what we've seen for most of the expressions we've seen thus far. However, we often want a way to evaluate expressions other than through the order they're written. To do so, we need <span class="term">control</span>. Such control is established with a <span class="term">control expression</span>.</p>

				<p>A control expression evaluates some or all of its operands in an order determined by the kind of expression or the values of the operands. A control expression should be distinguished from a <span class="term">control statement</span>. A <span class="italicsText">statement</span> is a construct that produces no value, but is used exclusively for its side effects. Thus, a <span class="italicsText">control statement</span> is a statement that evaluates some or all of its operands, but has no value. Expressions and statements are two distinct concepts &mdash; an expression is a construct with a value, and it is <span class="italicsText">evaluated</span>. A statement is a construct with no value, and it is <span class="italicsText">executed</span>. Both expressions and statements are <span class="italicsText">elaborated</span> (a term that harkens back to <span class="monoText">ALGOL</span>).</p>

				<p><span class="topic">Conditional Expressions.</span> The most common kind of control expression is a <span class="term">conditional expression</span>. Conditional expressions provide one means of control, namely <span class="italicsText">conditional evaluation</span>. The general form:</p>
				<figure class="math-display">
					<div>
						<ul class="syntax"><li>${v_t}$ if ${c}$ else ${v_f}$</li></ul>
					</div>
				</figure>
				<p>In the syntax above, ${v_t}$ and ${v_f}$ are values, and ${c}$ is an expression that returns a Boolean value (<span class="monoText">True</span> or <span class="monoText">False</span>). If ${c}$ evaluates to <span class="monoText">True</span>, then the entire expression evaluates to ${v_t.}$ If ${c}$ evaluates to false, then the entire expression evaluates to ${v_f.}$ So, for example:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						x = 2

						1/x if x != 0 else 1
						1/x if 2 != 0 else 1
						1/x if True else 1
						1/x
						1/2
						0.5
					</code></pre>
				</figure>
				<p>Note that ${c}$ is any expression that returns a Boolean value. In Python, if an expression that returns a Boolean value, it may or may not be a Boolean expression. For example, the following values are treated as inherently <span class="monoText">False</span>: <span class="monoText">False</span>, <span class="monoText">None</span>, <span class="monoText">0</span>, and empty strings, sets, lists, tuples, and dictionaries. All other values are <span class="monoText">True</span> by default.</p>

				<p><span class="topic">and-expressions.</span> Like conditional expressions, <span class="monoText">and</span> expressions provide yet another means of control. The general syntax:</p>
				<figure class="math-display">
					<ul class="syntax"><li>${v_1}$ and ${v_2}$</li></ul>
				</figure>
				<p>To evaluate the expression above, evaluate ${v_1}$ first. If ${v_1}$ evaluates to <span class="monoText">False</span>, then the value of ${v_1}$ becomes the value of the entire expression. Otherwise, the value of the expression is ${v_2.}$ For example:</p>

				<figure class="math-display">
					<ul class="syntax">
						<li>5 and "hello" ${\implies}$ "hello"</li>
						<li>[] and 1/0 ${\implies}$ []</li>
					</ul>
				</figure>

				<p>The and-expression is an example of a <span class="term">short-circuit evaluation</span>. We do not evaluate one of the operands depending on the value of the other.</p>

				<p><span class="topic">or-expressions.</span> Alongside <span class="monoText">and</span>, we have <span class="term">or-expressions</span>:</p>

				<figure class="math-display">
					<ul class="syntax"><li>${v_1}$ or ${v_2}$</li></ul>
				</figure>

				<p>The evaluation: First evalue ${v_1.}$ If ${v_1}$ evaluates to <span class="monoText">True</span>, then the value of the or-expression is ${v_1.}$ Otherwise, the value of the expression is ${v_2.}$ Like the and-expression, the or-expression is also a short-circuit evaluation.</p>

				<figure class="math-display">
					<ul class="syntax">
						<li>5 or "hello" ${\implies}$ 5</li>
						<li>[] or "hello" ${\implies}$ "hello"</li>
						<li>[1,2] or 1/0 ${\implies}$ [1,2]</li>
						<li>[] or 1/0 ${\implies}$ ERROR</li>
					</ul>
				</figure>

				<p><span class="topic">Conditional Statement.</span> Using conditional expressions, we can construct <span class="term">conditional statements</span> with the following syntax:</p>
				<figure class="math-display">
					<ul class="syntax">
						<li>if ${c_1}$:</li>
						<ul>
							<li>${s_1}$</li>
							<li>${\vdots}$</li>
							<li>${s_n}$</li>
						</ul>
						<li>elif ${c_2}$:</li>
						<ul>
							<li>${s_1}$</li>
							<li>${\vdots}$</li>
							<li>${s_n}$</li>
						</ul>
						<li>else:</li>
						<ul>
							<li>${s_1}$</li>
							<li>${\vdots}$</li>
							<li>${s_n}$</li>
						</ul>
					</ul>
				</figure>
				<p>In the syntax above, ${c_n}$ are conditional expressions, and ${s_n}$ are statements. The overall conditional statement is executed as such: (1) First, evaluate ${c_1.}$ If ${c_1}$ evaluates to <span class="monoText">True</span>, then execute the statements ${s_1 \ldots s_n.}$ If ${c_1}$ evaluates to <span class="monoText">False</span>, move to ${c_2,}$ and continue.</p>
				<p>Some examples. Notice the different ways of writing the same function.</p>
				<div class="compare">
					<div>
						<pre class="language-python"><code>
							def signum(x):
								if x > 0:
									return 1
								elif x == 0:
									return 0
								else:
									return -1
		
							def max(x,y):
								if x > y:
									return x	
								else:
									return y
		
							def min(x,y):
								if x < y:
									return x
								return y
						</code></pre>
					</div>
					<div>
						<pre class="language-python"><code>
							def signum(x):
								return 1 if x > 0 else 0 if x == 0 else -1

							def max(x,y):
								return x if x > y else y

							def min(x,y):
								return x if x < y else y
						</code></pre>
					</div>
				</div>

			</section>

			<section id="suites_and_sequences">
				<p><span class="topic">Suites &amp; Sequences.</span> Notice how in the examples above, we can group conditional statements together into a single sequence by indenting:</p>
				<pre class="language-python"><code>
					if x < 0:
						return -x:
					elif x = 0:
						return 0
					else x
				</code></pre>
				<p>This above construct is called a <span class="term">suite</span>. Although the entire construct contains several conditional statements, it is in fact a single statement. When we command Python to execute the suite, Python executes each of its statements <span class="italicsText">in sequence</span>. Notice that every statement in the suite has the same indentation, and it ends at the next statement that is indented to a previous level.</p>
				<pre class="language-python"><code>
					x = 0
					if x > 1:
						print(">1")
						if x < 6:
							print ("&lt;6")
						print("x=", x) # prints nothing
				</code></pre>
			</section>

			<section id="control_loops" class="grid-item">
				<p><span class="topic">Control: Loops.</span> Another way to achieve control is with looping constructs. For example, suppose we want to compute the sum of ${1^2 + 2^2 + 3^2 \ldots + 100^2.}$ There is an elegant mathematical formula for performing this computation, but for now, let's think about it in terms of control statements. A straight-forward approach would be to a recursive function:</p>
				<pre class="language-python"><code>
					def add_squares(accum, k, n):
						if k > n:
							return accum
						else:
							add_squares(accum + k**2, k + 1, n)
				</code></pre>
				<p>Recursion, however, is not the only means of tackling this problem. We can also perform the computation with a loop:</p>
				<pre class="language-python"><code>
					def add_squares(k, n):
						accum = 0
						while k <= n:
							accum = accum + k**2
							k += 1
						return accum
				</code></pre>
			</section>

			<section id="exercises-functions" class="grid-item exercise">
				<p><span class="exh">Exercise</span>. For the following functions, what is the return type?</p>
				<ol>
					<li>Function:</li>
						<pre class="language-python"><code>
							def a(x):
								'''
								x: int or float
								'''
								return x + 1
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>This function adds a data object of type <span class="monoText">int</span> or <span class="monoText">float</span> to the <span class="monoText">int 1</span>. Recall that in Python, adding two values of type <span class="monoText">int</span> will always result in an <span class="monoText">int</span>, but if just one of the addends is a <span class="monoText">float</span>, then the result is a <span class="monoText">float</span>. Thus, this function returns outputs of either type <span class="monoText">int</span> or type <span class="monoText">float</span>.</p>
						</details>
					<li>Function:</li>
						<pre class="language-python"><code>
							def a(x):
								'''
								x: int or float.
								'''
								return x + 1.0
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>The input here is either an <span class="monoText">int</span> or <span class="monoText">float</span>. The computation is an <span class="monoText">int</span> or <span class="monoText">float</span> added by the float <span class="monoText">1.0</span>. Because we're adding <span class="monoText">x</span> to a float, function returns an output of type <span class="monoText">float</span>.</p>
						</details>
						<li>Function:</li>
						<pre class="language-python"><code>
							def c(x, y):
								'''
								x: int or float
								y: int or float
								'''
								return x + y
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>Like the first function, this function's output type will vary. If both <span class="monoText">x</span> and <span class="monoText">y</span> are bound to data objects of type <span class="monoText">int</span>, then the result is an <span class="monoText">int</span>. If <span class="monoText">x</span> is bound to a <span class="monoText">float</span> or <span class="monoText">y</span> is bound to a <span class="monoText">float</span>, then the function returns a data object of type <span class="monoText">float</span>.</p>
						</details>
					<li>Function:</li>
						<pre class="language-python"><code>
							def d(x, y):
								'''
								x: Can be int or float
								y: Can be int or float
								'''
								return x > y
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>This function takes either an <span class="monoText">int</span> or a <span class="monoText">float</span>, and compares the values. To do so, the comparison operator <span class="monoText">">"</span> is used. This operator always returns either <span class="monoText">True</span> or <span class="monoText">False</span>. Thus, this function returns an output of type <span class="monoText">boolean</span>.</p>
						</details>
					<li>Function:</li>
						<pre class="language-python"><code>
							def e(x, y, z):
								'''
								x: Can be int or float
								y: Can be int or float
								z: Can be int or float
								'''
								return x >= y and x <= z
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>Like the previous example, this function uses comparison operators, but it also uses the boolean operator <span class="monoText">and</span>. Either or, the function returns an output of type <span class="monoText">boolean</span>.</p>
						</details>
					<li>Function:</li>
						<pre class="language-python"><code>
							def f(x, y):
								'''
								x: int or float
								y: int or float
								'''
								x + y - 2
						</code></pre>
						<details class="answer">
							<summary>Answer</summary>
							<p>This function does not have any output. There is no <span class="monoText">return</span> statement. Accordingly, we can say that the function's output type is <span class="monoText">NoneType</span>.</p>
							<p>If the function included a <span class="monoText">return x + y - 2</span>: The function takes <span class="monoText">int</span> or <span class="monoText">float</span> inputs, then adds them, and subtracts by the <span class="monoText">int 2</span>. Recall that with subtraction, if both the subtrahend (the number being subtracted from) and the minuend (the number the subtrahend is subtracted from) are <span class="monoText">int</span>s, then the difference is an <span class="monoText">int</span>. If either the subtrahend or the minuend are <span class="monoText">float</span>s, then the difference is a float. Accordingly, this function returns a data object of type <span class="monoText">int</span> or <span class="monoText">float</span>.</p>
						</details>
				</ol>

				<p><span class="exh">Exercise</span>. Write a function that takes one number as input and returns the square of that number.</p>
					<details class="answer">
						<summary>Solution</summary>
						<p>Here is one possible implementation:</p>
						<pre class="language-python"><code>
							def square(x):
								'''
								x: int or float
								output: square of int or float
								'''
								return x**2
						</code></pre>
					</details>
				
				<p><span class="exh">Exercise</span>. Write a function, <span class="monoText">evalQuadratic(a, b, c, x)</span>, that returns the value of the quadratic ${f(x) = ax^2 + bx + c.}$</p>
					<details class="answer">
						<summary>Solution</summary>
						<p>Here is one possible implementation:</p>
						<pre class="language-python"><code>
							'''
							Given f(x) = ax^2 + bx + c, function outputs f(x)
							a, b, c: Values for the coefficients of the quadratic equation
							x: value at which to evaluate the quadratic
							'''
							return (a*(x**2) + (b*x) + c)
						</code></pre>
					</details>
				
				<p><span class="exh">Exercise</span>. Consider the following code:</p>
				<pre class="language-python"><code>
					def a(x):
						'''
						x: int or float
						'''
						return x + 1

					def b(x):
						'''
						x: int or float
						'''
						return x + 1.0

					def c(x, y):
						'''
						x: int or float
						y: int or float
						'''
						return x + y

					def d(x, y):
						'''
						x: Can be of any type
						y: Can be of any type
						'''
						return x > y

					def e(x, y, z):
						'''
						x: Can be of any type
						y: Can be of any type
						z: Can be of any type
						'''
						return x >= y and x <= z

					def f(x, y):
						'''
						x: int or float
						y: int or float
						'''
						x + y - y
				</code></pre>
				<p>For each of the function calls below, what is (a) the returned data object and (b) what is its type?</p>
				<ol>
					<li><span class="monoText">a(6)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Here, we pass as an argument the <span class="monoText">int 6</span>. Thus, <span class="monoText">a(x)</span> returns <span class="monoText">x + 1</span>: <span class="monoText">7</span>. This an <span class="monoText">int</span> added to an <span class="monoText">int</span>, so the returned data object is of type <span class="monoText">int</span>.</p>
						</details>
					<li><span class="monoText">a(-5.3)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>We pass the float <span class="monoText">-5.3</span> as an argument into <span class="monoText">b(x)</span>. Thus, <span class="monoText">b(x)</span> computes <span class="monoText">x + 1.0</span>, which is <span class="monoText">-4.3</span>. This is a <span class="monoText">float</span> added to a <span class="monoText">float</span>, so the returned data object is of type <span class="monoText">float</span>.</p>
						</details>
					<li><span class="monoText">a(a(a(6)))</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Here, we have nested calls. <span class="monoText">a()</span> takes as an argument <span class="monoText">a()</span>, which takes as an argument <span class="monoText">a(6)</span>. At <span class="monoText">a(6)</span>, the returned data object is an <span class="monoText">int</span> &mdash; the value <span class="monoText">7</span>. That gets passed as an argument to the second <span class="monoText">a()</span>, which returns the <span class="monoText">int 8</span>. That then gets passed as an argument into the outermost <span class="monoText">a()</span>, which returns the <span class="monoText">int 9</span>.</p>
						</details>
					<li><span class="monoText">c(a(1), b(1))</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>We have two arguments passed to this function. The first argument is <span class="monoText">a(1)</span>, which returns <span class="monoText">int 2</span>. The second argument is <span class="monoText">b(x)</span>, which returns the <span class="monoText">float 2.0</span>. Both those return values go into the function <span class="monoText">c(x, y)</span>, which returns <span class="monoText">x + y</span>. Thus, the returned data object is <span class="monoText">4.0</span>, of type <span class="monoText">float</span>.</p>
						</details>
					<li><span class="monoText">d('apple', 11.1)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Again, two arguments are passed to a function. Here, it is the string <span class="monoText">'apple'</span> and the <span class="monoText">float 11.1</span>. Inside <span class="monoText">d(x, y)</span>, we are comparing values. But, in this case, we're comparing string type data and numeric type data. This will not do &mdash; an error is returned.</p>
						</details>
					<li><span class="monoText">e(a(3), b(4), c(3, 4))</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Three arguments are passed into this function. <span class="monoText">a(3)</span> will return the <span class="monoText">int 4</span>; <span class="monoText">b(4)</span> will return the <span class="monoText">float 5.0</span>; and <span class="monoText">c(3, 4)</span> will returns the <span class="monoText">int 7</span>. Those arguments are all passed into <span class="monoText">e(x, y, z)</span>, which compares the value. In this case:</p>
							<ul>
								<li><span class="monoText">x = 4</span></li>
								<li><span class="monoText">y = 5.0</span></li>
								<li><span class="monoText">z = 7</span></li>
							</ul>
							<p>Comparing the values:</p>
							<figure class="math-display">
								<div>
									<p><span class="monoText">4 >= 5.0 and 4 <= 7</span></p>
								</div>
							</figure>
							<p>This is clearly false. The invokation returns the data object <span class="monoText">False</span> of type <span class="monoText">boolean</span>.</p>
						</details>
					<li><span class="monoText">f</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>This is our first example of the type <span class="monoText">function</span>. Functions are data objects. Because they are data objects, they have a data type. In this case, the type <span class="monoText">function</span>. If we entered <span class="monoText">f</span> in the shell, we get the following:</p>
							<pre class="language-bash"><code>
								&lt;function __main__.f(x, y)&gt;
							</code></pre>
							<p>We can also see that this is a data object by modifying the code:</p>
							<pre class="language-python"><code>
								def f(x, y):
									'''
									x: int or float
									y: int or float
									'''
									x + y - y
								print(type(f))
							</code></pre>
							<pre class="language-bash"><code>
								&lt;class &apos;function&apos;&gt;
							</code></pre>
						</details>
				</ol>

				<p><span class="exh">Exercise</span>. Consider the following code:</p>
				<pre class="language-python"><code>
					def a(x, y z):
						if x:
							return y
						else:
							return z
					def b(q, r):
						return a(q>r, q, r)
				</code></pre>
				<p>What is (a) the value output by the function calls below, and (b) if there is a value output, what is its type?</p>
				<ol>
					<li><span class="monoText">a(False, 2, 3)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>This is a call to function <span class="monoText">a()</span>. The arguments are <span class="monoText">False</span>, <span class="monoText">2</span>, and <span class="monoText">3</span>. Thus:</p>
							<ul>
								<li><span class="monoText">x = False</span></li>
								<li><span class="monoText">y = 2</span></li>
								<li><span class="monoText">z = 3</span></li>
							</ul>
							<p>Since <span class="monoText">x = False</span>, the <span class="monoText">if</span> block does not execute. We proceed to the <span class="monoText">else</span> block. That block returns <span class="monoText">z</span>, which is bound to <span class="monoText">3</span>. This is an <span class="monoText">int</span> type value.</p>
						</details>
					<li><span class="monoText">b(3, 2)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>This is a call to function <span class="monoText">b(q, r)</span>. Passed as arguments are <span class="monoText">int 3</span> and <span class="monoText">int 2</span>. Thus:</p>
							<ul>
								<li><span class="monoText">q = 3</span></li>
								<li><span class="monoText">r = 2</span></li>
							</ul>
							<p>Function <span class="monoText">b(q, r)</span> calls function <span class="monoText">a(x, y, z)</span>, with the arguments <span class="monoText">q>r</span>, <span class="monoText">q</span>, and <span class="monoText">r</span>. The expression <span class="monoText">q>r</span> evaluates to <span class="monoText">True</span> (${3 > 2.}$ Thus:</p>
							<ul>
								<li><span class="monoText">x = True</span></li>
								<li><span class="monoText">y = 3</span></li>
								<li><span class="monoText">z = 2</span></li>
							</ul>
							<p>Because <span class="monoText">x = True</span>, the truth block executes. Since <span class="monoText">y = 3</span>, the value <span class="monoText">3</span> of type <span class="monoText">int</span> is returned.</p>
						</details>
					<li><span class="monoText">a(3>2, a, b)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>This is a call to function <span class="monoText">a(x, y, z)</span>. The arguments passed are <span class="monoText">3>2</span>, <span class="monoText">a</span>, and <span class="monoText">b</span>. Thus:</p>
							<ul>
								<li><span class="monoText">x = 3>2</span> (returns <span class="monoText">True</span>)</li>
								<li><span class="monoText">y = a</span></li>
								<li><span class="monoText">z = b</span></li>
							</ul>
							<p>Because <span class="monoText">x = True</span>, we proceed to the truth block. This tells us to return <span class="monoText">y</span>. <span class="monoText">y = a</span>, and <span class="monoText">a</span> is the name of a function. Thus, this will return a value <span class="monoText">function</span>, and the type <span class="monoText">function</span>.</p>
						</details>
					<li><span class="monoText">b(a, b)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>This is a call to function <span class="monoText">b(q, r)</span>, with the arguments <span class="monoText">a</span> and <span class="monoText">b</span> passed. Hence:</p>
							<ul>
								<li><span class="monoText">q = a</span></li>
								<li><span class="monoText">r = b</span></li>
							</ul>
							<p>This will return an error. The function <span class="monoText">b</span> computes which of two functions is greater. This is a nonsensical operation.</p>
						</details>
				</ol>

				<p><span class="exh">Exercise</span>. For each of the function calls below: (a) what is the value returned, and (b) if there is a value returned, what is its type?</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							a = 10
							def f(x):
								return x + a
							a = 3
							f(1)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Here we call the <span class="monoText">f(x)</span>, passing into it the argument <span class="monoText">1</span> of type <span class="monoText">int</span>. Inside <span class="monoText">f(x)</span>, we compute <span class="monoText">x + a</span>. The value of <span class="monoText">a</span> is <span class="monoText">3</span>, the most recent binding of <span class="monoText">a</span>. Thus, <span class="monoText">f(1)</span> returns <span class="monoText">1 + 3</span>, which the <span class="monoText">int</span> value <span class="monoText">4</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = 12
							def g(x):
								x = x + 1
								def h(y):
									return x + y
								return h(6)
							g(x)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This is a call to <span class="monoText">g(x)</span>. The variable <span class="monoText">x</span> stores the <span class="monoText">int</span> value <span class="monoText">12</span>. Inside <span class="monoText">g(x)</span>, we compute <span class="monoText">x = x + 1</span>. Thus, <span class="monoText">x = 12 + 1 = 13</span>. <span class="monoText">g(6)</span> then calls the function <span class="monoText">h(y)</span>, passing as an argument the <span class="monoText">int</span> value <span class="monoText">6</span>. <span class="monoText">h(y)</span> then computes <span class="monoText">x + y</span>; this is <span class="monoText">13 + 6</span>. Thus, <span class="monoText">h(6)</span> returns the <span class="monoText">int</span> value <span class="monoText">19</span>. This is the value returned by <span class="monoText">g(x)</span>.</p>
						</details>
					</li>
				</ol>
			</section>

			<section id="calling_functions_and_scope" class="grid-item">
				<h4>Calling Functions; Scope</h4>
				<p>Whenever we call functions, we must always bear in mind the concept of <span class="boldItalics">scope</span>. Consider the following function:</p>
				<pre class="language-python"><code>
					def f(x):
						x = x + 1
						print(f'in f(x): x = {x}')
						return x
					x = 3
					z = f(x)
				</code></pre>
				<pre class="language-bash"><code>
					in f(x): x = 4
				</code></pre>
				<p>Why is <span class="monoText">x = 4</span>? This is occurring because <span class="boldItalics">variable scope</span>. Each <span class="boldItalics">formal parameter</span> is bound to the value of the <span class="boldItalics">actual parameter</span> when the function is called. The moment we call a function, we created a new <span class="boldItalics">environment</span> (also called a <span class="italicsText">frame</span> or a <span class="italicsText">scope</span>). The environment is where we bind variables; evaluations inside a function are always relative to that environment. Scope is simply a mapping of names to data objects.</p>
				<p>In the code above, the variable <span class="monoText">x</span> is bound to the data object <span class="monoText">3</span> in the <span class="italicsText">global scope</span>. Because <span class="monoText">x</span> is bound to <span class="monoText">3</span> in the global scope, when Python reaches <span class="monoText">z = f(x)</span>, the value that is passed into the function is <span class="monoText">x</span>. When we call <span class="monoText">f()</span>, we create a new scope. That new scope will inherit data objects from the global scope if the function's body needs it. In this case, the global scope provides <span class="monoText">x = 3</span>. Thus, when the function executes, <span class="monoText">x = 4</span> &mdash; Python evaluates the function relative to the global scope.</p>
				<p>Here is another example. What happens if there is no <span class="monoText">return</span> statement?</p>
				<pre class="language-python"><code>
					def is_even(i):
						'''
						Input: i, a positive int
						No return
						'''
						i%2 == 0
				</code></pre>
				<p>If we do not include a <span class="monoText">return</span> statement, Python returns the value <span class="monoText">None</span> (the only value of type <span class="monoText">NoneType</span>). As we know, <span class="monoText">None</span> represents the absence of value. Note what this means: If we want a function to actually output something, we must have a <span class="monoText">return</span> statement.</p>
				<p><span class="topic">Caution</span>. The <span class="monoText">return</span> statement will terminate the function's execution. This means that once Python reaches a <span class="monoText">return</span> statement, everything is done &mdash; any code after the <span class="monoText">return</span> statement <span class="underlineText">will not</span> be executed.</p>
				<p><span class="topic">Functions as Arguments</span>. Functions can be passed as arguments to other functions. Consider the following example:</p>
				<pre class="language-python"><code>
					def func_a():
						print('inside func_a')
					def func_b(y):
						print('inside func_b')
						return y
					def func_c(z):
						print('inside func_c')
						return z()
					print(func_a())
					print(5 + func_b(2))
					print(func_c(func_a))
				</code></pre>
				<p>Let's run through what this code does. Based on what we know so far, we might predict: The statement <span class="monoText">print(func_a())</span> invokes <span class="monoText">func_a()</span>. So, it will print <span class="monoText">'inside func_a'</span>. Then, <span class="monoText">print(5 + func_b(2))</span> invokes <span class="monoText">func_b()</span>, and passed into it the argument <span class="monoText">2</span>, a data object of type <span class="monoText">int</span>. Thus, <span class="monoText">func_b(y)</span> will print <span class="monoText">'inside func_b'</span> and <span class="monoText">return</span> the data object <span class="monoText">2</span> of type <span class="monoText">int</span>. Accordingly, <span class="monoText">print(5 + func_b(2))</span> will print <span class="monoText">7</span>. Finally, <span class="monoText">print(func_c(func_a))</span> invokes <span class="monoText">func_(c))</span>, with the argument <span class="monoText">func_(a)</span>. So, it prints <span class="monoText">'inside func_c'</span>, then <span class="monoText">return</span>s <span class="monoText">func_a()</span> &mdash; which prints <span class="monoText">'inside func_a'</span>.</p>
				<p>Verifying, here is the output:</p>
				<pre class="language-bash"><code>
					inside func_a
					None
					inside func_b
					7
					inside func_c
					inside func_a
					None
				</code></pre>
				<p>All correct, except: Where is the <span class="monoText">None</span> coming from? The <span class="monoText">None</span> is appearing because <span class="monoText">func_a()</span> has no <span class="monoText">return</span> statement. Because we told Python to print the output of <span class="monoText">func_a()</span>, Python printed the output <span class="monoText">None</span>.</p>
				<p><span class="topic">Using Variables in Functions</span>. There are two rules we should always be cognizant of when we use variables in functions:</p>
				<div class="rule">
					<p><span class="topic">Rule</span>. Let ${f}$ be some function, and ${x}$ be some variable defined <span class="italicsText">outside</span> the body of ${f}$. <span class="italicsText">Inside</span> the body of ${f}$:</p>
					<ol>
						<li>We <span class="underlineText">can access</span> ${x;}$ and</li>
						<li>We <span class="underlineText">cannot modify</span> ${x.}$</li>
					</ol>
				</div>
				<p>Compare the following examples:</p>
				<div class="compare">
					<pre class="language-python"><code>
						# Script A
						def f(y):
							x = 1
							x += 1
							print(x)
						x = 5
						f(x)
						print(x)
					</code></pre>
					<pre class="language-python"><code>
						# Script B
						def g(y):
							print(x)
							print(x + 1)
						x = 5
						g(x)
						print(x)
					</code></pre>
					<pre class="language-python"><code>
						# Script C
						def h(y):
							x = x + 1
						x = 5
						h(x)
						print(x)
					</code></pre>
				</div>
				<p>In <span class="monoText">Script A</span>, we call the function <span class="monoText">f()</span> and pass into it the argument <span class="monoText">x</span>. We've bound the variable <span class="monoText">x</span> to the data object <span class="monoText">5</span> of type <span class="monoText">int</span>. Thus, <span class="monoText">x = 5</span> is passed into <span class="monoText">f()</span>. But, inside <span class="monoText">f()</span>, we redefined the variable <span class="monoText">x</span>: <span class="monoText">x = 1</span>. Thus, the value of <span class="monoText">x</span> used inside <span class="monoText">f()</span> is not <span class="monoText">x = 5</span>, but <span class="monoText">x = 1</span>. Thus, the output from calling <span class="monoText">f(x)</span> is <span class="monoText">2</span>. In the last line outside the function definition (inside the global environment), we print <span class="monoText">x</span>. That value is <span class="monoText">x = 5</span>, not <span class="monoText">x = 1</span>. Accordingly, the very last <span class="monoText">print(x)</span> in the global environment outputs <span class="monoText">5</span>. Running <span class="monoText">Script A</span> in a shell confirms:</p>
				<pre class="language-bash"><code>
					2
					5
				</code></pre>
				<p>In <span class="monoText">Script B</span>, we again pass <span class="monoText">x = 5</span> as an argument for <span class="monoText">g(y)</span>. That function will print <span class="monoText">x</span>: <span class="monoText">5</span>. Then it prints the result of <span class="monoText">x + 1</span>: <span class="monoText">6</span>. Finally, the last <span class="monoText">print(x)</span> in the global scope prints the value of <span class="monoText">x</span>: <span class="monoText">5</span>. A shell session confirms:</p>
				<pre class="language-bash"><code>
					5
					6
					5
				</code></pre>
				<p>Note that this <span class="monoText">Script B</span> works because we aren't modifying the global variable <span class="monoText">x</span> at all. All we are doing in <span class="monoText">g(y)</span> is printing. We can see this to be the case by comparing these two scripts:</p>
				<div class="compare">
					<div>
						<pre class="language-python"><code>
							def g(y):
								return x + 1
							x = 5
							g(x)
							print(g(x))
						</code></pre>
						<pre class="language-bash"><code>
							6
						</code></pre>
					</div>
					<div>
						<pre class="language-python"><code>
							def g(y):
								x = x + 1
								return x
							x = 5
							g(x)
							print(g(x))
						</code></pre>
						<pre class="language-bash"><code>
							UnboundLocalError: local variable 'x' referenced before assignment
						</code></pre>
					</div>
				</div>
				<p>In <span class="monoText">Script C</span>, we again pass <span class="monoText">x</span> as an argument into the function <span class="monoText">h(y)</span>. This is where we encounter a problem. Here, we're trying to reference the variable <span class="monoText">x</span> before we've even assigned it. More specifically, we are trying to <span class="italicsText">modify</span> <span class="monoText">x</span> directly. This is a violation of the rule above: We cannot modify <span class="monoText">x</span>. Output:</p>
				<pre class="language-bash"><code>
					UnboundLocalError: local variable 'x' referenced before assignment
				</code></pre>
				<p>If we wanted <span class="monoText">Script C</span> to work, we would instead write:</p>
				<pre class="language-python"><code>
					def h(x):
						x = x + 1
						print(x)
					x = 5
					h(x)
				</code></pre>
				<pre class="language-bash"><code>
					6
				</code></pre>
				<p>Why does this work? Compare <span class="monoText">Script C</span> with the revised script:</p>
				<div class="compare">
					<pre class="language-python"><code>
						def h(y):
							x = x + 1
						x = 5
						h(x)
						print(x)

						# prints UnboundLocalError
					</code></pre>
					<pre class="language-python"><code>
						def h(x):
							x = x + 1
							print(x)
						x = 5
						h(x)

						# prints 6
					</code></pre>
				</div>
				<p>The two scripts output different results because of scope. In the revised script, we've declared <span class="monoText">x</span> as a parameter. Because <span class="monoText">x</span> is a parameter, the variable named <span class="monoText">x</span> exists inside the function <span class="monoText">h(x)</span>'s scope. In contrast, for the function <span class="monoText">h(y)</span>, there is no such variable. There is no variable <span class="monoText">x</span> inside the function <span class="monoText">h(y)</span> because the parameter for <span class="monoText">h(y)</span> is only the variable named <span class="monoText">y</span>. When we wrote the statement ${x = x + 1,}$ we effectively told Python to modify <span class="monoText">x</span>&mdash;a variable <span class="italicsText">outside</span> <span class="monoText">h(y)</span>&mdash;while we are <span class="italicsText">inside</span> <span class="monoText">h(y)</span>. This is a direct violation of the rule we stated earlier, and Python will not execute. We can see that this is true with the code below:</p>
				<pre class="language-python"><code>
					# Notice there is no x declaration in h(x)

					def h(x):
						print(f'Inside h(x), there is a variable x = {x}')
					x = 5
					h(x)
				</code></pre>
				<pre class="language-bash"><code>
					Inside h(x), there is a variable x = 5
				</code></pre>
				<p>To nail the coffin, <span class="monoText">Script C</span> also works if we assign <span class="monoText">y</span> (the variable that exists locally in <span class="monoText">h(y)</span>) to <span class="monoText">x</span> (the variable passed as an argument). In doing so, we obtain a <span class="italicsText">local</span> <span class="monoText">x</span> which we can modify:</p>
				<pre class="language-python"><code>
					def h(y):
						x = y
						x = x + 1
						print(x)	
					x = 5
					h(x)
					print(x)
				</code></pre>
				<pre class="language-bash"><code>
					6
					5
				</code></pre>
				<p><span class="topic">Functions Defined Inside Functions</span>. Scope can get very tricky when we start defining functions inside functions. This does not mean we should not define functions inside functions (this is perfectly normal, and in many situations, good design). Rather, it just means we should always be thinking about scope. Here is code defining a function inside a function:</p>
				<pre class="language-python"><code>
					def g(x): 
						def h():
							x = 'abc'
						x = x + 1
						print(f'In g(x): x = {x}')
						h()
						return(x)
					x = 3
					z = g(x)
				</code></pre>
				<pre class="language-bash"><code>
					in g(x): x = 4
				</code></pre>
				<p>Let's walk through this code carefully.</p>
				<ol>
					<li>First, we defined the function <span class="monoText">g(x)</span>. It takes some parameter <span class="monoText">x</span>. Inside <span class="monoText">g(x)</span>, we defined the function <span class="monoText">h()</span>. That function takes no parameters, but it initializes a variable <span class="monoText">x</span> with the string object <span class="monoText">'abc'</span>. The function <span class="monoText">g(x)</span> then computes <span class="monoText">x = x + 1</span>, and prints a string. Then it calls <span class="monoText">h()</span>. Finally, it returns the value of <span class="monoText">x</span> (<span class="monoText">x = x + 1</span>).</li>
					<li>Second, we initialized the variable <span class="monoText">x</span> with the <span class="monoText">int</span> object <span class="monoText">3</span>.</li>
					<li>Finally, we assigned to <span class="monoText">z</span> the function <span class="monoText">g(x)</span>. This statement invokes <span class="monoText">g(x)</span>:</li>
					<ol>
						<li><span class="monoText">g(x)</span> computes <span class="monoText">x = x + 1</span>. <span class="monoText">x = 4</span>.</li>
						<li>Then it prints the relevant string.</li>
						<li>Next it calls <span class="monoText">h()</span>, but that function has no return.</li>
						<li>Finall, <span class="monoText">g(x)</span> returns the <span class="monoText">int</span> object <span class="monoText">4</span>.</li>
					</ol>
				</ol>
				<p>Some terminology: In the code above, the function <span class="monoText">h()</span> is broadly called a <span class="boldItalics">helper function</span> &mdash; a function that belongs to another function; it can only be used if its parent function is used.</p>
				<p>Where did the <span class="monoText">x = 'abc'</span> go? It became a <span class="boldItalics">garbage value</span>. Programming languages like Python have a feature called <span class="boldItalics">garbage collection</span> &mdash; the ability to reclaim memory occupied by data objects when those data objects are no longer referenced. Garbage collection is a form of automatic memory management &mdash; it is how languages like Python allow programmers to go without using memory-freeing functions like <span class="monoText">free()</span> in C.</p>
			</section>

			<section id="keyword_arguments" class="grid-item">
				<h4>Keyword Arguments &amp; Default Values</h4>
				<p>We can write function definitions that can change, depending on <span class="italicsText">how</span> we invoke it. For example:</p>
				<pre class="language-python"><code>
					def printName(firstName, lastName, reverse):
						if reverse:
							print(f'{lastName}, {firstName}')
						else:
							print(firstName, lastName)

					# invokations:
					printName('Sherlock', 'Holmes', False)
					printName('Sherlock', 'Holmes', reverse = False)
					printName('Sherlock', lastName = 'Holmes', reverse = False)
					printName(lastName = 'Holmes', firstName = 'Sherlock', reverse = False)
					printName('Sherlock', 'Holmes', True)
				</code></pre>
				<pre class="language-bash"><code>
					Sherlock Holmes
					Sherlock Holmes
					Sherlock Holmes
					Sherlock Holmes
					Holmes, Sherlock
				</code></pre>
				<p>Notice how all of the functions above outputed the same string, save for the last one, where we set <span class="monoText">reverse</span> to true. We can specify our arguments in a function's parameters.This is helpful when we forget the order of the parameters.</p>
				<p><span class="topic">Default Values</span>. We can also give functions <span class="italicsText">default values</span> &mdash; the values used when no arguments are supplied for the parameter:</p>
				<pre class="language-python"><code>
					def printName (firstName, lastName, reverse = False):
						if reverse:
							print(f'{lastName}, {firstName}')
						else:
							print(firstName, lastName)
					printName('Sherlock', 'Holmes')
					printName('Sherlock', 'Holmes', True)
				</code></pre>
				<pre class="language-bash"><code>
					Sherlock Holmes
					Holmes, Sherlock
				</code></pre>
				<p>Default values are particularly useful when we expect parameters to be a particular value, but on rare occasions a different value is needed.</p>
			</section>

			<section id="specifications" class="grid-item">
				<h4>Specifications</h4>
				<p>Functions have <span class="boldText">specifications</span>. We can think of a specification like a contract between two paries: (a) the function's implementer and (b) the function's users. The specification provides two things: (1) the function's assumptions, and (2) the function's guarantees.</p>
				<p><span class="topic">Assumptions</span> The assumptions are the conditions the client must satisfy to use the function. Almost always, the assumptions are what values must be used for the function's parameters.</p>
				<p><span class="topic">Guarantees</span> The guarantees are the conditions that function itself must meet, provided the user has satisfied the assumptions.</p>
				<p>The functions assumptions and guarantees are made explicit in the function's docstring. This is why it is considered best-practic include a docstrig for every function we write.</p>
			</section>

			<section id="iteration_v_recursion" class="grid-item">
				<h4>Iteration vs. Recursion</h4>
				<p>With the materials thus far, we now have the ability to write three types of programs: (1) <span class="italicsText">linear programs</span>, programs that execute in a single direction; (2) <span class="italicsText">branching programs</span>, programs with &#8220;forks&#8221;, executing in different directions depending on particular conditions; and (3) <span class="italicsText">iterative programs</span>, programs that execute in a &#8220;circular&#8221; direction depending on a specified condition. We now add an additional type to our tool kit: <span class="boldText">recursive programs</span>.</p>
				<p><span class="topic">Recursion</span> Recursion is a way to design problems through a divide-and-conquer approach. With respect to functions, it is a programming technique where a function calls itself. There is a danger to recursion &mdash; infinite executions. Save for very few situations, we <span class="underlineText">never</span> want infinite recursion. For this reason, we must follow this rule by default:</p>
				<div class="rule">
					<p><span class="topic">Rule</span> Let ${x}$ be some recursive function. Then $x$ is defined as:</p>
					<figure class="math-display">
						<ul class="abs-code">
							<li>define $x$:</li>
							<ul>
								<li>if $n$ &rarr; return ${m;}$</li>
								<li>else return $x$</li>
							</ul>
						</ul>
					</figure>
					<ul class="def">
						<li>${x \coloneqq}$ the function $x$</li>
						<li>${n \coloneqq}$ a simple base case</li>
						<li>${m \coloneqq}$ the simple base case's output; which is the function's output</li>
					</ul>
				</div>
				<p><span class="topic">Difference from Iteration</span> Recall that with iterative algorithms, we use looping constructs (<span class="monoText">while</span> and <span class="monoText">for</span> loops). In those constructs, we needed a variable to terminate the loop's execution. That variable was set <span class="italicsText">outside</span> the loop, but is changed <span class="italicsText">inside</span> the loop. For example, multiplication is an iterative algorithm. The computation ${a \cdot b}$ is equivalent to &#8220;add $a$ to itself $b$ times.&#8221; Implementing multiplication as a function in Python:</p>
				<pre class="language-python"><code>
					def times(a, b):
						'''
						Input: takes two integers a and b
						Output: a * b
						'''
						product = 0
						while b > 0:
							product += a
							b -= 1
						return product
				</code></pre>
				<p>In the code above, the function <span class="monoText">times()</span> has two parameters: <span class="monoText">a</span> and <span class="monoText">b</span>. This corresponds to ${\texttt{a} \times \texttt{b}.}$ The variable <span class="monoText">b</span> serves as our <span class="italicsText">counter variable</span>. It starts the value passed as argument for <span class="monoText">b</span>, and keeps going down (incrementing by <span class="monoText">1</span>) until it reaches <span class="monoText">0</span>. Once it reaches <span class="monoText">0</span>, the loop terminates. As long as ${\texttt{b} > 0,}$ we keep adding <span class="monoText">a</span> to <span class="monoText">product</span> &mdash; the value of the computation.</p>
				<p>Let's compare this to a recursive solution. To come up with a recursive solution, we should think of its two key parts:</p>
				<ol>
					<li><span class="boldText">The Recusive Step</span></li>
					<p>Here, we must answer the following question: &#8220;How do I reduce the problem to a simpler, or smaller, version of the problem?&#8221;</p>
					<li><span class="boldText">The Base Case</span></li>
					<p>To construct the base case, we want to answer this question: &#8220;How do I reduce the problem until it reaches a simpler case that can be solved directly?&#8221;</p>
				</ol>
				<p>Returning to the multiplication problem, consider the following analysis:</p>
				<figure><img src="images/multiplication_recursive.svg" alt="multiply" loading="lazy" class="fifty-p"></figure>
				<p>As we we've said, ${a \cdot b}$ is really just ${a + a + a \ldots + a}$. We're adding $a$ to itself $b$ times. The first time we add $a$ to itself (${a + a}$), the remaining amounts of times we have to add $a$ is ${b - 1.}$ The second time, ${b - 2}$; the third, ${b - 3;}$ and so on. This computation effectively reduces to ${a + a \times (b-1).}$ But hang on. We're defining multiplication with multiplication? That's circular! Indeed, it is. That is both the beauty and the danger or recursive functions. We avoid that danger by including a base case. Here, we know that the base case will be reached: The moment ${b = 1,}$ then we have ${a \cdot b = a}$ &mdash; the answer is just ${a.}$ This is the <span class="italicsText">simplest case</span>. Knowing this, we can implement in Python:</p>
				<pre class="language-python"><code>
					def times(a, b):
						if b == 1: # this is our base case
							return a
						else:
							return a + times(a, b-1) # recursion
				</code></pre>
				<p>Another mathematical operation conducive to recursion is ${n!,}$ where ${n \in \Z^{+}}$ (the factorial operation). Recall that the factorial takes the form:</p>
				<figure class="math-display">
					<div>
						<p>${n! = n \cdot (n - 1) \cdot (n - 2) \cdot (n -3) \cdot \ldots \cdot 1}$</p>
					</div>
				</figure>
				<p>For this problem, we first ask, &#8220;For what values of $n$ do I know the factorial of?&#8221; Or, more clearly, &#8220;What is the simplest case for this computation?&#8221; Well, the simplest case is ${1! = 1.}$ This is our base case.</p>
				<p>Ok. We have the base case. Now we ask, &#8220;How do I reduce this problem?&#8221; To answer that question, we need to think of rewriting the problem in such a way that the function, as it executes, creeps closer and closer to our base case, ${1! = 1.}$</p>
				<p>Just like the multiplication case, ${n!}$ is essentially ${n * (n - 1)!.}$ Implementing this in Python:</p>
				<pre class="language-python"><code>
					def factorial(n):
						if n == 1: # the base case
							return 1 
						else: # the recursion
							return n*factorial(n-1)
				</code></pre>
				<p><span class="topic">How does the computer know when to stop?</span> Suppose that executed our <span class="monoText">factorial()</span> function:</p>
				<pre class="language-python"><code>
					def factorial(n):
						if n == 1: # the base case
							return 1 
						else: # the recursion
							return n*factorial(n-1)
					print(factorial(4))
				</code></pre>
				<p>The recusion can be envisioned with the following diagram:</p>
				<figure><img src="images/recursive_factorial.svg" alt="factorial whiteboard" loading="lazy" class="ninety-p"></figure>
				<p>The diagram above shows that each recursive call to a function creates its own scope, or environment. Additionally, the variables bound within each frame (environment) is not changed by a recursive call. After each recursive call, the flow of control passes back to the previous scope, once the function call returns a value. That return of value does not occur until the function reaches the base case.</p>
				<p>Alternatively, we can think of the way recursion works in pseudocode:</p>
				<pre class="language-pseudo"><code>
					Input:
					define global factorial(n)
					{
						define local int z = 0
							if (n == 1): 
								then {z = 1}
							else:
								{z = n * factorial(n-1)}
						return z
					}
					define global n = 4
					output factorial(n)
				</code></pre>
				<pre class="language-pseudo"><code>
					Output:
					x = factorial(4)
					x = (4 * factorial(3))
					x = (4 * (3 * factorial(2)))
					x = (4 * (3 * (2 * factorial(1))))
					x = (4 * (3 * (2 * (1))))
					x = (4 * (3 * (2)))
					x = (4 * (6))
					x = (24)
					x = 24
				</code></pre>
				<p>Bearing these details in mind, we can see how iteration and recursion compare:</p>
				<div class="compare">
					<pre class="language-python"><code>
						def factorial(n):
							product = 1
							for i in range (1, n+1):
								product *= i
							return product
					</code></pre>
					<pre class="language-python"><code>
						def factorial(n):
							if n == 1:
								return 1
							else:
								return n*factorial(n-1)
					</code></pre>
				</div>
			</section>

			<section id="exercises-recursion" class="exercise grid-item">
				<p><span class="exh">Exercise</span>. Write a recursive function that takes a nonnegative integer input <span class="monoText">num</span> from the user, sums all nonnegative integers up to <span class="monoText">num</span> (inclusive), and prints the sum.</p>
					<details class="answer">
						<summary>Solution</summary>
						<p>The first question we ask: What is the simplest possible input? In this case, the simplest input is when the integer is 0:</p>
						<figure class="math-display">
							<div>
								<p>${\underbrace{\text{sum(0)} \to 0 }_{\text{ base case }}}$</p>
							</div>
						</figure>
						<p>We have base case then. The next question is, how do the hard cases relate to the simpler cases? For example, if we are given ${\text{sum(0)}}$ can we solve ${\text{sum(1)}?}$ If we have ${\text{sum(2)}}$ can we solve ${\text{sum(3)}?}$ Sure. Consider the pattern:</p>
						<figure class="math-display">
							<div>
								<p>${ n = 1 \to 1}$</p>
								<p>${ n = 2 \to 1 + 2}$</p>
								<p>${ n = 3 \to 1 + 2 + 3}$</p>
								<p>${ n = 4 \to 1 + 2 + 3 + 4}$</p>
								<p>${ n = 5 \to 1 + 2 + 3 + 4 + 5}$</p>
							</div>
						</figure>
						<p>This patterns shows us that if have the result where ${n = 2,}$ we can obtain the result of ${n = 3}$ by adding 3 to the result of ${n = 2}$. If we know the result where ${n = 3,}$ we can obtain the result of ${n = 4}$ by adding 4 to the result of ${n = 3.}$ Great, we have a relationship.</p>
						<p>Now let's generalize the pattern. Suppose we want to compute the arbitrary sum where ${n = k.}$ Well, from the pattern above, we know that this is simply:</p>
						<figure class="math-display">
							<div>
								<p>${\underbrace{1 + 2 + \ldots + k}_{\text{sum($k$)}}}$</p>
							</div>
						</figure>
						<p>Thus, to compute ${\text{sum($k$)},}$ what we have to do is compute ${\text{sum($k-1$)},}$ take the result, and add $k$ to it:</p>
						<figure class="math-display">
							<div>
								<p>${\underbrace{1 + 2 + \ldots + (k - 1)}_{\text{sum($k - 1$)}}}$</p>
							</div>
						</figure>
						<p>Combining the general pattern and the base case, we have an explicit structure for our code:</p>
						<figure class="math-display">
							<div>
								$$
									\text{sum($n$)} = \begin{cases}
										\text{if $n = 0$} \to 0 \\
										\text{else} \to \text{sum($n-1$)} + n 
									\end{cases} 
								$$
							</div>
						</figure>
						<p>Here is one possible implementation:</p>
						<pre class="language-python"><code>
							num = int(input("Add all nonnegative integers up to: "))
							def int_sum(num):
									if num == 0:
										return 0
									else:
										return num + int_sum(num-1)
							sum = int_sum(num)
							print(f'The sum of all nonnegative integers up to {num} is {sum}')
						</code></pre>
						<pre class="language-bash"><code>
							Add all nonnegative integers up to: 5
							The sum of all nonnegative integers up to 5 is 15

							Add all nonnegative integers up to: 9
							The sum of all nonnegative integers up to 9 is 45

							Add all nonnegative integers up to: 100
							The sum of all nonnegative integers up to 100 is 5050

							Add all nonnegative integers up to: 573
							The sum of all nonnegative integers up to 573 is 164451

							Add all nonnegative integers up to: 973
							The sum of all nonnegative integers up to 973 is 473851
						</code></pre>
					</details>
			</section>

			<section id="inductive_reasoning" class="grid-item">
				<h4>Inductive Reasoning</h4>
				<p>With iterative code, we can know that such code will work if we ensure that our loop invariant changes as we go through it. For example, reconsider our iterative multiplication function:</p>
				<pre class="language-python"><code>
					def multiply(a, b):
						result = 0
						while b > 0:
							result += a
							b -= 1
						return result
				</code></pre>
				<p>In the function, the loop will eventually terminate because the condition is <span class="monoText">b > 0</span>, and <span class="monoText">b</span> is decremented by <span class="monoText">1</span> at each iteration. At some point, <span class="monoText">b = 0</span>, in which case the <span class="monoText">while</span> loop's test condition returns false.</p>
				<p>Now consider the recursive function:</p>
				<pre class="language-python"><code>
					def multiply(a, b):
						if b == 1:
							return a
						else: 
							return a + mult(a, b-1)
				</code></pre>
				<p>In this function, rather than using a test condition, we use a base case. In this case, when <span class="monoText">b = 1</span>. When we call <span class="monoText">multiply()</span>, the function returns a <span class="italicsText">smaller</span> version of <span class="monoText">b</span>. As we keep calling <span class="monoText">multiply()</span>, we will eventually reach <span class="monoText">b = 1</span>. This all leads to a crucial point in writing recursive programs:</p>
				<div class="rule">
					<p><span class="topic">Rule</span>. Given a recursive function $f$ with a parameter ${x,}$ and a base case ${b,}$ the definition of $f$ must include statements that change the parameter ${x,}$ such that $f$ eventually reaches the base case ${b.}$</p>
				</div>
				<p>A helpful tool to ensure we comply with the rule above is <span class="boldItalics">inductive reasoning</span>. Suppose we wanted to prove that a statement, indexed on integers, is true for all values of ${n.}$ To construct such a proof, we perform two steps:</p>
				<ol>
					<li>First, prove that it is true when $n$ is the smallest possible value (e.g., ${n = 0}$ or ${n = 1}$).</li>
					<li>Second, prove that if it is true for any arbitrary value of ${n,}$ then it must be true for ${n + 1.}$</li>
				</ol>
				<p>For example, consider the previous exercise where we sought to sum all of the nonnegative integers up to some arbtirary ${n.}$ The general pattern for this computation is the following:</p>
				<figure class="math-display">
					<div>
						<p>${0 + 1 + 2 + 3 + \ldots + n = \dfrac{n(n + 1)}{2}}$</p>
					</div>
				</figure>
				<p>To prove this general pattern is true, we use inductive reasoning. We know the general statement for this computation is provided by the following:</p>
				<figure class="math-display">
					<div>
						<p>${n = \dfrac{n(n+1)}{2}}$</p>
					</div>
				</figure>
				<p>First, we prove that it is true in the base, or simplest, case. We know that ${n \in \Z_{\geq 0},}$ so the base case is when ${n = 0}$:</p>
				<figure class="math-display">
					<div>
						<p>${0 = \dfrac{0(0 + 1)}{2}}$</p>
						<p>${\phantom{0} = \dfrac{0}{2}}$</p>
						<p>${\phantom{0} = 0}$</p>
					</div>
				</figure>
				<p>This proves that statement is true in the simplest case. Now we want to prove the general case. To prove the general case, we want to show that for any arbitrary ${k \in \Z_{\geq 0},}$ the statement is true for ${k + 1.}$ What this means then, is, we want to prove the following (by substitution):</p>
				<figure class="math-display">
					<div>
						<p>${0 + 1 + 2 + \ldots + k + (k + 1) = \dfrac{(k + 1)(k + 2)}{2}}$</p>
					</div>
				</figure>
				<p>Now, assume that the statement is true for some arbtirary ${k \in \Z_{\geq 0}.}$ With that assumption, we can infer the following:</p>
				<figure class="math-display">
					<div>
						<p>${ \underbrace{0 + 1 + 2 \ldots + k}_{\dfrac{k(k + 1)}{2}} + (k + 1) = \dfrac{(k + 1)(k + 2)}{2}}$</p>
					</div>
				</figure>
				<p>Because the expression ${0 + 1 + 2 + \ldots + k}$ converges to ${\dfrac{k(k + 1)}{2},}$ we know that the lefthand side reduces to:</p>
				<figure class="math-display">
					<div>
						<p>${\dfrac{k(k + 1)}{2} + (k + 1)}$</p>
					</div>
				</figure>
				<p>Rearranging this reduced expression:</p>
				<figure class="math-display">
					<div>
						<p>${\dfrac{k(k + 1)}{2} + (k + 1) = \dfrac{k(k + 1)}{2} + \dfrac{2(k + 1)}{2}}$</p>
						<p>${\phantom{\dfrac{k(k + 1)}{2} + (k + 1)} = \dfrac{(k + 1)(k + 2)}{2}}$</p>
					</div>
				</figure>
				<p>This proves that, assuming ${n = \frac{n(n + 1)}{2}}$ is true for some ${k \in \Z_{\geq 0},}$ then it follows that ${n = \frac{n(n + 1)}{2}}$ is true for ${k + 1.}$ And since we proved the base case where ${n = 0,}$ the statement ${n = \frac{n(n + 1)}{2}}$ is true for any ${n \in \Z_{\geq 0}.}$ Why? Because if ${k = 0,}$ then ${k = \frac{k(k + 1)}{2}}$ is true. This mean that ${k}$ is true for some ${k \in \Z_{\geq 0}.}$ Given that $k$ is true for some ${k \in \Z_{\geq 0},}$ it follows that ${k = \frac{k(k + 1)}{2}}$ is true for ${k + 1.}$ Which in turn means that ${k = \frac{k(k + 1)}{2}}$ is true when ${k = 1.}$ And since the statement is true for ${k = 1,}$ it is true for ${k = 2,}$ ${k = 3,}$ ${k = 4,}$ and so on and so forth &mdash; ${k \in \Z_{\geq 0}.}$</p>
				<p>This entire analysis directly translates to code:</p>
				<pre class="language-python"><code>
					def multiply(a ,b):
						if b == 1:
							return a
						else:
							return a + mult(a, b-1)
				</code></pre>
				<p>We first show that the base case is true. Will <span class="monoText">return a</span> yield the correct computation when <span class="monoText">b = 1</span>? Yes. Because we know the base case is true, we first assume that <span class="monoText">muliply()</span> returns the correct computation for problems smaller than <span class="monoText">b</span>. Given that assumption, the increment, <span class="monoText">a + mult(a, b-1)</span>, will also return a correct answer for problem of size <span class="monoText">b</span>. By inductive reasoning, we know that our code will work.</p>
			</section>

			<section id="towers_of_hanoi" class="grid-item">
				<p><span class="topic">The Towers of Hanoi.</span> The <span class="italicsText">Towers of Hanoi</span> is a staple logic puzzle for introductory computer science and discrete mathematics. The puzzle goes as such: There are 3 posts and $n$ number of different sized discs. Inititally, each of the discs are stacked on a single post. The goal: Move the entire stack to the next post, with the following constraints:</p>
				<ol>
					<li>Only one disc can be moved at a time; and</li>
					<li>at no point can a larger disc cover a smaller disc.</li>
				</ol>
				<p>Visually representing this in the simplest case, when ${n = 3:}$</p>
				<figure><img src="images/towers_of_hanoi_simple.svg" alt="towers" loading="lazy" class="ninety-p"></figure>
				<p>How would we implement this as an algorithm? Consider the most basic case, ${n = 3,}$ where the three discs are ${1, 2, 3,}$ where ${1}$ is the largest disk, and ${3}$ the smallest. Suppose further that the posts are ${a, b, c.}$ The moves would go as such:</p>
				<div class="compare">
					<pre class="language-pseudo"><code>
						# initial

						a: 1, 2, 3
						b:
						c:
					</code></pre>
					<pre class="language-pseudo"><code>
						# move-1

						a: 1, 2
						b: 3
						c: 
					</code></pre>
					<pre class="language-pseudo"><code>
						# move-2

						a: 1
						b: 3
						c: 2
					</code></pre>
					<pre class="language-pseudo"><code>
						# move-3

						a: 1
						b: 
						c: 2, 3
					</code></pre>
				</div>
				<div class="compare">
					<pre class="language-pseudo"><code>
						# move-4

						a: 
						b: 1
						c: 2, 3
					</code></pre>
					<pre class="language-pseudo"><code>
						# move-5

						a: 3
						b: 1
						c: 2
					</code></pre>
					<pre class="language-pseudo"><code>
						# move-6

						a: 3
						b: 1, 2
						c: 
					</code></pre>
					<pre class="language-pseudo"><code>
						# final

						a: 
						b: 1, 2, 3
						c: 
					</code></pre>
				</div>
				<p>It looks relatively simple, but we can see that it will take much more work to expose the bottom disk as ${n}$ gets bigger. Indeed, it gets more and more difficult once we start thinking about very large magnitudes of ${n.}$ This problem, however, is conducive to recusion. Moving a disc is no different from moving a stack. If we have ${n}$ discs, move the stack on top of it. How do you move the stack on top of it? Move the stack on top of it. And how do you move that stock on top of it? Move that stack on top of it. This process goes on and on until we're just moving single discs. Indeed, we can write code for this:</p>
				<pre class="language-python"><code>
					def printMove (fromStack, toStack):
						print(f"Move from {fromStack} to {toStack}")

					def TowersHanoi(n, fromStack, toStack, spare):
						if n == 1:
							printMove(fromStack, toStack)
						else:
							TowersHanoi(n - 1, fromStack, spare, toStack)
							TowersHanoi(1, fromStack, toStack, spare)
							TowersHanoi(n - 1, spare, toStack, fromStack)

					print(TowersHanoi(3, 'a', 'b', 'c'))
				</code></pre>
				<pre class="language-bash"><code>
					Move from a to b
					Move from a to c
					Move from b to c
					Move from a to b
					Move from c to a
					Move from c to b
					Move from a to b
					None
				</code></pre>
				<p><span class="exh">Exercise.</span> Write an iterative function that computes the greatest common divisor of two positive integers. Recall: The greatest common divisor is the largest integer that divides each of the two integers without a remainder.</p>
					<details class="answer">
						<summary>Solution</summary>
						<p>Here is one possible implementation:</p>
						<pre class="language-python"><code>
							a = int(input('First integer: '))
							b = int(input('Second integer: '))
							def gcd(a, b):
								for i in range (b, 0, -1):
									if (a % i == 0) and (b % i == 0):
										return i
									elif (i == 1):
										return i
							result = gcd(a, b)
							print(f'gcd({a}, {b}) = {result}')
						</code></pre>
						<pre class="language-bash"><code>
							First integer: 27
							Second integer: 3
							gcd(27, 3) = 3

							First integer: 2
							Second integer: 12
							gcd(2, 12) = 2

							First integer: 40
							Second integer: 24
							gcd(40, 24) = 8

							First integer: 19
							Second integer: 12
							gcd(19, 12) = 1
						</code></pre>
					</details>
				<p><span class="exh">Exercise.</span> Write the same program recursively.</p>
					<details class="answer">
						<summary>Solution</summary>
						<p>Here is a simple implementation, relying on Euclid's algorithm, which states: Given two integers ${a}$ and ${b,}$ if ${b = 0,}$ then the greatest common divisor is ${a.}$ Otherwise, the greatest common divisor is ${b \bmod (a \bmod b).}$</p>
						<pre class="language-python"><code>
							a = int(input('First integer: '))
							b = int(input('Second integer: '))
							def gcd(a, b):
									if b == 0:
										return a
									else:
										return gcd(b, (a % b))
							
							result = gcd(a, b)
							print(f'gcd({a}, {b}) = {result}'))
						</code></pre>
						<pre class="language-bash"><code>
							First integer: 99
							Second integer: 18
							gcd(99, 18) = 9

							First integer: 6
							Second integer: 12
							gcd(6, 12) = 6

							First integer: 97
							Second integer: 3
							gcd(97, 3) = 1
						</code></pre>
					</details>
			</section>

			<section id="multiple_base_cases" class="grid-item">
				<p><span class="topic">Multiple Base Cases.</span> With recursion, we aren't limited to just one base case. In fact, many recursive algorithms rely on multiple base cases. Consider, for the example, computing the following problem.</p>
				<p>Leonardo of Pisa (Fibonacci) proposed this problem: Suppose we have a newborn pair of rabbits, one male and one female. Call the male ${a_m}$ and the female ${a_f.}$ Suppose the rabbits never die, and all female rabbits produce one male rabbit and one female rabbit. After one month, the rabbits, ${a_m}$ and ${a_f,}$ reach gestation and mate. Thus, after one month, ${a_f}$ produces two offspring, ${b_m}$ and ${b_f.}$ After another month, ${b_m}$ and ${b_f}$ produce two offspring, ${c_m}$ and ${c_f,}$ and ${a_m}$ and ${a_f}$ produce another two offspring, ${b_{m_{2}}}$ and ${b_{f_{2}}.}$ Then, after another month, ${c_m}$ and ${c_f}$ produce two offspring, and so on and so forth. Is there a quick way to determine how many rabbits we might have for any ${n}$ amount of years?</p>
				<p>Yes. If we focused on the number of females, a pattern of gestation and offspring produced demonstrates a sequence:</p>
				<figure>
					<table class="truth_table">
						<thead>
							<th>month</th>
							<th>females</th>
						</thead>
						<tbody>
							<tr>
								<td>0</td>
								<td>1</td>
							</tr>
							<tr>
								<td>1</td>
								<td>1</td>
							</tr>
							<tr>
								<td>2</td>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
								<td>5</td>
							</tr>
							<tr>
								<td>5</td>
								<td>8</td>
							</tr>
							<tr>
								<td>6</td>
								<td>13</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>Examining this sequence, we can see a general formula:</p>
				<figure class="math-display">
					<div>
						<p>${r_f(n) = r_f(n - 1) + r_f(n - 2)}$</p>
						<ul class="def">
							<li class="where">${r_f \coloneqq}$ the number of females</li>
							<li>${n \coloneqq}$ the month</li>
						</ul>
					</div>
				</figure>
				<p>How might we represent this sequence in code? Well, we can see that we have two base cases:</p>
				<figure class="math-display">
					<div>
						<p>${r_f(0) = 1}$</p>
						<p>${r_f(1) = 1}$</p>
					</div>
				</figure>
				<p>From the sequence's formula, we can also see that we have two invokations:</p>
				<figure class="math-display">
					<div>
						<p>${r_f(n - 1)}$</p>
						<p>${r_f(n - 2)}$</p>
					</div>
				</figure>
				<p>Accordingly, we can translate this into code:</p>
				<pre class="language-python"><code>
					def fibonacci(n): 
						'''
						input: number of months, n 
						output: number of females at end of n months
						assumes: n is an int >= 0
						'''
						if n == 0 or n == 1:
							return 1
						else:
							return fibonacci(n - 1) + fibonacci(n - 2)
					
					initial_month = fibonacci(0)
					first_month = fibonacci(1)
					sixth_month = fibonacci(6)

					print(initial_month)
					print(first_month)
					print(sixth_month)
				</code></pre>
				<pre class="language-bash"><code>
					1
					1
					13
				</code></pre>
				<p>The code above demonstrates a recursive function with two base cases. We need two base cases here because the function itself has two invocations, ${r_f(n-1)}$ and ${r_f(n-2).}$</p>
			</section>

			<section id="recursion_on_strings" class="grid-item">
				<h4>Recursion on Strings</h4>
				<p>Recursion is not limited to numerica data objects. We can also apply recursion to textual data, i.e., strings. Consider, for example, the palindrome &mdash; a string that reads the same way both forwards and backwards. For example, &#8220;race car&#8221; (setting aside the whitespace) is &#8220;race car&#8221; both foward and back. Ignoring white space and punctuation, how might we write code that determines whether a particular string is a palindrome?</p>
				<p>The first step would be to remove all white spaces and punctuation marks. Next, we convert all the characters to lower case. Thus, the palindrome &#8220;race car&#8221; would simply become &#8220;racecar.&#8221;</p>
				<p>Once the string is converted entirely to characters alone, we determine the base case. What is the simplest case? A string composed of characters 0 or 1 is a palindrome.</p>
				<p>With the base case down, we can then think of the recursive case. The recursive case works as such: Check the first and last characters, and if they're the same, then check the second and second to last, then the third and third to last, etc. If we keep following this process, we will eventually reach our base case: a string of 0 characters or a string of 1 character. The code:</p>
				<pre class="language-python"><code>
					stn = input("String: ")

					def isPalindrome(stn):
						def toCharacters(stn):
							stn = stn.lower()
							pureStn = ''
							for letter in stn:
								if letter in 'abcdefghijklmnopqrstuvwxyz':
									pureStn = pureStn + letter
							return pureStn
						
						def isPal(stn):
							if len(stn) <= 1:
								return True
							else:
								return stn[0] == stn[-1] and isPal(stn[1:-1])

						return isPal(toCharacters(stn))
					
					result = isPalindrome(stn)
					print(result)
				</code></pre>
				<pre class="language-bash"><code>
					String: race car
					True

					String: Abba
					True

					String: palindrome
					False
				</code></pre>
			</section>

			<section id="python_files" class="grid-item">
				<h3>Python Files</h3>
				<p><span class="topic">Writing to Files.</span> As we proceed to the next sections, we will begin writing our own modules. To do so, we need a way to save our work for later use. In Python, this is done through a <span class="term">file handle</span>. This appears as such:</p>
				<pre class="language-python"><code>
					nameHandle = open('outputs', 'w')
				</code></pre>
				<p>The code above tells Python to open a file named <span class="monoText">outputs</span>. The second argument, <span class="monoText">w</span>, tells Python we will write to that file. We then bind that function's result to a name, <span class="monoText">nameHandle</span>, so we can refer to that result and use it:</p>
				<pre class="language-python"><code>
					nameHandle = open('outputs', 'w')
					for i in range(2):
						name = input("Enter name: ")
						nameHandle.write(name + '\')
					nameHandle.close()
				</code></pre>
				<p>This code will open a file named <span class="monoText">outputs</span>, and write to that file the <span class="monoText">name</span> inputted by the user, followed by a new line (a carrier return). Once that's done, close the <span class="monoText">outputs</span> file (<span class="monoText">nameHandle.close()</span>).</p>
				<p><span class="topic">Reading Files.</span> With data stored in a separate file, we can read the data by replacing the argument <span class="monoText">w</span> with <span class="monoText">r</span>:</p>
				<pre class="language-python"><code>
					nameHandle = open('outputs', 'r')
					for line in nameHandle:
						print(line)
					nameHandle.close()
				</code></pre>
				<p><span class="exh">Exercise.</span> Below are two files, <span class="monoText">foo.py</span> and <span class="monoText">bar.py</span>. The file <span class="monoText">bar.py</span> is executed. What is the result printed to the console?</p>
				<ol>
					<li>
						<div class="compare">
							<pre class="language-python"><code>
								# foo.py
								aa = "AA"
								aaa = "AAA"
								c = "C"
								d = "D"
							</code></pre>
							<pre class="language-python"><code>
								# bar.py
								aa = "aa"
								tripleA = "aaa"
								print(aa)
							</code></pre>
						</div>
						<details class="answer">
							<summary>Solution</summary>
							<p>The string <span class="monoText">aa</span> is printed.</p>
						</details>
					</li>
					<li>
						<div class="compare">
							<pre class="language-python"><code>
								# foo.py
								aa = "AA"
								aaa = "AAA"
								c = "C"
								d = "D"
							</code></pre>
							<pre class="language-python"><code>
								aa = "aa"
								tripleA = "aaa"
								print(foo.py)
							</code></pre>
						</div>
						<details class="answer">
							<summary>Solution</summary>
							<p>An error is returned.</p>
						</details>
					</li>
					<li>
						<div class="compare">
							<pre class="language-python"><code>
								# foo.py
								aa = "AA"
								aaa = "AAA"
								c = "C"
								d = "D"
							</code></pre>
							<pre class="language-python"><code>
								# bar.py
								import foo
								aa = "aa"
								tripleA = "aaa"
								print(batteries.aa)
							</code></pre>
						</div>
						<details class="answer">
							<summary>Solution</summary>
							<p>The string <span class="monoText">AA</span> is printed.</p>
						</details>
					</li>
					<li>
						<div class="compare">
							<pre class="language-python"><code>
								# foo.py
								aa = "AA"
								aaa = "AAA"
								c = "C"
								d = "D"
							</code></pre>
							<pre class="language-python"><code>
								# bar.py
								from batteries import *
								aa = "aa"
								print(aa, aaa, c, d)
							</code></pre>
						</div>
						<details class="answer">
							<summary>Solution</summary>
							<p>The strings <span class="monoText">aa</span>, <span class="monoText">AAA</span>, <span class="monoText">C</span>, and <span class="monoText">D</span> are printed.</p>
						</details>
					</li>
				</ol>
			</section>

			<section id="structured_types" class="grid-item">
				<h3>Structured Types</h3>
				<p>Data is not limited to single numbers and strings. In fact, it is much more common for data to come in collections. Just as functions group computations together, <span class="term">data structures</span> group data objects. In the next sections, we consider some of these data structures.</p>
			</section>

			<section id="tuples" class="grid-item">
				<h4>Tuples</h4>
				<p>A <span class="term">tuple</span> is a data structure whose elements are <span class="italicsText">ordered</span> in sequence. By &#8220;ordered,&#8221; we do not mean that the values are ordered from least to greatest or vice versa. We mean that every element in the tuple has an <span class="italicsText">index</span>, or position, in the sequence which we can refer to so as to retrieve that element.</p>
				<p>Like strings, tuples are an <span class="term">immutable</span> data structure &mdash; once initialized, the values of the tuple's elements cannot be changed. Tuples can be <span class="term">homogenous</span> (all of its elements are of just one data type), or they can be <span class="term">heterogenous</span> (the tuple contains mixed data types). In Python, we represent tuples with parentheses:</p>
				<pre class="language-python"><code>
					# declare a tuple
					tple = ()

					# initialize a tuple
					tpl = (2, "one", 3)

					# index into tuple; evaluates to 2
					tpl[0];

					# concatenate tuples; evaluates to (2, "one", 3, 5, 6)
					(2, "one", 3) + (5, 6)  

					# slice tuple; evaluates to ("one",)
					tpl[1:2] 

					# slice again; evaluates to ("one", 3)
					tpl[1:3]

					# TypeError; cannot modify a tuple
					tpl[1] = 4
				</code></pre>
				<p>Note that we must have commas when initializing tuples. If we fail to include commas, Python will assume we are scoping code, rather than initializing a tuple:</p>
				<pre class="language-python"><code>
					tple = ('name',) # outputs a tuple -- ('name',)
					tple = ('name') # outputs a string -- 'name'
				</code></pre>
				<p><span class="topic">Variable Swapping.</span> Tuples are useful for variable swapping. Consider the following variable swaps:</p>
				<div class="compare">
					<figure>
						<pre class="language-python"><code>
							# invalid
							x = y
							y = x
						</code></pre>
						<figcaption>Script A</figcaption>
					</figure>
					<figure>
						<pre class="language-python"><code>
							# valid
							temp = x
							x = y
							y = temp
						</code></pre>
						<figcaption>Script B</figcaption>
					</figure>
					<figure>
						<pre class="language-python"><code>
							# valid
							(x, y) = (y, x)
						</code></pre>
						<figcaption>Script C</figcaption>
					</figure>
				</div>
				<p>We know that Script A returns an error. In Script B, we used the temporary variable method for swapping. Script C provides an alternative way &mdash; with tuples. With the tuple method, we created bindings for <span class="monoText">x</span> and <span class="monoText">y</span>, then we swapped their order in the tuple.</p>
				<p><span class="topic">Returning More Than One Value.</span> Tuples also allow us to return more than one value from a function:</p>
				<pre class="language-python"><code>
					def quotient_and_remainder(x, y):
						q = x // y
						r = x % y 
						return (q, r)

					(quotient, remainder) = quotient_and_remainder(4, 5)
				</code></pre>
				<p><span class="topic">Manipulating Tuples.</span> Tuples are also iterable &mdash; we can loop through them:</p>
				<pre class="language-python"><code>
					def get_data(aTuple):
						nums = ()
						words = ()
						for element in aTuple:
							nums = nums + (element[0],)
							if element[1] not in words: 
								words = words + (element[1],)
						min_nums = min(nums)
						max_nums = max(nums)
						unique_words = len(words)
						return (min_nums, max_nums, unique_words) 
				</code></pre>
				<p>The code above iterates over a tuple containing tuples. <span class="monoText">aTuple((), (), ()).</span> At each iteration (each tuple inside the tuple), we collect the first element inside the tuple, an <span class="monoText">int</span>, and insert it into the empty tuple <span class="monoText">num</span> (<span class="monoText">nums = nums + (t[0],)</span>). Then, we check the second element in the tuple &mdash; a word &mdash; to see if it isn't already inside the empty tuple <span class="monoText">word</span>. If it isn't, we collect and insert it into <span class="monoText">word</span>. We perform for each tuple inside the tuple.</p>
				<p><span class="exh">Exercise.</span> Suppose the following tuple is initialized:</p>
				<pre class="language-python"><code>
					x = (1, 2, (3, 'John', 4), 'Hi')
				</code></pre>
				<p>For each of the following expressions, what is its output type and value?</p>
				<ol>
					<li><span class="monoText">x[0]</span></li>
					<details class="answer">
						<summary>Solution</summary>
						<p>Output: <span class="monoText">1</span>, type <span class="monoText">int</span>.</p>
					</details>
					<li><span class="monoText">x[2]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">(3, 'John', 4,)</span>, type <span class="monoText">tuple</span>.</p>
						</details>
					<li><span class="monoText">x[-1]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">'Hi'</span>, type <span class="monoText">String</span>.</p>
						</details>
					<li><span class="monoText">x[2][2]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">4</span>, type <span class="monoText">int</span>.</p>
						</details>
					<li><span class="monoText">x[2][-1]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">4</span>, type <span class="monoText">int</span>.</p>
						</details>
					<li><span class="monoText">x[-1][-1]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">'i'</span>, type <span class="monoText">String</span>.</p>
						</details>
					<li><span class="monoText">x[-1][2]</span></li>
					<details class="answer">
						<summary>Solution</summary>
						<p>Output: <span class="monoText">Error</span>; index is out of bounds.</p>
					</details>
					<li><span class="monoText">x[0:1]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">(1, 2, (3, 'John', 4))</span>, type <span class="monoText">tuple</span>.</p>
						</details>
					<li><span class="monoText">x[0:-1]</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">(1, 2, (3, 'John', 4))</span>, type <span class="monoText">tuple</span>.</p>
						</details>
					<li><span class="monoText">len(x)</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">4</span>, type <span class="monoText">int</span>.</p>
						</details>
					<li><span class="monoText">2 in x</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">True</span>, type <span class="monoText">Boolean</span>.</p>
						</details>
					<li><span class="monoText">3 in x</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">False</span>, type <span class="monoText">Boolean</span>.</p>
						</details>
					<li><span class="monoText">x[0] = 8</span></li>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">TypeError</span>, cannot modify a tuple.</p>
						</details>
				</ol>
				<p><span class="exh">Exercise.</span> Write a procedure called <span class="monoText">oddTuples</span>, which takes a tuple as input, and returns a new tuple as output, where every other element of the input tuple is copied, starting with the first one.</p>
					<details class="answer">
						<summary>Solution</summary>
						<p>One implementation:</p>
						<pre class="language-python"><code>
							def oddTuples(aTup):
								'''
								input: aTup -- a tuple
								output: a tuple with every other element of aTup
								'''
								newTup = ()
								for element in aTup[::2]:
									newTup = newTup + (element,)
								return newTup
						</code></pre>
						<p>Or, even shorter:</p>
						<pre class="language-python"><code>
							def oddTuples(aTup):
								'''
								input: aTup -- a tuple
								output: a tuple with every other element of aTup
								'''
								return aTup[::2]
						</code></pre>
					</details>
			</section>
			
			<section id="lists" class="grid-item">
				<h4>Lists</h4>
				<p>A <span class="term">list</span> is a data structure like a tuple, but with the key difference that it is <span class="term">mutable</span> &mdash; we can enter the list and change its elements after initialization. This is very different from strings and tuples, which are immutable. This feature is a double-edged sword; the ability to change lists is very useful, but it also presents room for errors.</p>
				<p>Like tuples, lists store their elements in ordered sequence. Accordingly, every list element has an index. In contrast to tuples, we denote lists with square brackets <span class="monoText">[]</span>. Lists are almost always homogenous and rarely heterogenous.</p>
				<p>Just like strings and tuples, we can perform operations with indices:</p>
				<pre class="language-python"><code>
					# declare a list
					a_list = []

					# initialize some lists
					b_list = [2, 'a', 2.17, true]
					L = [1, 2, 3]

					# return lists's length; evaluates to 3
					len[L] 

					# return element at index; evaluates to 1
					L[0]

					# evaluates to 4
					L[2] + 1

					# Out of bounds error
					L[3]
				</code></pre>
				<p>Note that indices need not be literals; we can also provide expressions:</p>
				<pre class="language-python"><code>
					i = 2
					L = [1, 2, 3]

					# evaluates to 2, since L[i - 1] == L[1] 
					L[i - 1]
				</code></pre>
				<p><span class="topic">List Mutability.</span> Because lists are mutable, we can assign elements to indices inside the list. As we saw, we cannot do this with strings and tuples:</p>
				<pre class="language-python"><code>
					L = [1, 2, 3]
					L[0] = 0 

					# L is now [0, 2, 3]
				</code></pre>
				<p>Writing the code above, we directly changed <span class="monoText">L</span>. This is <span class="underlineText">not</span> a new object. It is the same object, changed.</p>
				<p><span class="topic">Looping through a List.</span> Like strings and tuples, lists are iterable; we can loop through their elements:</p>
				<pre class="language-python"><code>
					total = 0
						for i in range(len(L)):
							total += L[i]
				</code></pre>
				<p>The code above is a common pattern for summing all of the elements in a list. The same code can be written more concisely:</p>
				<pre class="language-python"><code>
					total = 0
						for i in L:
							total += i
				</code></pre>
				<p>As a reminder, the elements of a list are indexed starting from <span class="monoText">0</span> to <span class="monoText">len(list)-1</span>. If the <span class="monoText">range(n)</span> function is used, then the elements are indexed from <span class="monoText">0</span> to <span class="monoText">range(n-1)</span>.</p>
				<p><span class="exh">Exercise.</span> The following array is initialized:</p>
				<pre class="language-python"><code>
					x = [1, 2, [3, 'John', 4], 'Hi']
				</code></pre>
				<p>For each of the expressions below, what is the value and the value's type?</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							x[0]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">1</span> of type <span class="monoText">int</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							x[2]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">[3, 'John', 4]</span> of type <span class="monoText">list</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							x[-1]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">Hi</span> of type <span class="monoText">String</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							x[2][2]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">4</span> of type <span class="monoText">int</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							x[0:1]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">[1]</span> of type <span class="monoText">list</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							2 in x
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">True</span> of type <span class="monoText">boolean</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							3 in x
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">False</span> of type <span class="monoText">boolean</span>.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							x = [1, 2, [3, 'John', 4], 'Hi']
							x[0] = 8
							x
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Evaluates to <span class="monoText">[8, 2, [3, 'John', 4], 'Hi']</span> of type <span class="monoText">list</span>.</p>
						</details>
					</li>
				</ol>
			</section>

			<section id="list_operations" class="grid-item">
				<h4>Operations on Lists</h4>
				<p>Like strings and tuples, there are lists come with useful methods. Below we cover some of the most commonly used.</p>
				<p><span class="topic">Adding New Elements to a List.</span> We can add new elements to a list with the <span class="monoText">.append()</span> method:</p>
				<pre class="language-python"><code>
					myList = [1, 2, 3]
					myList.append(4)

					# myList is now [1, 2, 3, 4]
				</code></pre>
				<p>Just as replacing existing elements with indices changes a list, inserting new elements into an existing list <span class="italicsText">mutates</span> the list. The result list is not a new list; it is the same list, mutated.</p>
				<p>Notice further that we use dot notation when applying the <span class="monoText">.append()</span> method. This is because lists in Python are objects &mdash; nearly everything in Python is an object. Because lists are objects, they contain data and functions (methods). We access these functions and data with dot notation:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						object_name.data_or_method
					</code></pre>
				</figure>
				<p><span class="topic">Concatenating Lists.</span> We can also merge, or concatenate lists:</p>
				<pre class="language-python"><code>
					list_a = [1, 2, 3]
					list_b = [4, 5, 6]
					list_c = list_a + list_b 
					# list_c is [1, 2, 3, 4, 5, 6]

					list_c.extend([7, 8])
					# list_c is now [1, 2, 3, 4, 5, 6, 7, 8]
				</code></pre>
				<p>The code above also shows the <span class="monoText">.extend()</span> method, which allows us to add multiple elements to the list.</p>
				<p><span class="topic">Removing Elements in a List.</span> There are multiple ways to delete existing elements in a list. If we want to remove an element with a specific index, we can use the <span class="monoText">.del(<span class="italicsText">list_name[index]</span>)</span> method. If we want to remove the last element in the list, we can use the <span class="monoText">list_name.pop()</span> method. If we want to remove an element but we do now know its index, we can use the <span class="monoText">list_name.remove(<span class="italicsText">element</span>)</span> method.</p>
				<p>The second and last methods, <span class="monoText">.pop()</span> and <span class="monoText">list_name.remove()</span>, have certain features. For <span class="monoText">.pop()</span>, the return value is the last element in the list. For <span class="monoText">list_name.remove()</span>, the method will look for the element, and then remove it. If the the element appears multiple times, it will only remove the first occurrence. If the element is not in the list, it will return an error (you cannot remove something that does not exist).</p>
				<pre class="language-python"><code>
					myList = [1, 2, 3, 4, 5, 6]

					myList.remove(2)
					# myList mutated -- now [1, 3, 4, 5, 6]

					myList.remove(3)
					# myList mutated -- now [1, 4, 5, 6]

					del(myList[1])
					# myList mutated -- now [1, 5, 6]

					myList.pop()
					# myList mutated -- now [1, 5]; returns 6
				</code></pre>
				<p>As an aside, the method <span class="monoText">.pop()</span> is so named from the colloquialism of &#8220;popping&#8221; something off a stack.</p>
				<p><span class="topic">Lists and Strings.</span> An interesting feature in Python is converting from lists to strings and vice versa. This is a particularly useful feature, considering many languages &mdash; e.g., JavaScript &mdash; do not allow this computation. To convert a string to a list, we use the method <span class="monoText">list(string_object)</span>. This method will return a list with every character in <span class="monoText">string_object</span> as elements in a list.</p>
				<p>We can also split strings on a character parameter with <span class="monoText">string_object.split(parameter)</span>. With the <span class="monoText">.split()</span> method, the output is a list of strings. If no parameter is provided, then the string is split according to spaces.</p>
				<p>We can also convert a list of characters into a string with the <span class="monoText">''.join(list_name)</span> method. If we want each of the characters or strings in the list to be separated by a particular character, we use the syntax <span class="monoText">'separating_character'.join(list_name)</span>.</p>
				<pre class="language-python"><code>
					myString = "CS :)"

					list(myString)
					# returns ['C', 'S', ' ', ':', ')']

					myString.split('S')
					# returns ['C', ' :)']

					charList = ['a', 'b', 'c']
					''.join(charList)
					# returns 'abc'

					'_'.join(charList)
					# returns 'a_b_c'
				</code></pre>
				<p><span class="topic">Sorting Lists.</span> We can also sort or reverse the order of the elements in a list:</p>
				<pre class="language-python"><code>
					myList = [3, 4, 1, 2]

					sorted(myList)
					# returns [1, 2, 3, 4] -- does NOT MUTATE myList

					myList.sort()
					# returns [1, 2, 3, 4] -- MUTATES myList

					myList.reverse()
					# returns [4, 3, 2, 1] -- MUTATES myList
				</code></pre>
				<p><span class="topic">The Range Procedure.</span> Now that we've encountered lists and tuples, we can see how the <span class="monoText">range()</span> procedure behaves. When used on its own, <span class="monoText">range()</span> behaves like a tuple:</p>
				<figure class="table">
					<table class="truth_table">
						<tbody>
							<tr>
								<td>range(5)</td>
								<td>Output: (0, 1, 2, 3, 4)</td>
							</tr>
							<tr>
								<td>range(2, 6)</td>
								<td>Output: (2, 3, 4, 5)</td>
							</tr>
							<tr>
								<td>range(5, 2, -1)</td>
								<td>Output: (5, 4, 3)</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>When used in a <span class="monoText">for</span> loop, <span class="monoText">range()</span> behaves like a list:</p>
				<figure class="table">
					<table class="truth_table">
						<tbody>
							<tr>
								<td>range(5)</td>
								<td>Output: [0, 1, 2, 3, 4]</td>
							</tr>
							<tr>
								<td>range(2, 10, 2)</td>
								<td>Output: [2, 4, 6, 8]</td>
							</tr>
							<tr>
								<td>range(5, 0, -1)</td>
								<td>Output: [5, 4, 3, 2, 1]</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p><span class="exh">Exercise.</span> Suppose the following lists are initialized:</p>
				<pre class="language-python"><code>
					list_a = [1, 4, 3, 0]
					list_b = ['x', 'z', 't', 'q']
				</code></pre>
				<p>For each of the expressions following the initialization, what is the output value and its type?</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							list_a = [1, 4, 3, 0]
							list_b = ['x', 'z', 't', 'q']

							list_a.sort
							list_a.sort()
							list_a
							list_a.insert(0, 100)
							list_a.remove(3)
							list_a.append(7)
							list_a
							list_a + list_b
							list_b.sort()
							list_b.pop()
							list_b.count('a')
							list_b.remove('a')
							list_a.extend([4, 1, 6, 3, 4])
							list_a.count(4)
							list_a.index(1)
							list_a.pop(4)
							list_a.reverse()
							list_a
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<pre class="language-python"><code>
								list_a = [1, 4, 3, 0]
								list_b = ['x', 'z', 't', 'q']

								list_a.sort
								# return: built-in method
								# type: function

								list_a.sort()
								# Sort and mutate list_a
								# return: None
								# type: NoneType
								# side effects:
									list_a = [0, 1, 3, 4]

								list_a
								# return: [0, 1, 3, 4]
								# type: list

								list_a.insert(0, 100)
								# .insert(index, element) method inserts 'element' at 'index' 
								# Insert the element 100 at index 0. 
								# list_a is mutated
								# return: None
								# type: NoneType
								# side effects:
									# list_a = [100, 0, 1, 3, 4]

								list_a.remove(3)
								# Remove element 3 from list_a.
								# return: None  
								# type: NoneType
								# side effects:
									# list_a = [100, 0, 1, 4]

								list_a.append(7)
								# Insert element 7 at end of list_a
								# return: None
								# type: NoneType
								# side effects:
									# list_a = [100, 0, 1, 4, 7]

								list_a
								# return: [100, 0, 1, 4, 7]
								# type: list

								list_a + list_b
								# concatenate list_a and list_b
								# creates new list 
								# return: [100, 0, 1, 4, 7, 'x', 'y', 't', 'q']
								# type: list

								list_b.sort()
								# when sort() is used on strings, the strings are sorted alphabetically
								# return: None
								# type: NoneType
								# side effects:
									# sort and mutate list_b 
									# list_b = ['q', 't', 'x', 'y' 'z']

								list_b.pop()
								# remove last element in list_b
								# return: 'z'
								# type: String
								# side effects:
									# list_b is mutated 
									# list b = ['q', 't', 'x', 'y'] 
								
								list_b.count('a')
								# .count(param) returns number of times param appears
								# return: 0
								# type: int
								
								list_b.remove('a')
								# there is no 'a' in list_b
								# return: error
								# type: NoneType

								list_a.extend([4, 1, 6, 3, 4])
								# return: None
								# type: NoneType
								# side effects:
									# extend and mutate list_a
									# list_a = [100, 0, 1, 4, 7, 4, 1, 6, 3, 4]

								list_a.count(4)
								# count how many times '4' appears
								# return: 3
								# type: int

								list_a.index(1)
								# .index(element) returns index of element 
								# return: 2
								# type: int

								list_a.pop(4)
								# .pop(i) removes element at index i
								# element '7' is removed
								# return: 7
								# type: int
								# side effects:
									# list_a is mutated:
									# [100, 0, 1, 4, 4, 1, 6, 3, 4]

								list_a.reverse()
								# reverse list_a elements in place
								# return: None
								# type: NoneType
								# side effects:
									# list_a is mutated
									# list_a = [4, 3, 6, 1, 4, 4, 1, 0, 100]

								list_a
								# return: [4, 3, 6, 1, 4, 4, 1, 0, 100]
								# type: list
							</code></pre>
						</details>
					</li>
				</ol>
			</section>

			<section id="mutating_aliasing_cloning" class="grid-item">
				<h4>Mutating, Aliasing, &amp; Cloning</h4>
				<p>Lists are mutable data objects in memory. When we initialize a list, the list's name is a <span class="italicsText">variable name</span> that points to the list object in memory. Lists, however, have a unique characteristic &mdash; we can have multiple variables pointing to the same list. These different variables are all <span class="term">aliases</span> of the list object &mdash; they all refer to the list object.</p>
				<figure>
					<img src="images/multiple_list_aliases.svg" alt="multiple aliases" loading="lazy" class="sixty-p">
					<figcaption>Multiple variable names pointing to the same list object</figcaption>
				</figure>
				<p>What this means is, if a list has multiple aliases, and we change one of its aliases, that change will affect all of the other aliases. This is called a <span class="term">side effect</span>, and it is something we must always keep in mind when handling lists. For example, the <span class="monoText">sort()</span> proceudre will mutate the list and return nothing. But, the <span class="monoText">sorted()</span> procedure does not mutate the list, and because it returns a new, sorted list, we must assign it to a variable:</p>
				<pre class="language-python"><code>
					list_a = [3, 4, 1, 2]
					list_b = [9, 8, 6, 7]

					print('list_a before sorting = ', list_a)
					print('list_b before sorting = ', list_b)

					sorted_list_a = list_a.sort()

					print('sorted_list_a = ', sorted_list_a)
					print('list_a = ', list_a)

					sorted_list_b = sorted(list_b)

					print('sorted_list_b = ', sorted_list_b)
					print('list_b = ', list_b)
				</code></pre>
				<pre class="language-bash"><code>
					list_a before sorting =  [3, 4, 1, 2]
					list_b before sorting =  [9, 8, 6, 7]
					sorted_list_a =  None
					list_a =  [1, 2, 3, 4]
					sorted_list_b =  [6, 7, 8, 9]
					list_b =  [9, 8, 6, 7]
				</code></pre>
				<p>The example above is evidence of how dangerous list mutability can be. The statement <span class="monoText">list_a.sort()</span> mutates the original list. This danger is exacerbated when we have multiple names for the same list.</p>
				<p>Another way to understand this concept of multiple aliases is by way of analogy. Consider a famous individual, say Calvin Cordozar Broadus Jr. We can associate attributes with Mr. Broadus: creative, rich, rapper. Mr. Broadus has many other names &mdash; Snoop Dogg; Snoop Doggy Dogg; Snoop Lion; Bigg Snoop Dogg; Dogg Father; Snoop Rock; Snoopzilla; DJ Snoopadelic. All these names point to the same person. As such, all of Mr. Broadus's attributes, old and new or associated with government or entertainment name, are attributable to Mr. Broadus: Snoop Doggy Dogg is a rapper; Snoop Dogg is rich; Snoop Lion is a reggae performer &mdash; they all point to the same person, Mr. Broadus. The same phenomenon occurs for list aliases:</p>
				<pre class="language-python"><code>
					warm = ['red', 'yellow', 'orange']
					hot = warm

					print(warm)
					print(hot)

					hot.append('pink')

					print(warm)
				</code></pre>
				<pre class="language-bash"><code>
					['red', 'yellow', 'orange']
					['red', 'yellow', 'orange']
					['red', 'yellow', 'orange', 'pink']
				</code></pre>
				<p>Notice that when we appended the data object <span class="monoText">pink</span> to the list <span class="monoText">hot</span>, we also appended the data object to the list <span class="monoText">warm</span>. This is because both <span class="monoText">warm</span> and <span class="monoText">hot</span> point to the same list object. This is a side effect of manipulating lists. The danger in mutability comes from the fact that we might not have intended to manipulate <span class="monoText">warm</span>.</p>
				<p>On the other hand, the fact that two different names print the same list does not imply that they are aliases for the same list. In other words, the fact that some list name <span class="monoText">list_a</span> and some list name <span class="monoText">list_b</span> print what appeas to be the same list does not imply that <span class="monoText">list_a == list_b.</span> We can see this is the case by mutating one of the lists and checking it against the other:</p>
				<pre class="language-python"><code>
					list_a = [1, 2, 3]
					list_b = [1, 2, 3]

					print('list_a: ', list_a)
					print('list_b: ', list_b)

					list_b.append(4)

					print('list_b mutated')

					print('list_b: ', list_b)
					print('list_a: ', list_a)
				</code></pre>
				<pre class="language-bash"><code>
					list_a:  [1, 2, 3]
					list_b:  [1, 2, 3]
					list_b mutated
					list_b:  [1, 2, 3, 4]
					list_a:  [1, 2, 3]
				</code></pre>
				<p>Mutating <span class="monoText">list_b</span> does not affect <span class="monoText">list_a</span> because <span class="monoText">list_a</span> and <span class="monoText">list_b</span> point to different list objects.</p>
				<p><span class="topic">Cloning Lists.</span> We can also make copies of, or <span class="term">clone</span>, a list. When we clone a list, we create a new list, called a <span class="boldText">clone</span>, which is a copy of the original list, called the <span class="boldText">source</span>. To clone an entire list, we use the syntax <span class="monoText">list_name[:]</span>.</p>
				<pre class="language-python"><code>
					list_a = ['john', 'ali', 'sadako']
					list_b = list_a[:]

					print(list_b)
				</code></pre>
				<pre class="language-bash"><code>
					['john', 'ali', 'sadako']
				</code></pre>
				<p>A critical point with cloning is that we're creating a new list object. Modifying the clone does not modify the source:</p>
				<pre class="language-python"><code>
					list_a = ['john', 'ali', 'sadako']
					list_b = list_a[:]

					print('list_b:', list_b)

					list_b[0] = 'bing'

					print('list_b mutated')
					print('list_b:', list_b)
					print('list_a:', list_a)
				</code></pre>
				<pre class="language-bash"><code>
					list_b: ['john', 'ali', 'sadako']
					list_b mutated
					list_b: ['bing', 'ali', 'sadako']
					list_a: ['john', 'ali', 'sadako']
				</code></pre>
				<p>When we want to work some list ${a}$ but do not want to mutate ${a,}$ then cloning ${a}$ is the best approach.</p>
				<p><span class="topic">Nested Lists.</span> Nothing stops us from having lists of lists, or lists of lists of lists. Nested lists, however, are ripe for unexpected mutation. Consider the following:</p>
				<pre class="language-python"><code>
					list_a = [1, 2]
					list_b = [3]
					list_c = [list_a]

					print(list_c)
				</code></pre>
				<pre class="language-bash"><code>
					[[1, 2]]
				</code></pre>
				<p>In the above code, we assigned as an element of <span class="monoText">list_c</span> the <span class="monoText">list_a</span>, resulting in a list containing a list. Visually, the lists point as such:</p>
				<figure><img src="images/nested_lists_pointers.svg" alt="nested lists" loading="lazy" class="sixty-p"></figure>
				<p>Notice that <span class="monoText">list_c</span> points to the same object that <span class="monoText">list_a</span> points to. This means that if we modify the list inside <span class="monoText">list_c</span>, we modify <span class="monoText">list_a</span> as well, since they both point to the same object.</p>
				<pre class="language-python"><code>
					list_a = [1, 2]
					list_b = [3]
					list_c = [list_a]

					print('list_a =', list_a)
					print('list_c =', list_c)

					list_c[0].append(3)

					print('array inside list_c mutated')
					print('list_c =', list_c)
					print('list_a =', list_a)
				</code></pre>
				<pre class="language-bash"><code>
					list_a = [1, 2]
					list_c = [[1, 2]]
					array inside list_c mutated
					list_c = [[1, 2, 3]]
					list_a = [1, 2, 3]
				</code></pre>
				<p>But, as long as we do not modify the list inside <span class="monoText">list_c</span> (the list pointing to <span class="monoText">list_a</span>), we can modify <span class="monoText">list_c</span> without modifying <span class="monoText">list_a</span>:</p>
				<pre class="language-python"><code>
					list_a = [1, 2]
					list_b = [3]
					list_c = [list_a]

					print('list_a =', list_a)
					print('list_c =', list_c)

					list_c.append(list_b)

					print('list_c mutated')
					print('list_c =', list_c)
					print('list_a =', list_a)
				</code></pre>
				<pre class="language-bash"><code>
					list_a = [1, 2]
					list_c = [[1, 2]]
					list_c mutated
					list_c = [[1, 2], [3]]
					list_a = [1, 2]
				</code></pre>
				<p><span class="topic">Mutation and Iteration.</span> One thing we should avoid doing as much as possible is mutating a list as we iterate over it. This is a common source for bug infestations:</p>
				<pre class="language-python"><code>
					def remove_duplicates(list_1, list_2):
						for element in list_1:
							if element in list_2:
								list_1.remove(element)
						return list_1

					myList = ['vodka', 'wine', 'coors', 'gin']
					herList = ['vodka', 'wine', 'tequila', 'whiskey']

					final_list = remove_duplicates(myList, herList)

					print(final_list)
				</code></pre>
				<pre class="language-bash"><code>
					['wine', 'coors', 'gin']
				</code></pre>
				<p>Weird. Why is the list <span class="monoText">['wine', 'coors', 'gin']</span> when it should be <span class="monoText">['coors', 'gin']</span>? This occurs because Python uses an internal counter to keep track of the index. At each iteration, however, we're removing an element from the list, which mutates the list's length. Python does not update the counter, so the loop never actually sees the element <span class="monoText">'wine'</span> as a duplicate.</p>
				<p>A better way to write the function is to first clone the list:</p>
				<pre class="language-python"><code>
					def remove_duplicates(list_1, list_2):
						list_1_clone = list_1[:]
						for element in list_1_clone:
							if element in list_2:
								list_1.remove(element)
						return list_1

					myList = ['vodka', 'wine', 'coors', 'gin']
					herList = ['vodka', 'wine', 'tequila', 'whiskey']

					final_list = remove_duplicates(myList, herList)

					print(final_list)
					print(myList)
				</code></pre>
				<pre class="language-bash"><code>
					['coors', 'gin']
					['coors', 'gin']
				</code></pre>
				<p>Note, however, that the code above mutates <span class="monoText">myList</span>. If we want to make sure <span class="monoText">myList</span> is not mutated, we need to create a separate list object.</p>
				<pre class="language-python"><code>
					def remove_duplicates(list_1, list_2):
						list_1_no_duplicates = []
						for element in list_1:
							if element not in list_2:
								list_1_no_duplicates.append(element)
						return list_1_no_duplicates

					myList = ['vodka', 'wine', 'coors', 'gin']
					herList = ['vodka', 'wine', 'tequila', 'whiskey']

					myList_no_duplicates = remove_duplicates(myList, herList)

					print(myList_no_duplicates)
					print(myList)
				</code></pre>
				<pre class="language-bash"><code>
					['coors', 'gin']
					['vodka', 'wine', 'coors', 'gin']
				</code></pre>
				<p><span class="exh">Exercise.</span> For each of the following, specify the type and value of the last expression.</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">True</span></p>
							<p>Type: <span class="monoText">boolean</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">True</span></p>
							<p>Type: <span class="monoText">Boolean</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
							list_a
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">[0, 1, 'hello', 3, 4, 5]</span></p>
							<p>Type: <span class="monoText">List</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
							list_a
							list_b
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">[0, 1, 'hello', 3, 4, 5]</span></p>
							<p>Type: <span class="monoText">List</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
							list_a
							list_b
							list_c = [6, 5, 4, 3, 2]
							list_d = []
							for num in list_c:
								list_d.append(num)
							list_c == list_d
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">True</span></p>
							<p>Type: <span class="monoText">boolean</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
							list_a
							list_b
							list_c = [6, 5, 4, 3, 2]
							list_d = []
							for num in list_c:
								list_d.append(num)
							list_c == list_d
							list_c is list_d
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">False</span></p>
							<p>Type: <span class="monoText">boolean</span></p>
							<p>Notice the difference between the <span class="monoText">is</span> operator and the <span class="monoText">==</span> operator. The <span class="monoText">is</span> operator will check if the list names point to the same address (i.e., point to the same list object). In contrast, the <span class="monoText">==</span> operator checks if both lists have exactly the same elements.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
							list_a
							list_b
							list_c = [6, 5, 4, 3, 2]
							list_d = []
							for num in list_c:
								list_d.append(num)
							list_c == list_d
							list_c is list_d
							list_c[2] = 20
							list_c
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">[6, 5, 20, 3, 2]</span></p>
							<p>Type: <span class="monoText">List</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							list_a = [0, 1, 2, 3, 4, 5]
							list_b = list_a
							list_a[2] = 'hello'
							list_a == list_b
							list_a is list_b
							list_a
							list_b
							list_c = [6, 5, 4, 3, 2]
							list_d = []
							for num in list_c:
								list_d.append(num)
							list_c == list_d
							list_c is list_d
							list_c[2] = 20
							list_c
							list_d
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Value: <span class="monoText">[6, 5, 4, 3, 2]</span></p>
							<p>Type: <span class="monoText">List</span></p>
						</details>
					</li>
				</ol>
			</section>

			<section id="functions_as_objects" class="grid-item">
				<h4>Functions as Objects</h4>
				<p>Recall that nearly everything in Python is an object. Functions fall under this general rule, and we can treat them as objects.</p>
				<p>In programming languages, functions are <span class="term">first class objects</span>. First class objects are objects that: (1) have a type; (2) can be elements of data structures; and (3) can appear inside expressions (i.e., they can be assigned or be passed as arguments to functions). Because functions have all three of these properties, we can often use functions in the same way we would use literals like numbers or strings, and in the same way we would use data structures like tuples and lists.</p>
				<p>Given that functions can be treated as discrete data objects, we can store them inside lists, and perform operation on that list or pass the list itself as an argument. Doing so is an example of <span class="term">higher order programming. For example:</span></p>
				<pre class="language-python"><code>
					def applyToEach(aList, func):
						'''
						inputs:
							aList, a list
							func, a function
						
						computation:
							replace each element of aList with func(element)
							
						output:
							mutated aList -- each element now func(element)
						'''

						for element in range(len(aList)): 
							aList[element] = func(aList[element])
				</code></pre>
				<p>The function above takes two arguments, (1) a list with elements, and (2) a function to apply. The function mutates the list argument by replacing each of its elements with the output of the function execution with the element passed as an argument. Let's apply this function:</p>
				<pre class="language-python"><code>
					def applyToEach(aList, func):
						for element in range(len(aList)): 
							aList[element] = func(aList[element])

					def fibonacci(n):
						if n == 0 or n == 1:
							return 1
						else:
							return fibonacci(n - 1) + fibonacci(n - 2)

					def factorial(n):
						if n == 1:
							return 1
						else:
							return n * factorial(n - 1)

					numList = [1, -2, 3.14] 

					applyToEach(numList, abs)
					print(numList)

					applyToEach(numList, int)
					print(numList)

					applyToEach(numList, factorial)
					print(numList)

					applyToEach(numList, fibonacci)
					print(numList)
				</code></pre>
				<pre class="language-bash"><code>
					[1, 2, 3.14]
					[1, 2, 3]
					[1, 2, 6]
					[1, 2, 13]
				</code></pre>
				<p>In the code above, we mutated the list several times by applying to each element in the list a function we passed as an argument. We can also perform the operation in the opposite direction:</p>
				<pre class="language-python"><code>
					def applyToEach(funcList, x):
						for func in funcList: 
							print(func(x))

					def fibonacci(n):
						if n == 0 or n == 1:
							return 1
						else:
							return fibonacci(n - 1) + fibonacci(n - 2)

					def factorial(n):
						if n == 1:
							return 1
						else:
							return n * factorial(n - 1)
					
					funcList = [abs, int, factorial, fibonacci]
					applyToEach(funcList, 5)
				</code></pre>
				<pre class="language-bash"><code>
					5
					5
					120
					8
				</code></pre>
				<p>Here, we applied a list of functions to a particular number. The <span class="monoText">applyToEach</span> function we wrote is an example of a <span class="term">higher order procedure</span> (&#8220;HOP&#8221;). HOPs are so common in programming that Python provides a general purpose HOP called <span class="monoText">map</span>.</p>
				<p>In its simplest form, a <span class="monoText">map</span> consists of a <span class="term">unary function</span> and a collection of suitable arguments. The simplest use follows the syntax:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						map(unary_function, arguments)
					</code></pre>
				</figure>
				<p>For example, if we wanted to apply the <span class="monoText">abs</span> function to a list, we can use <span class="monoText">map</span>. <span class="monoText">map</span> returns a <span class="italicsText">map object</span>, an iterable data object:</p>
				<pre class="language-python"><code>
					aList = [1, -2, -5, -7]
					aList_all_positive = []
					for element in map(abs, aList):
						aList_all_positive.append(element)

					print(aList)
					print(aList_all_positive)
				</code></pre>
				<pre class="language-bash"><code>
					[1, -2, -5, -7]
					[1, 2, 5, 7]
				</code></pre>
				<p>To repeat, the return from <span class="monoText">map</span> is a map object:</p>
				<pre class="language-python"><code>
					aList = [1, -2, -5, -7]
					aList_map = map(abs, aList)

					print(aList_map)
				</code></pre>
				<pre class="language-bash"><code>
					&lt;map object at 0x7fb65a3c2ca0&gt;
				</code></pre>
				<p>To actually use the object's elements, we must iterate through the object. We can also use <span class="monoText">map</span> in a more general form:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						map(n-ary_function, argument_1, argument_2, ... , argument_n)
					</code></pre>
				</figure>
				<p>In its general form, we can pass a <span class="term">${n-\text{ary}}$ function</span> &mdash; a function that takes multiple arguments, and provide the arguments thereafter. For example, suppose we have two lists, and we want to obtain a new list with the smallest element at a particular index:</p>
				<pre class="language-python"><code>
					list_a = [9, 117, 10, 15, 2]
					list_b = [12, 109, 98, 72, 23]
					min_element_per_index = []
					
					for element in map(min, list_a, list_b):
						min_element_per_index.append(element)
					
					print(min_element_per_index)
				</code></pre>
				<pre class="language-bash"><code>
					[9, 109, 10, 15, 2]
				</code></pre>
				<p><span class="exh">Exercise.</span> Consider the following list and <span class="monoText">applyToEach</span> function:</p>
				<pre class="language-python"><code>
					L = [1, -4, 8, -9]

					def applyToEach(L, f):
						for i in range(len(L)):
							L[i] = f(L[i])
				</code></pre>
				<p>With the above list and function, write expressions that generate the output:</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							print(L)
						</code></pre>
						<pre class="language-bash"><code>
							[1, 4, 8, 9]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<pre class="language-python"><code>
								L = [1, -4, 8, -9]
		
								def applyToEach(L, f):
									for i in range(len(L)):
										L[i] = f(L[i])
								
								applyToEach(L, abs)
								print(L)
							</code></pre>
							<pre class="language-bash"><code>
								[1, 4, 8, 9]
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(L)
						</code></pre>
						<pre class="language-bash"><code>
							[2, -3, 9, -8]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<pre class="language-python"><code>
								L = [1, -4, 8, -9]
		
								def applyToEach(L, f):
									for i in range(len(L)):
										L[i] = f(L[i])
								
								def increment(num):
									return num + 1
								
								applyToEach(L, increment)
								print(L)
							</code></pre>
							<pre class="language-bash"><code>
								[2, -3, 9, -8]
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(L)
						</code></pre>
						<pre class="language-bash"><code>
							[1, 16, 64, 81]
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<pre class="language-python"><code>
								L = [1, -4, 8, -9]
		
								def applyToEach(L, f):
									for i in range(len(L)):
										L[i] = f(L[i])
								
								def square(num):
									return num * num
								
								applyToEach(L, square)
								print(L)
							</code></pre>
							<pre class="language-bash"><code>
								[1, 16, 64, 81]
							</code></pre>
						</details>
					</li>
				</ol>
				<p><span class="exh">Exercise.</span> Consider the following functions:</p>
				<pre class="language-python"><code>
					def applyEachTo(L, x):
						result = []
						for i in range(len(L)):
							result.append(L[i](x))
						return result
					def square(a):
						return a*a
					def halve(a):
						return a/2
					def inc(a):
						return a+1
				</code></pre>
				<p>For each of the expressions below, what value and value's type?</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							applyEachTo([inc, square, halve, abs], -3)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">[-2, 9, -1.5, 3]</span></p>
							<p>Type: <span class="monoText">list</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							applyEachTo([inc, square, halve, abs], 3.0)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: <span class="monoText">[4.0, 9.0, 1.5, 3.0]</span></p>
							<p>Type: <span class="monoText">list</span></p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							applyEachTo([inc, max, int], -3)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Output: error</p>
							<p>Type: NoneType</p>
						</details>
					</li>
				</ol>
			</section>

			<section id="python_dictionaries" class="grid-item">
				<h4>Dictionaries</h4>
				<p>Comparing the data structures we've seen thus far:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>Type</th>
							<th>Element Type</th>
							<th>Example Literal</th>
							<th>Mutable?</th>
						</thead>
						<tbody>
							<tr>
								<td>str</td>
								<td>character</td>
								<td>'hello'</td>
								<td>no</td>
							</tr>
							<tr>
								<td>tuple</td>
								<td>any type</td>
								<td>(1, 2, 'abc', 4)</td>
								<td>no</td>
							</tr>
							<tr>
								<td>range</td>
								<td>int</td>
								<td>range(2, 10, 2)</td>
								<td>no</td>
							</tr>
							<tr>
								<td>list</td>
								<td>any type</td>
								<td>[1, 2, 'a', 3, [0, 1]]</td>
								<td>yes</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>With strings, tuples, lists, and ranges, we have the following operations:</p>
				<div class="compare">
					<ul>
						<li><span class="blueText monoText">sequence[${i}$]</span> - return the element inside the data structure at index ${i.}$</li>
						<li><span class="blueText monoText">len(sequence)</span> - return the data structure's length</li>
						<li><span class="blueText monoText">sequenceA + sequenceB</span> - concatenate multiple data structures (does not apply to ranges)</li>
						<li><span class="blueText monoText">${n}$ * sequence</span> - repeat the sequence ${n}$ times (does not apply to ranges)</li>
					</ul>
					<ul>
						<li><span class="blueText monoText">sequence[start:end]</span> - return a portion of the data structure</li>
						<li><span class="blueText monoText">${e}$ in sequence</span> - return whether a particular element ${e}$ is inside the data structure</li>
						<li><span class="blueText monoText">${e}$ not in sequence</span> - return whether a particular element ${e}$ is not inside the data structure</li>
						<li><span class="blueText monoText">for ${e}$ in sequence</span> - iterate over the elements in the sequence</li>
					</ul>
				</div>
				<p>The beauty in these operations rests on the fact they abstract away the technical details underlying their implementations. We can concatenate, obtain length, or perform the operations above without having to worry about whether we are applying them to strings, tuples, or lists. Considering these feature, we explore another data structure &mdash; dictionaries.</p>
				<p>Suppose we have different students with different grades for different courses. With only the data structures we have so far, we might store the data as such:</p>
				<pre class="language-python"><code>
					student_names = ['James', 'Roberto', 'Ahmed', 'Ivan']
					grades = ['B', 'B', 'B', 'A']
					course = ['physics', 'chemistry', 'calculus', 'biology']
				</code></pre>
				<p>The data is stored with separate lists, all of which have the same length to ensure they match each of the students. The problem with this approach: It is very messy to work with. We must index to separate lists to retrieve relevant data. A dictionary directly solves this problem.</p>
				<figure>
					<img src="images/list_v_dictionary.svg" alt="list v dictionary" loading="lazy" class="fifty-p">
					<figcaption>List versus dictionary, where: ${i}$ is the index; ${e}$ is an element, ${k}$ is a key; and ${v}$ is a value.</figcaption>
				</figure>
				<p>With dictionaries, we can index to an <span class="term">item</span> in the dictionary directly (and the index need not be an integer). Because dictionaries are just one data structure, we do not have to use separate lists.</p>
				<p>In a list, we have a sequence of elements, where each element has an index starting at 0. Similar to a list, a dictionary is a collection of elements. But, rather than using strictly integers for indices, we create a custom index, called a <span class="term">key</span> for a particular element.</p>
				<p>Examining the data structure, we can see why the dictionary data structure is called a dictionary &mdash; like a dictionary, we can reference a word (the key), and retrieve all of the information associated with key (the element(s)). In the diagram above, the dictionary is purposefully drawn differently from the list, to represent the fact that dictionaries are not necessarily ordered the way lists are. We might order the keys a particular way, but the dictionary data structure itself is not inherently ordered the way lists are inherently ordered by index.</p>
				<p>In Python, the items stored in a dictionary are called <span class="term">key-value pairs</span> &mdash; a dictionary item consists of a key and its associated value. To demonstrate, consider the multiple lists we had above. Representing the collection as a dictionary:</p>
				<pre class="language-python"><code>
					grades = {'James':'B', 'Roberto':'B', 'Ahmed':'B', 'Ivan':'A'} 
				</code></pre>
				<p>From the example, we can see that dictionaries are initialized with curly braces <span class="monoText">{}</span>:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						dictionary_name = {key_name1:data_value1, ...}
					</code></pre>
				</figure>
				<p>With dictionaries, we can access the value associated with a particular key with square bracket notation:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					print(number_of_crates['apple'])
					print(number_of_crates['grape'])
					print(number_of_crates['kiwi'])
				</code></pre>
				<pre class="language-bash"><code>
					4
					9
					7
				</code></pre>
				<p>If we use a key not inside the dictionary, we get back a <span class="monoText">KeyError</span>:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					print(number_of_crates['strawberry'])
				</code></pre>
				<pre class="language-bash"><code>
					KeyError: 'strawberry'
				</code></pre>
				<p>We can fix this by adding an entry to the dictionary:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					number_of_crates['strawberry'] = 6

					print(number_of_crates['strawberry'])
				</code></pre>
				<pre class="language-bash"><code>
					6
				</code></pre>
				<p>The fact that we can add entries to an existing dictionary tells us that dictionaries are mutable &mdash; we can modify them after they are initialized.</p>
				<p>We can also test if a particular key is in the dictionary:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}
					number_of_crates['strawberry'] = 6

					haveApples = 'apple' in number_of_crates  
					haveMangos = 'mango' in number_of_crates

					print(haveApples)
					print(haveMangos)
				</code></pre>
				<pre class="language-bash"><code>
					True
					False
				</code></pre>
				<p>We can also remove entries:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					del(number_of_crates['apple'])

					haveApples = 'apple' in number_of_crates  

					print(haveApples)
				</code></pre>
				<pre class="language-bash"><code>
					False
				</code></pre>
				<p>Suppose we want a set of all the keys in the dictionary:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					available_fruits = number_of_crates.keys()

					print(available_fruits)
				</code></pre>
				<pre class="language-bash"><code>
					dict_keys(['apple', 'grade', 'kiwi'])
				</code></pre>
				<p>Notice that the output is an iterable. If we want to put all of the keys into a separate list:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					available_fruits = []

					for fruit in number_of_crates.keys():
						available_fruits.append(fruit)

					print(available_fruits)
				</code></pre>
				<pre class="language-bash"><code>
					['apple', 'grape', 'kiwi']
				</code></pre>
				<p>We can also obtain a set of all the values inside the dictionary:</p>
				<pre class="language-python"><code>
					number_of_crates = {'apple': 4, 'grape': 9, 'kiwi': 7}

					total_crates = 0

					for crates in number_of_crates.values():
						total_crates += crates
					
					print(total_crates)
				</code></pre>
				<pre class="language-bash"><code>
					20
				</code></pre>
				<p>A key point with dictionaries is that they do not have a particular order. This means whenever we use dictionaries, we can never rely on the entries being ordered.</p>
				<p>Dictionary values can be any data type &mdash; immutable or mutable. This means dictionaries can store tuples, lists, or even other dictionaries as values.</p>
				<p>The limitations apply to keys: The keys <span class="underlineText">must be unique</span>. We cannot have duplicate keys (but, we can have duplicate values). Keys must also be an immutable type &mdash; <span class="monoText">int, float, string, tuple, bool</span> (but, we need to be careful with using a <span class="monoText">float</span> as a key; recall there are accuracy issues, so we may not find what we're looking for). More technically, keys must be <span class="term">hashable</span>. We meet this requirement by ensuring our keys are immutable types.</p>
				<p>Comparing lists and dictionaries:</p>
				<div class="compare">
					<div>
						<p class="subheading">Lists</p>
						<ul>
							<li>an <span class="italicsText">ordered</span> sequence of elements</li>
							<li>we access elements by referencing an integer index</li>
							<li>indices have an order</li>
							<li>index is an <span class="monoText">int</span></li>
						</ul>
					</div>
					<div>
						<p class="subheading">Dictionaries</p>
						<ul>
							<li>matches <span class="italicsText">keys</span> to <span class="italicsText">values</span> (key-value pairs)</li>
							<li>we access elements by referencing either the key or the value</li>
							<li>inherently no order</li>
							<li>key can be <span class="italicsText">any</span> immutable type</li>
						</ul>
					</div>
				</div>
				<p><span class="exh">Exercise.</span> Suppose the following expressions:</p>
				<pre class="language-python"><code>
					animals = {'a': 'aardvark', 'b': 'baboon', 'c': 'coati'}
					animals['d'] = 'donkey'
				</code></pre>
				<p>For the expressions below, what printed to the console? Assume that the expressions occur one after another.</p>
				<ol>
					<li>
						<pre class="language-python"><code>
							print(animals)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This will return the dictionary:</p>
							<pre class="language-bash"><code>
								{'a': 'aardvark', 'b': 'baboon', 'c': 'coati', 'd': 'donkey'}
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(animals['c'])
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This will return the value paired with the key <span class="monoText">'c'</span>:</p>
							<pre class="language-bash"><code>
								coati
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(animals['donkey'])
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This will return an <span class="monoText">error</span>. The data object <span class="monoText">'donkey'</span> is a value, not a key.</p>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(len(animals))
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This returns <span class="monoText">4</span> &mdash; there are <span class="monoText">4</span> items (key-value pairs) in the dictionary.</p>
							<pre class="language-bash"><code>
								4
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							animals['a'] = 'anteater'
							print(animals['a'])
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This replaces the value paired with the key <span class="monoText">'a'</span> from <span class="monoText">'aardvark'</span> to <span class="monoText">'anteater'</span>:</p>
							<pre class="language-bash"><code>
								'anteater'
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(len(animals['a']))
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>The value stored in <span class="monoText">'a'</span> is a string, <span class="monoText">'anteater'</span>, which has a length of <span class="monoText">8</span>:</p>
							<pre class="language-bash"><code>
								8
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print('baboon' in animals)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This returns <span class="monoText">False</span> because the operator <span class="monoText">in</span> checks for whether a key, not a value, is in a dictionary:</p>
							<pre class="language-bash"><code>
								False
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print('donkey' in animals.values())
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This returns <span class="monoText">True</span> because now we're checking if <span class="monoText">'donkey'</span> is among the values.</p>
							<pre class="language-bash"><code>
								True
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print('b' in animals)
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This returns <span class="monoText">True</span> because the key <span class="monoText">'b'</span> is in the dictionary.</p>
							<pre class="language-bash"><code>
								True
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(animals.keys())
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This will return an iterable object of the dictionary's keys:</p>
							<pre class="language-bash"><code>
								dict_keys(['a', 'b', 'c', 'd'])
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							del animals['b']
							print(len(animals))
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This deletes one of the keys along with its paired value, so the length is now three:</p>
							<pre class="language-bash"><code>
								3
							</code></pre>
						</details>
					</li>
					<li>
						<pre class="language-python"><code>
							print(animals.value())
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>This returns an iterable object of the dictionary's values:</p>
							<pre class="language-bash"><code>
								dict_values(['anteater', 'coati', 'donkey'])
							</code></pre>
						</details>
					</li>
				</ol>
				
			</section>

			<section id="dictionary_applications" class="grid-item">
				<h4>Using Dictionaries</h4>
				<p>With dictionaries, we can begin writing even more sophisticated programs. In this section, we explore some applications of dictionaries, which in turn will evidence just how powerful they are.</p>
				<p><span class="topic">Data Occurrence Data.</span> A common problem in peruasive writing is using words too many times &mdash; the most common perpetrators: that, of, very, was, has, etc. Let's write a program that takes a string, and outputs the most common words in that string.</p>
				<p>First, we want to create a frequency dictionary, which maps every instance of a string to an integer. We're going to want to iterate through our text, so we should also write a function that converts our text into a list:</p>
				<pre class="language-python"><code>
					def text_to_array(text):
						punctuation = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
						text = text.lower()
						for letter in text:
							if letter in punctuation:
								text = text.replace(letter, '')
						arr_text = text.split(' ') 
						return arr_text
						
					def verbose (text):
						myDict = {}
						text_array = text_to_array(text)
						for word in text_array:
							if word in myDict:
								myDict[word] += 1
							else:
								myDict[word] = 1
						return myDict
					
					sample = input("Enter text for verbosity analysis: ")
					print(verbose(sample))
				</code></pre>
				<p>Let's test if this works. Here's a sentence from a criminal trial brief:</p>
				<pre class="language-bash"><code>
					Enter text for verbosity analysis: This statement ignores the fact that the response was made on that date and before this response was recorded.

					{
						'this': 2, 
						'statement': 1, 
						'ignores': 1, 
						'the': 2, 
						'fact': 1, 
						'that': 2, 
						'response': 2, 
						'was': 2, 
						'made': 1, 
						'on': 1, 
						'date': 1, 
						'and': 1, 
						'before': 1, 
						'recorded': 1
					}
				</code></pre>
				<p>Success. This dictionary, however, is somewhat hard to parse. Let's write another function that gives us the most common words, along with how many times they occur:</p>
				<pre class="language-python"><code>
					def text_to_array(text):
						punctuation = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
						text = text.lower()
						for letter in text:
							if letter in punctuation:
								text = text.replace(letter, '')
						arr_text = text.split(' ') 
						return arr_text
						
					def verbose (text):
						myDict = {}
						text_array = text_to_array(text)
						for word in text_array:
							if word in myDict:
								myDict[word] += 1
							else:
								myDict[word] = 1
						return myDict
					
					def most_common_words(frequencies):
						values = frequencies.values()
						best = max(values)
						common_words = []
						for word in frequencies:
							if frequencies[word] == best:
								common_words.append(word)
						return (common_words, best)
					
					sample = input("Enter text for verbosity analysis: ")

					verbose_analysis = verbose(sample)

					common_words = most_common_words(verbose_analysis)

					print(f'The most common words are {common_words[0]} occuring {common_words[1]} times each.')
				</code></pre>
				<pre class="language-bash"><code>
					Enter text for verbosity analysis: This statement ignores the fact that the response was made on that date and before this response was recorded.

					The most common words are: 
						['this', 'the', 'that', 'response', 'was'] 
					occuring 2 times each.
				</code></pre>
				<p>Woe is the power of dictionaries.</p>
				<p><span class="exh">Exercise.</span> Consider the following expressions:</p>
				<pre class="language-python"><code>
					animals = {'a': ['aardvark'], 'b':['baboon'], 'c':['coati']}
					animals['d'] = ['donkey']
					animals['d'].append('dog')
					animals['d'].append('dingo')
				</code></pre>
				<p>Write a function called <span class="monoText">how_many</span> that returns the sum of the number of values associated with a dictionary.</p>
				<details class="answer">
					<summary>Solution</summary>
					<p>Here is one possible implementation:</p>
					<pre class="language-python"><code>
						animals = {'a': ['aardvark'], 'b':['baboon'], 'c':['coati']}
						animals['d'] = ['donkey']
						animals['d'].append('dog')
						animals['d'].append('dingo')

						def how_many(aDict):
							num_values = 0
							dict_values = aDict.values()
							for val in dict_values:
								num_values += len(val)
							return num_values
						
						test = how_many(animals)
						print(test)
					</code></pre>
					<pre class="language-bash"><code>
						6
					</code></pre>
				</details>
				<p><span class="exh">Exercise.</span> Consider the following expressions:</p>
				<pre class="language-python"><code>
					animals = {'a': ['aardvark'], 'b':['baboon'], 'c':['coati']}
					animals['d'] = ['donkey']
					animals['d'].append('dog')
					animals['d'].append('dingo')
				</code></pre>
				<p>Write a prograum that the returns the key corresponding to the entry with the largest number of values paired. If there is more than one such entry, erturn any one of the matching keys.</p>
				<details class="answer">
					<summary>Solution</summary>
					<p>Here is one possible implementation:</p>
					<pre class="language-python"><code>
						animals = {'a': ['aardvark'], 'b':['baboon'], 'c':['coati']}
						animals['d'] = ['donkey']
						animals['d'].append('dog')
						animals['d'].append('dingo')

						def biggest(aDict):
							lengths = []
							longest_entries = []
							for kee in aDict:
								lengths.append(len(aDict[kee]))
							longest = max(lengths)
							for kee in aDict:
								if len(aDict[kee]) == longest:
									longest_entries.append(kee)
							return longest_entries
						
						test = biggest(animals)
						print(test)
					</code></pre>
					<pre class="language-bash"><code>
						['d']
					</code></pre>
				</details>
				<p><span class="topic">The Fibonacci Sequence and Dictionaries.</span> Recall the recursive function we wrote for the Fibonacci sequence. We had two base cases, and the function calls itself twice:</p>
				<pre class="language-python"><code>
					def fibonacci(n):
						if n == 1:
							return 1
						elif n == 2:
							return 2
						else:
							return fibonacci(n-1) + fibonacci(n-2)
				</code></pre>
				<p>The problem with the code above? It's inefficient. Suppose we compute <span class="monoText">fibonacci(5)</span>. The expression <span class="monoText">fibonacci(5)</span> evaluates to <span class="monoText">fibonacci(4)</span>, which evaluates to <span class="monoText">fibonacci(3)</span>, which evaluates to <span class="monoText">fibonacci(2)</span> and <span class="monoText">fibonacci(1)</span> (our base cases). Having obtained <span class="monoText">fibonacci(3)</span>, <span class="monoText">fibonacci(4)</span> receives <span class="monoText">fibonacci(2)</span>, a base case, and <span class="monoText">fibonacci(5)</span> receives <span class="monoText">fibonacci(3)</span>, which evaluates to <span class="monoText">fibonacci(2)</span> and <span class="monoText">fibonacci(1)</span>, the base cases.</p>
				<figure><img src="images/fibonacci_tree.svg" alt="fibonacci tree" loading="lazy" class="eighty-p"></figure>
				<p>Why is this computation inefficient? Because we keep computing <span class="monoText">fibonacci(2)</span> and <span class="monoText">fibonacci(1)</span>, our base cases, over and over again. From the tree above, we can see that the computations are done 5 separate times. This inefficiency may not seem like much for small computations like <span class="monoText">fibonacci(5)</span>, but it is substantial and noticeable for very large numbers.</p>
				<p>We can improve this program's efficiency with dictionaries. Instead of computing the base cases repeatedly, we can use a dictionary to keep track of calculated values:</p>
				<pre class="language-python"><code>
					def fib(num, fib_dict):
						if num in fib_dict:
							return fib_dict[num]
						else:
							result = fib(num - 1, fib_dict) + fib(num - 2, fib_dict)
							fib_dict[num] = result
							return result

					d = {1:1, 2:2}

					# test:
					print(fib(5, d))
				</code></pre>
				<pre class="language-bash"><code>
					8
				</code></pre>
				<p>In the code above, we continue to compute recursively, but instead of including just one parameter, we have two: the number we want to compute the Fibonacci for, and a dictionary. Inside the function, we compute as we normally would, but with the additional step of storing the result in the dictionary argument. If we've already done the computation, then Python will simply use the result stored in the dictionary rather than performing the computation again.</p>
				<p>In computer science, this process is called <span class="term">memoization</span> &mdash; we create a &#8220;memo&#8221; in order to recall what we've already done.</p>
				<p><span class="topic">The <span class="monoText">global</span> Symbol.</span> Let's compare using memoization and without using memoization. To do so, we will use the <span class="monoText">global</span> symbol, a symbol that warrants a brief and important warning.</p>
				<p>In many of our programs so far, we've been using <span class="term">global variables</span>. Global variables, by and large, are frowned upon in practice. This is because they are dangerous &mdash; they effectively break the scoping of variables by function call, and they leave for side effects changing variable values in ways that affect other computations. They are, however, a convenient way to keep track of information inside a function.</p>
				<p>Another way to declare global variables is with the symbol <span class="monoText">global</span>. Recall: variables inside a function are only visible inside that function. When append the symbol <span class="monoText">global</span>, we effectively break that rule, and the variables prefaced with <span class="monoText">global</span> become visible outside. Again, this is very dangerous.</p>
				<p>In the previous example, we used a module called <span class="monoText">time</span> to compare how long it took for each program to run. Let's instead use a global variable to determine how many times the Fibonacci functions are called.</p>
				<p>Let's compare the function call for a number argument of 35. Without using memoization, the recursive function is called 29,860,703 times:</p>
				<pre class="language-python"><code>
					def fibonacci(n):
						global numFibCalls
						numFibCalls += 1
						if n == 0 or n == 1:
							return 1
						else:
							return fibonacci(n - 1) + fibonacci(n - 2)

					numFibCalls = 0

					print(fibonacci(35))
					print(f'Number of calls: {numFibCalls}')
				</code></pre>
				<pre class="language-bash"><code>
					14930352
					Number of calls: 29860703
				</code></pre>
				<p>Using memoization, the recursive function is called 67 times:</p>
				<pre class="language-python"><code>
					def fib(num, fib_dict):
						global numFibCalls
						numFibCalls += 1
						if num in fib_dict:
							return fib_dict[num]
						else:
							result = fib(num - 1, fib_dict) + fib(num - 2, fib_dict)
							fib_dict[num] = result
							return result

					d = {1:1, 2:2}

					numFibCalls = 0

					print(fib(35, d))
					print(f'Number of calls: {numFibCalls}')
				</code></pre>
				<pre class="language-bash"><code>
					14930352
					Number of calls: 67
				</code></pre>
				<p>29,860,703 calls versus 67 calls. The difference in efficiency should be apparent.</p>
			</section>

			<section id="testing_and_debugging" class="grid-item">
				<h3>Testing and Debugging</h3>
				<p>Programs rarely ever run perfectly on first attempt; bugs are a part of the programming experience. Their pervasiveness, however, has led to numerous techniques and tactics of dealing with them, i.e., <span class="term">debugging</span>. In fact, there are so many approaches that there are entire courses dedicated to testing and debugging. In the next few sections, we cover some of those approaches from a Python perspective.</p>
				<p>Testing and debugging can be conceptualized by analogy: Suppose we are making a soup, but bugs keep descending from the ceiling, landing perfectly in our pot. Now, assuming we have no palette for insectoids, how might we prevent these unwanted ingredients?</p>
				<p>One way is to simply carry on making the soup, checking the soup for bugs as we go. Another way is to make sure the lid is closed. Or, we could simply evade the entire problem by cleaning our kitchen before we begin making the soup. Each of these three approaches corresponds to testing and debugging.</p>
				<p><span class="topic">Testing and Validation.</span> Checking the soup for bugs is akin to <span class="term">testing</span>. Here, we put our code through various tests that reveal bugs. Here, we resolve (or pick out) the bugs as they appear. The first step to testing is asking: How do I break my program? Assuming we defensively programmed right from the get-go (which we should have done), we can come up with ways of breaking our program by checking the our comments and function specifications.</p>
				<p><span class="topic">Defensive Programming.</span> Ensuring the lid is closed is akin to <span class="term">defensive programming</span>. With defensive programming, we write our code according to a plan that anticipates and prevents, or at least detects, bugs. To defensively program, we want to make sure we write specifications for functions. We also want to modularize our programs. This is such an important point. We do not want to write massive functions; break. it. up. This prevents possibilities of cross-contamination. At every piece of code taking inputs and returning outputs, we ought to check conditions on inputs and outputs.</p>
				<p><span class="topic">Debugging.</span> Cleaning the kitchen is akin to <span class="term">debugging</span> &mdash; eliminate the root source. In debugging, we go right to where all the bugs are coming from. While this obviously solves the problem full stop, it is easier said than done. Of the three approaches, debugging is generally the most difficult, particularly with gargantuan programs. Our first approach to debugging should be to examine the events leading up to the error. What are the causes and the effects? The necessary and sufficient conditions?</p>
			</section>

			<section id="classes_of_tests" class="grid-item">
				<h4>Classes of Tests</h4>
				<p>Testing and debugging is several magnitudes easier when we plan effectively before coding. From the very beginning, we need to ensure that our program easily supports testing and debugging. This is done in two ways: (1) by decomposing our program into smaller, separate modules; and (2) clear documentation.</p>
				<p>Testing and debugging is a nightmare with gargantuan programs. Programs can easily increase to over a thousand lines, and with every increase, the more difficult it is to find problems. By breaking the program into smaller pieces, it is much much easier to pinpoint where problems are.</p>
				<p>However, even the most modular programs can yield little to no aid if they are undocumented or unclearly documented. Indeed, an oft-repeated sentiment among programmers embarking on large open source projects is lack of documentation. Every program module should document two things: (a) The module's constraints. What do we expect the input to be? What do we expect the output to be? And (b), the module's assumptions. What are we assuming is true for the module's computation? What are we assuming is false? Does the module depend on another module? These are all questions that should be answered in documentation.</p>
				<p>With documentation, always err on the side of over-documenting rather than hand-waiving. What might seem obvious at the moment is not guaranteed to be obvious a month, six months, or two years later. And it is almost certainly not guaranteed to be obvious for those reading our code at first glance. Document everything.</p>
				<div class="rule">
					<p><span class="topic">Proposition.</span> Let ${x}$ be documentation, ${n}$ be the person who wrote ${x,}$ and ${m}$ be the person who reads ${x}$ in the future. There exists an ${m}$ such that ${m}$ has: gone mad, equipped himself with an axe, and learned where ${x}$ and his or her family live.</p>
				</div>
				<p><span class="topic">Prerequisites for Testing.</span> Before we even begin testing, there are two things we must do. First, we should be certain that our code actually runs. This weeds out some of the superficial problems we might have &mdash; syntax errors, static semantic errors, out of bound errors, undefined errors, things that the interpreter will catch quickly.</p>
				<p>Second, we should come up with a set of expected results. Here, we think of a typical input set, and pass them into the program. Before we actually pass them, however, we should know what to expect. For each input in the set, we record, whether by pen and paper or key and screen, what we expect to see. Only then do we pass the inputs into program. Once we have these two prerequisites done, we can begin thinking about what <span class="italicsText">classes of tests</span> to run.</p>
				<p><span class="topic">Unit Testing.</span> In <span class="italicsText">unit testing</span>, we validate each piece of the program, testing each module and function separately, one by one.</p>
				<p><span class="topic">Regression Testing.</span> Once we've done unit testing, we should do a <span class="italicsText">regression test</span>. Often, while we unit test, we end up encountering bugs. We might then immediately respond and squash the bug with a patch. But, in doing so, we might have introduced new bugs or reintroduce errors that were previously patched. With <span class="italicsText">regression testing</span>, at every patch, we go back to where we started and conduct tests again.</p>
				<p><span class="topic">Integration Testing.</span> Once we've done unit and regression tests, we begin <span class="italicsText">itegration testing</span>. Here, we answer the question: Does the overall program work? To answer that question, we test the connections between each of the modules. Are inputs and outputs flowing properly? Are modules receiving the inputs they need? This is the very last stage, and we do not go anywhere near here unless we've done unit tests followed by regression tests.</p>
			</section>

			<section id="testing_approaches" class="grid-item">
				<h4>Testing Approaches</h4>
				<p>With the classes in mind, we now discuss the different ways to test. The approaches below are the most common approaches, but there are numerous other techniques and tactics.</p>
				<p><span class="topic">Intuition.</span> The most straight-foward testing approach is using intuition. Most problems will have natural boundaries. When we solve such a problem with a procedure, that procedure will have natural partitions. It is those partitions that we want to test. For example, consider this docstring for some function:</p>
				<pre class="language-python"><code>
					'''
					Assumptions:
						x is an int
						y is an int
					Returns: 
						If y is less than x, True
						Otherwise, False
					'''
				</code></pre>
				<p>What are some natural partitions for this function? Well, what if <span class="monoText">x</span> and <span class="monoText">y</span> are data types other than <span class="monoText">int</span>? What if <span class="monoText">y</span> is greater than <span class="monoText">x</span>? What if <span class="monoText">y</span> is equal to <span class="monoText">x</span>? What if <span class="monoText">x</span> and <span class="monoText">y</span> are both negative?</p>
				<p><span class="topic">Random Testing.</span> Sometimes, however, there are no natural boundaries. In those instances, we might do <span class="italicsText">random testing</span>, where we pass in random inputs. Think of this as akin to throwing whatever we can find against a wall and seeing whether the wall holds up. The probability of the wall being strong increases with more tests. But, there are better approaches.</p>
				<p><span class="topic">Black Box Testing.</span> With <span class="italicsText">black box testing</span>, we explore <span class="underlineText">possible</span> paths through specification. An example should clarify the vagueness. Consider the following procedure:</p>
				<pre class="language-python"><code>
					def sqrt(x, epsilon):
						'''
						Assumptions:
							x is a float
							epsilon is a float
							x >= 0
							epsilon > 0

						Returns:
							[result] such that:
								x-epsilon <= result * result <= x + epsilon
						'''
				</code></pre>
				<p>With blackbox testing, we never actually look at the code for this function. All we do is look at the specification (the docstring). This is a particularly useful testing approach because it allows for someone other than the implementer to conduct the test, thereby avoiding implicit biases.</p>
				<p>From the specification, we think of all the possible test cases for the function (again, without looking at the code). For example, if we have a procedure that operates on a list, we want to test boundary conditions &mdash; pass empty lists, singleton lists, very large lists, lists containing other data structures, into the procedure. If we have function that deals with numbers, we want to pass 0, very small numbers, and very large numbers. In the function above, here are some possible cases to check:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>case</th>
							<th><span class="monoText">x</span></th>
							<th><span class="monoText">epsilon</span></th>
						</thead>
						<tbody>
							<tr>
								<td>boundary</td>
								<td>0</td>
								<td>0.0001</td>
							</tr>
							<tr>
								<td>perfect square</td>
								<td>25</td>
								<td>0.0001</td>
							</tr>
							<tr>
								<td>less than 1</td>
								<td>0.05</td>
								<td>0.0001</td>
							</tr>
							<tr>
								<td>irrational</td>
								<td>2</td>
								<td>0.0001</td>
							</tr>
							<tr>
								<td>extremes</td>
								<td>2</td>
								<td>1.0/2.0 ** 64.0</td>
							</tr>
							<tr>
								<td>extremes</td>
								<td>2.0 ** 64.0</td>
								<td>1.0/2.0 ** 64.0</td>
							</tr>
							<tr>
								<td>extremes</td>
								<td>1.0/2.0 ** 64.0</td>
								<td>2.0 ** 64.0</td>
							</tr>
							<tr>
								<td>extremes</td>
								<td>2.0 ** 64.0</td>
								<td>2.0 ** 64.0</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p><span class="topic">Glass Box Testing.</span> In contrast, <span class="italicsText">glass box testing</span> explores <span class="underlineText">all</span> of that paths through the code itself. Here, we actually look inside the function and examine its code, using the code to guide our test designs. Ideally, we have <span class="underlineText">at least one</span> test case for each path in the code. By path, we mean the different possible branches of the code (e.g., conditions and their blocks). If test every possible path in the code at least once, then the particular module is said to be path complete.</p>
				<p>The drawback? We cannot always guarantee path completeness. Recursive functions, for example, can have an arbitrary amount of paths. Other functions might have missing paths. Nevertheless, the most common candidates for path testing:</p>
				<div class="compare">
					<div>
					<p class="subheading">Branches</p>
					<ul>
						<li>Test: execute every part of the conditional</li>
						<li>Test: execute each part at different times (i.e., what happens if one condition is true before another condition is true; remember, none of the conditions are executed the moment the interpreter encounters a true condition).</li>
					</ul>
					</div>
					<div>
						<p class="subheading">Loops</p>
						<ul>
							<li>Test: What happens if loop is not entered?</li>
							<li>Test: What happens if we go through the loop exactly one?</li>
							<li>Test: What happens if we go through the loop more than once?</li>
							<li>Test: Possible ways to exit the loop (e.g., terminating too early)</li>
						</ul>
					</div>
				</div>
				<p>Consider the following function:</p>
				<pre class="language-python"><code>
					def abs(x):
						'''
						Assumptions:
							x is an int
						Returns:
							if x >= 0, x
							otherwise, -x 
						'''
						if x < -1:
							return -x
						else:
							return x
				</code></pre>
				<p>Here, we might pass <span class="monoText">-2</span> and <span class="monoText">2</span>. This test will be path-complete, but it misses a bug: What happens when <span class="monoText">x = -1</span>? Well, the function will incorrectly return <span class="monoText">-1</span>. Why? Because our <span class="monoText">if</span> condition is <span class="monoText">x < -1</span>. This demonstrates the fact that, even if we know a test is path complete, we must still test the boundary cases.</p>
			</section>

			<section id="bugs" class="grid-item">
				<h4>Bugs</h4>
				<p>Once we test and discover that our code does something we do not want it to do, we have discovered a <span class="term">bug</span>. This is our code blue, prompting us to perform three things: (1) isolate the bug; (2) eradicate the bug; and (3) retest until the code runs correctly. To perform these three steps properly, we must be able to identify different types of bus.</p>
				<p><span class="topic">Overt v. Covert Bugs.</span> Bugs are either <span class="italicsText">overt</span> or <span class="italicsText">covert</span>. An <span class="italicsText">overt bug</span> is one that has an obvious manifestaton &mdash; the code crashes or hangs. A <span class="italicsText">covert bug</span> is one with no obvious manifestation &mdash; the code returns a value, but it is incorrect.</p>
				<p>Because overt bugs are obvious, we want practice good defensive programming to ensure as many possible bugs are overt.</p>
				<p><span class="topic">Persistent v. Intermittent Bugs.</span> Bugs are also either <span class="italicsText">persistent</span>, or <span class="italicsText">intermittent</span>. <span class="italicsText">Persistent bugs</span> are those that occur every time the code is executed. <span class="italicsText">Intermittent bugs</span> are those that occur on and off; sometimes the code runs correctly, other times incorrectly, even on the same input. As we can probably tell, covert intermittent bugs are the most dangerous of all. Some bugs are annoying or frustrating. Covert intermittent bugs, however, have the potential for terror &mdash; the code ran incorrectly just once, but has since ran correctly without any changes.</p>
			</section>

			<section id="debugging" class="grid-item">
				<h4>Debugging</h4>
				<p>Debugging has a very steep learning curve. It takes many hours of practice to get to a level where we are able to write large, bug-free programs.</p>
				<p>IDEs often provide debugging tools for particular languages. We should take the time to learn and use these tools. Otherwise, the most basic tools include using the <span class="monoText">print</span> statement and debuggers. The most critical tool of all &mdash; your brain.</p>
				<p><span class="topic">Preliminary Questions.</span> To make a hypothesis, we want to ask several questions: How did I get to to this unexpected result? Is this related to some other problem I have solved before? Were there previous versions of this code that worked? Ask specific questions at this stage. Do not ask general questions like, what is wrong? We ask these preliminary questions to gather data. Once we have enough data, we want to come up with a debugging plan using the scientific method:</p>
				<ol>
					<li>Make a hypothesis for where the bug might come from.</li>
					<li>Run experiments testing that hypothesis.</li>
					<li>Make conclusions and draw further hypotheses</li>
				</ol>
				<p>Once we have constructed a hypothesis, we can begin running experiments with the tools below.</p>
				<p><span class="topic">Trace Execution.</span> Executing tracing is where we carefully lay out the sequence of executions for the code. This can be particularly useful for when we want to have a big picture view of how the code works. There are tools like <a href="http://pythontutor.com/visualize.html#mode=edit">Python Tutor</a> which lay these out for us. However, a fair warning: trace execution is often abused by new programmers. We should come up with an understanding of the code ourselves before we actually use an external tool, and coming up with our own hypothesis for why a bug is occurring.</p>
				<p><span class="topic">The <span class="monoText">print</span> Statement.</span> The <span class="monoText">print</span> statement is one of the most powerful ways to test our hypotheses. For example, with functions, we usually want to insert <span class="monoText">print</span> statements: (a) when we enter the function; (b) before computations in the function; and (c) when we exit the function. We also want to print the function's parameters and results.</p>
				<p>Point (b) raises a debugging approach called the <span class="term">bisection method</span> &mdash; placing <span class="monoText">print</span> statements halfway through the code. This helps us determine where a bug may be depending on the values printed.</p>
				<p><span class="topic">Understand Error Messages.</span> Error messages are invaluable for debugging. The most common errors in Python are the following:</p>
				<p><span class="topic"><span class="monoText">IndexError</span></span> We are trying to access beyond the limits of a list.</p>
				<pre class="language-python"><code>
					test = [1, 2, 3]
					element = test[4]
				</code></pre>
				<p><span class="topic"><span class="monoText">TypeError</span></span> Two possibilities: (1) We are casting into a type we cannot cast into; (2) we are mixing data types without appropriate coercion.</p>
				<pre class="language-python"><code>
					# bad casting
					test = [1, 2, 3] 
					int(test)

					# bad data type mixing
					'3' / 4
				</code></pre>
				<p><span class="topic"><span class="monoText">NameError</span></span> We are referencing a non-existent variable.</p>
				<pre class="language-python"><code>
					b = a + 1
					print(b)
				</code></pre>
				<p><span class="topic"><span class="monoText">SyntaxError</span></span> We are making illegal statements (e.g., forgetting to close parenthesis, forgetting colons or commas, etc.)</p>
				<pre class="language-python"><code>
					a = len([1, 2, 3])
					print a
				</code></pre>
				<p><span class="topic"><span class="monoText">KeyError</span></span> We are referencing a non-existent key.</p>
				<pre class="language-python"><code>
					myDict = {'name': 'sherlock', 'job':'detective'}
					print(myDict['address'])
				</code></pre>
				<p><span class="topic"><span class="monoText">RecursionError</span></span> Our recursive function is going beyond the maximum recursion depth.</p>
				<pre class="language-python"><code>
					def fibonacci(n):
						if n == 0 or n == 1:
							return 1
						else:
							return fibonacci(n - 1) + fibonacci(n - 2)

					fibonacci(1000000000)
				</code></pre>
				<p><span class="topic"><span class="monoText">UnboundLocalError</span></span> We are referencing a local variable in a function or method before the variable has been assigned.</p>
				<pre class="language-python"><code>
					x = 10
					def add_two():
						x += 2
						print(x)

					add_two()
				</code></pre>
				<p><span class="topic"><span class="monoText">ValueError</span></span> We are passing an argument into the function that is the right type, but has an inappropriate value.</p>
				<pre class="language-python"><code>
					import math

					math.sqrt(-10)
				</code></pre>
				<p><span class="topic">Logic Errors.</span> We will not get error messages for logic errors. This is where we get back outputs, but they are not what we expected. These are the most difficult errors to remedy, and preventive solutions are worth far more than curative ones. We should always think carefully before we write code. If we do encounter logic errors, a helpful tool is diagramming what we want our code to do. Flow chart the procedure's steps.</p>
				<p>Better yet, <span class="italicsText">explain</span> the code out loud. In programming parlance, this is called <span class="italicsText">rubber duck debugging</span>; the programmer explains the code to a rubber duck or someone willing to listen.</p>
				<p><span class="topic">Effective Workflow.</span> We can minimize bugs by ensuring our code is sanitary at all times. This is done by employing the following workflow:</p>
				<ol>
					<li>Write a function.</li>
					<li>Test the function.</li>
					<li>Debug the function.</li>
					<li>Write another function.</li>
					<li>Test the function.</li>
					<li>Debug the function.</li>
					<li>Integrate the functions.</li>
					<li>Do integration testing.</li>
				</ol>
				<p>Every group of changes we make should be followed by a <span class="monoText">git commit</span>. We should always have backups and previous versions of our code.</p>
				<p>If, at any point, we encounter a bug, we must do the following:</p>
				<ol>
					<li>Make a <span class="monoText">git commit</span> of the code right now.</li>
					<li>Change the code.</li>
					<li>Record the potential bug in a comment.</li>
					<li>Test the code.</li>
					<li>Compare the previous version with the current version.</li>
				</ol>
			</section>

			<section id="exceptions_assertions" class="grid-item">
				<h4>Exceptions and Assertions in Python</h4>
				<p><span class="italicsText">Exceptions</span> and <span class="italicsText">assertions</span> in Python provide additional means of defensive programming.</p>
				<p><span class="topic">Exceptions.</span> Exceptions in Python directly address the question: What happens when the procedure is executed and meets an unexpected condition? Hitting an unexpected condition is an <span class="term">exception</span>. When an exception occurs, we typically get back error messages (e.g., <span class="monoText">IndexError</span>, <span class="monoText">TypeError</span>, <span class="monoText">NameError</span>, etc.).</p>
				<p>Other common types exceptions: <span class="monoText">SyntaxError</span> - Python cannot parse the program. <span class="monoText">NameError</span> - a local or global name cannot be seen. <span class="monoText">AttributeError</span> - an attribute reference has failed. <span class="monoText">TypeError</span> - the operand does not have the correct type. <span class="monoText">ValueError</span> - the operand type is valid, but the value is illegal. <span class="monoText">IOError</span> - There is a problem with the IO system (e.g., nonexistent file or file not found).</p>
				<p><span class="topic">What do we do with exceptions?</span> There are three options for handling exceptions: (1) Fail silently; (2) Return an &#8220;error&#8221; value; (3) stop execution and signal the condition.</p>
				<p>The first option, failing silently, is where we substitute default values or simply continue. This is the worst possible approach. It is essentially sweeping the problem under the rug and pretending it does not exist. Worse, it borders on deceit. The user will get no warning that something has gone wrong.</p>
				<p>The second option, return an error value, is an incomplete solution. Even if we return an error value, we still have the problem. This can also needlessly complicate our code. What value should we choose? How do we check for the special value?</p>
				<p>The third option is the one we should always go with &mdash; as soon as the code hits an exception, stop executing and <span class="italicsText">raise an exception</span>. This is done in Python with the following:</p>
				<pre class="language-python"><code>
					raise Exception("string describing error")
				</code></pre>
				<p><span class="topic">Handlers.</span> Python provides symbols for handling exceptions. Consider the following:</p>
				<pre class="language-python"><code>
					try:
						a = int(input("Divisor: "))
						b = int(input("Dividend: "))
						print(a/b)
						print("Okay")
					except:
						print("Bug in user input")
					print("Outside")
				</code></pre>
				<p>The code above contains two new pieces of syntax: <span class="monoText">try</span> and <span class="monoText">except</span>. The code effectively provides, <span class="monoText">try</span> these statements below; if at any point an exception is raised, STOP, jump to the statement below <span class="monoText">except</span>.</p>
				<p>The <span class="monoText">try</span> and <span class="monoText">except</span> structure above essentially allows us to customize exception handling.</p>
				<p><span class="topic">Handling Specific Exceptions.</span> Handlers can be extended to specific errors. For example:</p>
				<pre class="language-python line-number"><code>
					try:
						a = int(input("First term: "))
						b = int(input("Second term: "))
						print("a/b = ", a/b)
						print("a+b = ", a+b)
					except ValueError:
						print("Could not cast to a number.")
					except ZeroDivisionError:
						print("Can't divide by zero.")
					except:
						print("Something went wrong.")	
				</code></pre>
				<p>The code above provides that if the exceptions above occur, stop execution and go to the relevant exception. Instead of print out the usual error message (i.e., <span class="monoText">ValueError</span>) do this instead.</p>
			</section>
			
			<section id="object_oriented_programming" class="grid-item">
				<h3>Object Oriented Programming</h3>
				<p>The ability to define functions allows us to write procedures and treat them as though they were built into the language, just like <span class="monoText">+, -, /, *, %</span> operators, or the build in methods like <span class="monoText">len()</span>.</p>
				<p>Now we want to do the same thing with data &mdash; creating <span class="italicsText">objects</span> and <span class="italicsText">classes of objects</span>. This ability drastically increases our ability to write complex and efficient programs.</p>
				<p>We have already encountered a number of objects: <span class="monoText">int</span>, <span class="monoText">string</span>, <span class="monoText">boolean</span>, etc. These are all data objects. We have also seen data structures, which themselves are data objects: tuples, lists, and dictionaries.</p>
				<p>All of these objects have (1) a <span class="italicsText">type</span>; (2) an <span class="italicsText">internal data representation</span> - whether the object is primitive or composite; and (3) a set of procedures for interacting with that particular object.</p>
				<p>The following are all <span class="term">instances</span> of a data object type: <span class="monoText">8</span> is an instance of <span class="monoText">int</span>; <span class="monoText">True</span> is an instance of <span class="monoText">boolean</span>; <span class="monoText">2.44</span> is an instance of <span class="monoText">float</span>; <span class="monoText">'hello'</span> is an instance of <span class="monoText">string</span>.</p>
				<p>All of this lends to an underlying principle grounding Python &mdash; nearly everything in Python is an object with a type. Objects, more generally, are <span class="italicsText">data abstractions</span>. That abstraction captures two things: (a) the <span class="italicsText">data attributes</span> and (b) it defines the data's <span class="italicsText">interface</span> through <span class="italicsText">methods</span> (procedures), which has the effect of defining the data object's <span class="italicsText">behavior</span> while hiding the object's implementation.</p>
				<p>With every data object, we can create new instances of that data object's type. Checking that ability, we can also destroy instances of that particular data object's type, either explicitly with methods like <span class="monoText">del</span>, or implicitly by allowing Python's garbage collection to eventually remove them from memory.</p>
				<p>To repeat, data objects are abstractions, just as functions are abstractions. For example, consider the data type <span class="monoText">list</span>. How are lists represented internally? It turns out lists in Python are <span class="italicsText">linked lists</span> &mdash; each list element consists of (a) the literal stored (itself a data object), and (b) a pointer to the next element in the list. We have many ways of manipulating the list: we can index, obtain length, find the max, etc. The data object <span class="monoText">list</span> allows us to create, manipulate, and destroy lists without worrying about the lower level implementation details &mdash; allocating memory, assigning pointers, freeing memory, etc. Data objects abstract away the technicalities.</p>
			</section>

			<section id="python_classes" class="grid-item">
				<h4>Classes</h4>
				<p>There is a distinction between <span class="italicsText">classes</span> and an <span class="italicsText">instance</span> of that class. The data object <span class="monoText">[1, 2, 3]</span> is an instance of the class <span class="monoText">list</span>.</p>
				<p>As a matter of Python programming, a <span class="term">class</span> is essentially a <span class="italicsText">type</span>. The use of &#8220;class&#8221; is largely a historic artifact. Originally, Python had both types and classes&mdash;separate, distinct, and never the twain shall meet. Types were built-in objects defined in C; classes were what the programmer built using a <span class="monoText">class</span> statement. The distinction existed because you could not legally use the two, type and class, together. That distinction has largely gone away.</p>
				<p>As a matter of type theory, however, there is a distinction between types and classes. A <span class="italicsText">type</span> is a collection of all the common features of <span class="italicsText">a set of objects</span> with the <span class="italicsText">same characteristics</span>. A <span class="italicsText">class</span>, on the other hand, is a specific <span class="italicsText">type</span> &mdash; it defines how a particular object is created. In other words, all classes are types, but not all types are classes.</p>
				<p>For example, tuples, lists, dictionaries, functions, <span class="monoText">int</span>, <span class="monoText">float</span>, and <span class="monoText">boolean</span> are all types. But <span class="monoText">int</span>, <span class="monoText">float</span>, and <span class="monoText">boolean</span> are not classes; they are are primitives. Arrays, tuples, dictionaries, and functions, however, are classes.</p>
				<p><span class="topic">Object-Oriented Programming.</span> The ability to create classes is our forray into <span class="italicsText">object-oriented programming</span> &mdash; the programming paradigm where data is bundled with procedures into an object (in Python, a class), and modularize programs with such objects. There are several advantages to object-oriented programming.</p>
				<p>First, it embodies a <span class="italicsText">divide-and-conquer</span> development approach. By modularizing our programs into classes, we can implement and test each class separately. Not only does this ease testing and debugging, it reduces program complexity.</p>
				<p>Second, by encouraging us to use classes as much as we can, we have more pieces of reusable code. Many third-party Python modules (i.e., libraries) define new classes. Each of those classes have separate environments (avoiding collisions with our own function names), which in turn allows us to use pre-existing classes throughout our code. The same idea applies for our own modules. Furthermore, <span class="italicsText">inheritance</span>, a topic to be discussed in later sections, allows us to create <span class="italicsText">subclasses</span>, which in turn redefine or extend a selected <span class="italicsText">subset</span> of the <span class="italicsText">superclass</span>'s behavior.</p>
				<p><span class="topic">Creating Classes.</span> Implementing, or creating, a class involves two steps: (1) defining the class name, and (2) defining the class attributes. When we use the class, we (a) create instances of objects of that class, and (b) perform operations on those instances. All that said, let us now turn to examples.</p>
				<p>To create a class, we use the symbol <span class="monoText">class</span>. The general form:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						<span class="blueText">class</span> class_name(<span class="blueText">object</span>):
							⟨attributes⟩
					</code></pre>
				</figure>
				<p>Like <span class="monoText">def</span>, we indent code to tell Python which statements (the class's <span class="term">attributes</span>) are part of the <span class="term">class definition</span>. The symbol <span class="monoText">object</span> tells Python that <span class="monoText">class_name</span> is a Python object and <span class="italicsText">inherits</span> all its attributes. In other words, <span class="monoText">class_name</span> is a <span class="term">subclass</span> of <span class="monoText">object</span>, and <span class="monoText">object</span> is a <span class="term">superclass</span> of <span class="monoText">class_name</span>. A subclass always inherits from its superclass. Thus, the general form of a class definition is really:</p>
				<figure class="math-display">
					<pre class="language-pseudo"><code>
						class class_name(class_parent):
							⟨class attributes⟩
					</code></pre>
				</figure>
				<p><span class="topic">Attributes.</span> The data and procedures beloning to a class are called the class's <span class="italicsText">attributes</span>. Thus, all attributes fall into two kinds: (a) <span class="term">data attributes</span> and (b) <span class="term">methods</span>. The <span class="italicsText">data attributes</span> are the other objects that make up the class. For example, suppose we had a class called <span class="monoText">coordinates</span>. That class might itself contain two objects: an object called <span class="monoText">x_coordinate</span>, and another object called <span class="monoText">y_coordinate</span>.</p>
				<p>The <span class="italicsText">methods</span> are the functions that work only within that class (this is where the distinction betwee <span class="italicsText">methods</span> and <span class="italicsText">functions</span> arises &mdash; all methods are functions, but not all functions are methods, but all methods and functions are procedures). For example, for the <span class="monoText">coordinate</span> class, we might have a method that calculates the distance between two <span class="monoText">coordinate</span> objects.</p>
				<p><span class="topic">Creating Instances of an Class.</span> To use the class, we must define how to create an instance of the class. To do so, we use the the special method <span class="monoText">__init__()</span>. For example:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = y
							self.y = y
				</code></pre>
				<p>The <span class="monoText">__init__()</span> method is a built-in method, or <span class="term">reserved method</span>, in Python for creating instances of a class. This particular kind of method is found in many other languages that support object-oriented programming like Java and C++, and is more broadly called a <span class="term">constructor</span>.</p>
				<p>The symbol <span class="monoText">self</span> is a special variable parameter, more specifically an object, that refers to an instance of the class. This symbol logically follows when we consider the following code:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y

					origin = Coordinate(0,0) 
					point_A = Coordinate(5,5)
				</code></pre>
				<p>In the final line, we have an instance of the <span class="monoText">coordinate</span> class called <span class="monoText">origin</span>. That instance is passed into the <span class="monoText">class</span> definition as a parameter, by virtue of the special parameter <span class="monoText">self</span>.</p>
				<p>Inside the class definition, we have two statements: <span class="monoText">self.x = x</span> and <span class="monoText">self.y = y</span>. The values passed in the last line, <span class="monoText">coordinate(0,0)</span> are passed into the definition, and bound to <span class="monoText">self.x</span> and <span class="monoText">self.y</span>. The two statements &mdash; <span class="monoText">self.x</span> and <span class="monoText">self.y</span> &mdash; are examples of <span class="italicsText">data attributes</span>. More specifically, <span class="monoText">self.x</span> and <span class="monoText">self.y</span> are called <span class="term">instance variables</span>.</p>
				<p>Let's see what the value bound to <span class="monoText">origin</span> is:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y

					origin = Coordinate(0,0) 
					point_A = Coordinate(5,5)

					print(origin)
					print(point_A)
				</code></pre>
				<pre class="language-bash"><code>
					&lt;__main__.Coordinate object at 0x7f5651ac9d00&gt;
					&lt;__main__.Coordinate object at 0x7f5651a947c0&gt;
				</code></pre>
				<p>Great. The definition worked just fine; we can see the two instances were created successfully. Notice that we did not explicitly pass an argument for the <span class="monoText">self</span> parameter. This is because the argument for the <span class="monoText">self</span> parameter is the instance itself. Python automatically creates a pointer to the instance for the definition to use.</p>
				<p>Now, once we have created an instance of the class, we have instance variables we can access:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y

					origin = Coordinate(0,0) 
					point_A = Coordinate(5,5)

					print(origin.x)
					print(origin.y)
					print(point_A.x, point_A.y)
				</code></pre>
				<pre class="language-bash"><code>
					0
					0
					5 5
				</code></pre>
				<p>How does this all work? When we write <span class="monoText">origin.x</span>, the symbol <span class="monoText">origin</span> points to a <span class="italicsText">frame</span>, just like function calls. Within the scope of that frame, there are values bound to data attribute variables (<span class="monoText">self.x = x</span>). The expression <span class="monoText">origin.x</span> is interpreted as getting the value of <span class="monoText">origin</span> (a frame) and then looking up the value associated with <span class="monoText">x</span> within that frame (the specific value ofthat instance).</p>
				<p>Note what this all means. We can now organize data and use them just as if they were literals:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y

					origin = Coordinate(0,0)
					point_A = Coordinate(5,5)
					point_B = Coordinate(6,6)

					x_coordinates = [origin.x, point_A.x, point_B.x]

					print(x_coordinates)
				</code></pre>
				<pre class="language-bash"><code>
					[0, 5, 6]
				</code></pre>
				<p>Very cool.</p>
				<p><span class="topic">Methods.</span> With classes, we can also include functions that work only with a particular class. For example, the <span class="monoText">.len()</span> function only works with objects that have a length property. Functions that work only for a particular class are called <span class="term">methods</span>. In contrast to data attributes, methods are a class's <span class="term">procedural attributes</span>.</p>
				<p>When we define methods, Python will always pass the actual object as the first argument. Thus, as we did with data attributes, we include the <span class="monoText">self</span> argument as the first argument whenever we define a method.</p>
				<p>Additionally, we use <span class="italicsText">dot notation</span> to access procedural data attributes (methods), just as we would data attributes. To create methods, we use the same general form employed for data attributes. Consider the following:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def distance(self, other):
							x_diff_sq = (self.x-other.x) ** 2
							y_diff_sq = (self.y-other.y) ** 2
							return (x_diff_sq + y_diff_sq) ** 0.5
				</code></pre>
				<p>As we can see, we define methods just as we would functions, with the added syntax of <span class="monoText">self</span> and the dot operator. We use the dot operator for both arguments because we are accessing data attributes for instances of the particular class, <span class="monoText">Coordinate</span>. Testing:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def distance(self, other):
							x_diff_sq = (self.x-other.x) ** 2
							y_diff_sq = (self.y-other.y) ** 2
							return (x_diff_sq + y_diff_sq) ** 0.5
					
					origin = Coordinate(0,0)
					pt_A = Coordinate(3,4) 
					distance_origin_to_A = pt_A.distance(origin)
					print(distance_origin_to_A)
				</code></pre>
				<pre class="language-bash"><code>
					5.0
				</code></pre>
				<p>Great, it worked perfectly. Notice how we called it. We wrote <span class="monoText">pt_A.distance(origin)</span>. This tells Python, go to the instance <span class="monoText">pt_A</span>, access the method <span class="monoText">distance</span>, pass <span class="monoText">pt_A</span> and <span class="monoText">origin</span> as arguments into the method's definition, and execute. This is the conventional way of calling the method. However, we can also call the method with:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def distance(self, other):
							x_diff_sq = (self.x-other.x) ** 2
							y_diff_sq = (self.y-other.y) ** 2
							return (x_diff_sq + y_diff_sq) ** 0.5
					
					origin = Coordinate(0,0)
					pt_A = Coordinate(3,4) 
					distance_origin_to_A = Coordinate.distance(pt_A, origin)
					print(distance_origin_to_A)
				</code></pre>
				<pre class="language-bash"><code>
					5.0
				</code></pre>
				<p>Both approaches above are correct, but the former is conventional in Python.</p>
				<p>Earlier, we saw passing an instance of a class on its own to the <span class="monoText">print</span> method results in the following output:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y

					origin = Coordinate(0,0) 
					point_A = Coordinate(5,5)

					print(origin)
					print(point_A)
				</code></pre>
				<pre class="language-bash"><code>
					&lt;__main__.Coordinate object at 0x7f5651ac9d00&gt;
					&lt;__main__.Coordinate object at 0x7f5651a947c0&gt;
				</code></pre>
				<p>This is an example of an <span class="term">uninformative</span> print representation, and it is the default representation for class instances. We can, however, change this with the <span class="monoText">__str__</span> method. This allows us to see what the object looks like when we use the <span class="monoText">print</span> statement. Even better, the <span class="monoText">__str__</span> method allows us to dictate what the result of a <span class="monoText">print</span> statement should look like when we pass the particular instance as an argument:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def __str__(self):
							return f"<{self.x},{self.y}>"
					
					pt_A = Coordinate(5,5)
					print(pt_A)
				</code></pre>
				<pre class="language-bash"><code>
					&lt;5,5&gt;
				</code></pre>
				<p>This is a very useful method to have, partuclarly for debugging. We can also check for <span class="monoText">type</span>:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def __str__(self):
							return f"<{self.x},{self.y}>"
					
					pt_A = Coordinate(5,5)
					print(type(pt_A))
				</code></pre>
				<pre class="language-bash"><code>
					&lt;'__main__.Coordinate'&gt;
				</code></pre>
				<p>Another very useful method to have is to check if an instance is an instance of a particular class (especially useful for branching programs). To do so, we use the <span class="monoText">isinstance()</span> method:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def __str__(self):
							return f"<{self.x},{self.y}>"
					
					pt_A = Coordinate(5,5)

					test = isinstance(pt_A, Coordinate)

					print(test)
				</code></pre>
				<pre class="language-bash"><code>
					True
				</code></pre>
				<p><span class="topic">Special Operators.</span> We can define what certain operators mean for instances of a particular object:</p>
				<figure class="table">
					<table class="loop_table">
						<thead>
							<th>Operator</th>
							<th>Description</th>
						</thead>
						<tbody>
							<tr>
								<td><span class="monoText">__add__</span></td>
								<td>Define <span class="monoText">self + other</span>. This defines what it means when two instances of the class are added.</td>
							</tr>
							<tr>
								<td><span class="monoText">__sub__</span></td>
								<td>Define <span class="monoText">self - other</span>. This defines what it means when two instances of the class are subtracted.</td>
							</tr>
							<tr>
								<td><span class="monoText">__eq__</span></td>
								<td>Define <span class="monoText">self == other</span>. This defines what it means for two instances of the class to be equal.</td>
							</tr>
							<tr>
								<td><span class="monoText">__ne__</span></td>
								<td>Define <span class="monoText">self != other</span>. This defines what it means for two instances of the class to be not equal.</td>
							</tr>
							<tr>
								<td><span class="monoText">__lt__</span></td>
								<td>Define <span class="monoText">self < other</span>. This defines what it means for one instance of the class to be less than another.</td>
							</tr>
							<tr>
								<td><span class="monoText">__le__</span></td>
								<td>Define <span class="monoText">self <= other</span>. This defines what it means for one instance of the class to be less than or equal to another.</td>
							</tr>
							<tr>
								<td><span class="monoText">__gt__</span></td>
								<td>Define <span class="monoText">self > other</span>. This defines what it means for one instance of the class to be greater than another.</td>
							</tr>
							<tr>
								<td><span class="monoText">__ge__</span></td>
								<td>Define <span class="monoText">self >= other</span>. This defines what it means for one instance of the class to be greater than or equal to another.</td>
							</tr>
							<tr>
								<td><span class="monoText">__len__</span></td>
								<td>Define <span class="monoText">self < other</span>. This defines what the length of an instance of the class is.</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>For example, we might want to define what it means to subtract two <span class="monoText">Coordinate</span> objects:</p>
				<pre class="language-python"><code>
					class Coordinate(object):
						def __init__(self, x, y):
							self.x = x
							self.y = y
						def __str__(self):
							return f"<{self.x},{self.y}>"
						def __sub__(self, other):
							return Coordinate(self.x - other.x, self.y - other.y)
					
					pt_A = Coordinate(5,5)
					pt_B = Coordinate(1,3)

					test = pt_A - pt_B

					print(test)
				</code></pre>
				<pre class="language-bash"><code>
					&lt;4,2&gt;
				</code></pre>
			</section>

			<section id="example_class_fractions" class="grid-item">
				<p><span class="topic">Application: Creating a Class for Fractions</span>. Let's apply what we know so far and create a new data type to represent fractions.</p>
				<p>Step 1: Internal representation. What do we need to represent this data type internally? We need two things: (1) a numerator, and (2) a denominator.</p>
				<p>Step 2: Interface. What are the methods we need? In other words, how should instances of <span class="monoText">fraction</span> interact with one another? Let's just start with the most basic things we do with fractions: (a) add and subtract, (b) convert to a <span class="monoText">float</span>, and (c) a <span class="monoText">print</span> representation.</p>
				<pre class="language-python"><code>
					class fraction(object):
						def __init__(self, numer, denom):
							self.numer = numer
							self.denom = denom
						def __str__(self):
							return f"{self.numer}/{self.denom}"
				</code></pre>
				<p>Testing:</p>
				<pre class="language-python"><code>
					class fraction(object):
						def __init__(self, numer, denom):
							self.numer = numer
							self.denom = denom
						def __str__(self):
							return f"{self.numer}/{self.denom}"
						
					half = fraction(1, 2)
					print(half)
				</code></pre>
				<pre class="language-bash"><code>
					1/2
				</code></pre>
				<p>Great, it works.</p>
				<p><span class="topic">Accessing Data Attributes.</span> With classes, we can define how to access data attributes with <span class="term">getters</span>. Getters are what allow us to quickly access data attributes:</p>
				<pre class="language-python"><code>
					class fraction(object):
						def __init__(self, numer, denom):
							self.numer = numer
							self.denom = denom
						def __str__(self):
							return f"{self.numer}/{self.denom}"

						def getNumer(self):
							return self.numer
						def getDenom(self):
							return self.denom
						
					half = fraction(1, 2)

					print( half.getNumer() )
					print( half.getDenom() )
				</code></pre>
				<pre class="language-bash"><code>
					1
					2
				</code></pre>
				<p>We can use getters to define more complex methods. For example, adding and subtracting fractions:</p>
				<pre class="language-python"><code>
					class fraction(object):
						def __init__(self, numer, denom):
							self.numer = numer
							self.denom = denom
						def __str__(self):
							return f'{self.numer}/{self.denom}'
						
						# getters
						def getNumer(self):
							return self.numer
						def getDenom(self):
							return self.denom
						
						# add fractions
						def __add__(self, other):
							numerNew =   (other.getDenom() * self.getNumer()) \ 
											+ ( other.getNumer() * self.getDenom())
							denomNew = other.getDenom() * self.getDenom()
							return fraction(numerNew, denomNew)
						
						# subtract fractions
						def __sub__(self, other):
							numerNew =   (other.getDenom() * self.getNumer()) \
											- (other.getNumber * self.getDenom)
							denomNew = other.getDenom() * self.getDenom()
							return fraction(numerNew, denomNew)
							
					oneHalf = fraction(1,2)
					oneThird = fraction(1,3)
					
					foo = oneHalf + oneThird
					
					print(foo)
				</code></pre>
				<pre class="language-bash"><code>
					5/6
				</code></pre>
				<p>Parfait. The getters stand in contrast to <span class="term">setters</span> &mdash; <span class="monoText">self.numer = numer</span> and <span class="monoText">self.denom = denom</span>. Why do we use getters instead of setters in the method definitions? Because we never want to modify an object's internal representation. Getters ensure that any computation or modification is performed on anything but the internal representation. That said, we now have the ability to create new instances of <span class="monoText">fraction</span> by performing arithmetic operators on existing instances. Let's add one more method: Converting the <span class="monoText">fraction</span> instances into floats:</p>
				<pre class="language-python"><code>
					class fraction(object):
						def __init__(self, numer, denom):
							self.numer = numer
							self.denom = denom
						def __str__(self):
							return f'{self.numer}/{self.denom}'
						
						# getters
						def getNumer(self):
							return self.numer
						def getDenom(self):
							return self.denom

						# add fractions
						def __add__(self, other):
							numerNew =   (other.getDenom() * self.getNumer()) \ 
											+ ( other.getNumer() * self.getDenom())
							denomNew = other.getDenom() * self.getDenom()
							return fraction(numerNew, denomNew)
						
						# subtract fractions
						def __sub__(self, other):
							numerNew =   (other.getDenom() * self.getNumer()) \
											- (other.getNumber * self.getDenom)
							denomNew = other.getDenom() * self.getDenom()
							return fraction(numerNew, denomNew)
						
						# convert fractions into floats
						def convert(self):
							return self.getNumer() / self.getDenom()
							
					oneHalf = fraction(1,2)
					oneThird = fraction(1,3)
					
					foo = oneHalf + oneThird
					foo_float = foo.convert()
					
					print(foo_float)
				</code></pre>
				<pre class="language-bash"><code>
					0.8333333333333334
				</code></pre>
				<p>Great, it works.</p>
			</section>

			<section id="creating_sets_in_python" class="grid-item">
				<p><span class="topic">Application: Creating a Set of Integers.</span> A common mathematical entity is a <span class="italicsText">set</span>. Sets in mathematics inherenlty have no order &mdash; they are just a collection, or gathering, of elements. Let's create a new type that represents a set of integers, initially empty. Furthermore, for this particular set implementation, we depart from set theory's permissibility of non-uniqueness of elements, and require that a particular integer can appear only once in a set. In computer science, we call this property &mdash; an element appears only once in a collection &mdash; <span class="term">representational invariance</span>. The elements in such a collection are called <span class="italicsText">representational invariants</span>.</p>
				<p>Step 1: What will be the class's internal representation? Here we will use a <span class="monoText">list</span> to store the set's elements.</p>
				<p>Step 2: What will be the class's interface? Given that the class is supposed to represent a set, we want three particular methods: (1) <span class="monoText">insert(e)</span>, which inserts an integer <span class="monoText">e</span> if it isn't in the set already; (2) <span class="monoText">member(e)</span>, which returns <span class="monoText">True</span> if integer <span class="monoText">e</span> is in the set, otherwise <span class="monoText">False</span>; and (3) <span class="monoText">remove(e)</span>, which removes integer <span class="monoText">e</span> from the set and returns an error if no such integer exists (we should always inform a reader she is attempting to remove something that does not exist).</p>
				<pre class="language-python"><code>
					class intSet(object):
						def __init__(self):
							self.vals = []
						
						# methods
						def insert(self, e):
							if not e in self.vals:
								self.vals.append(e)
						def member(self, e):
							return e in self.vals
						def remove(self, e):
							try:
								self.vals.remove(e)
							except:
								raise ValueError(f"{e} not found")
						
						# print output
						def __str__(self):
							self.vals.sort()
							result = ''
							for e in self.vals:
								result = result + str(e) + ','
							return '{' + result[:-1] + '}'
				</code></pre>
				<p>Notice that in our code, we took advantage of the existing properties of lists. This is great example of why modularization is so important. We take existing methods and objects, and use them to create more methods and objects. Let's test our new data type:</p>
				<pre class="language-python"><code>
					class intSet(object):
						def __init__(self):
							self.vals = []
						
						# methods
						def insert(self, e):
							if not e in self.vals:
								self.vals.append(e)
						def member(self, e):
							return e in self.vals
						def remove(self, e):
							try:
								self.vals.remove(e)
							except:
								raise ValueError(f"{e} not found")
						
						# print output
						def __str__(self):
							self.vals.sort()
							result = ''
							for e in self.vals:
								result = result + str(e) + ','
							return '{' + result[:-1] + '}'

					naturals = intSet()
					print(naturals)
					
					naturals.insert(1)
					print(naturals)
					
					naturals.insert(2)
					print(naturals)
					
					naturals.insert(3)
					print(naturals)
					
					naturals.insert(1)
					print(naturals)
					
					is_one_in_naturals = naturals.member(1)
					print(is_one_in_naturals)
					
					naturals.remove(3)
					print(naturals)
					
					naturals.remove(4)
					print(naturals)	
				</code></pre>
				<pre class="language-bash"><code>
					{}
					{1}
					{1,2}
					{1,2,3}
					{1,2,3}
					True
					{1,2}
					ValueError: 4 not found
				</code></pre>
				<p>Success. Again, observe the way we used the existing methods for lists to create a method for a new data type. This the whole point of object-oriented programming: Grouping data and methods together into an object (a class), and using existing objects (classes) to create more complex objects grouping data and methods (classes).</p>
			</section>

			<section id="the_power_of_oop" class="grid-item">
				<h4>The Value of Object-Oriented Programming</h4>
				<p>Object-oriented programming is a powerful approach to tackling programming problems because it bundles together things (objects) that share common attributes and procedures that operate on those attributes. Grouping similar things together because of their characteristics and what we can do based on those characters is something we do frequently not only in programming, but in real life as well. We can add two integers together, but it makes no sense to add a cat and a dog. We can determine what dry foods to feed a cat and what to feed a dog, but it makes no sense to ask what dry foods we should feed Booleans.</p>
				<p>Object-oriented programming abstracts away all of the lower level questions we ask: Is this a dog? Is this a cat? Is this a number? What happens when I add? What happens if the food is <span class="italicsText">Cereal K9</span>? We encapsulate all of these lower level details in a class, so we do not have ask them everytime we work with instances of that class. Because of <span class="italicsText">inheritance</span>, all of the attributes and methods in the class <span class="monoText">dog</span> will work for the sub-classes <span class="monoText">shiba inu</span>, <span class="monoText">German shephard</span>, and <span class="monoText">pitbull</span>. And the cherry on top: We can treat these classes as if Python built them in from the very beginning &mdash; we are, in a sense, extending the language.</p>
				<p>The whole concept of classes is based on the idea of classification. Persians, Siamese, and British Shorthairs are all cats. Cats, dogs, seals, dugongs, rabbits, and cows are all mammals. Mammals, reptiles, amphibians, and insects are all animals. Animals, plants, bacteria, and fungi are all living organisms. All living organisms contain carbon, so that data attribute is inherited by everything below. All living organisms propogate, so we might define a method for propogate inherited by everything below, and modify it accordingly for each of the subclasses &mdash; some need a mate; some have certain gestation periods; some have limits on how much they can propogate given a certain amount of time. These are all <span class="italicsText">layers of abstraction</span>.</p>
				<p><span class="topic">Dangers in Python.</span> Python gives us an enormous amount of freedom when creating classes and using instances of those classes. That freedom, however, comes at a price &mdash; revealing and allowing too much access to information. As we've seen, we can access data from outside the class definition easily: <span class="monoText">instance.data_attribute</span>. We can also access and write to data from outside the class definition: <span class="monoText">instance.data_attribute = value</span>. We can also create data data attributes for an instance outside the class definition: <span class="monoText">instance.new_attribute = value</span>. <span class="boldText">Do not do these</span>. It is horrible style and can cause an inordinate amount of misery during testing and debugging.</p>
			</section>

			<section id="hierarchies" class="grid-item">
				<h4>Inheritance</h4>
				<p>As aforementioned, classes are premised on classification. A key component of classification is the concept of <span class="italicsText">hierarchy</span>. Let's explore that concept in terms of Python programming.</p>
				<p>Classes can have hierarchies. Consider, for example, the following hierarchy:</p>
				<figure><img src="images/number_hierarchy.svg" alt="num hierarchy" loading="lazy"></figure>
				<p>As we can see, hierarchies can be complicated, and many problems can be simplified if we break them down along the hierarchy.</p>
				<p>At the very top of the hierarchy is the <span class="term">parent class</span>. Every class beneath the parent class is called a <span class="term">child class</span>. The parent class is said to be the <span class="term">superclass</span> of the child class, and the child class is said to be the <span class="term">subclass</span> of the parent class.</p>
				<p>Every subclass inherits all data attributes (state) and procedural attributes (behavior) of the parent class. However, we are free to add more data attributes, more procedural attributes, and override existing attributes with a subclass.</p>
				<p>Let's suppose we have a parent class called <span class="monoText">Animal</span>, and three child classes: <span class="monoText">Person</span>, <span class="monoText">Cat</span>, and <span class="monoText">Rabbit</span>. Then suppose the <span class="monoText">Person</span> class has the subclass <span class="monoText">Student</span>. We begin with the parent class, <span class="monoText">Animal</span>:</p>
				<pre class="language-python"><code>
					class Animal(object):
						def __init__(self, age):
							self.age = age
							self.name = None
						def get_age(self):
							return self.age
						def get_name(self):
							return self.name
						def set_age(self, newAge):
							self.age = newAge
						def set_name(self, newName):
							self.name = newName
						def __str__(self):
							return f"animal: {self.name} : {self.age}"
				</code></pre>
				<p>In the <span class="monoText">Animal</span> class above, we pass <span class="monoText">object</span> as a parameter, which tells Python that this class inherits all of Python's built-in objects and methods. This in turn means that every subclass of <span class="monoText">Animal</span> will inherit the same.</p>
				<p>Now we can define a subclass of <span class="monoText">Animal</span>, <span class="monoText">Cat</span>:</p>
				<pre class="language-python"><code>
					class Cat(Animal):
						def speak(self):
							print("meow")
						def __str__(self):
							return f"cat: {self.name} : {self.age}"
				</code></pre>
				<p>Notice that rather than passing <span class="monoText">object</span> as a parameter, we passed in <span class="monoText">Animal</span>. This is because <span class="monoText">Cat</span> is a subclass of <span class="monoText">Animal</span>, so it inherits all the properties of <span class="monoText">Animal</span>. Notice further that we did not explicitly write <span class="monoText">__init__</span>. Again, this is because <span class="monoText">Cat</span> inherits everything from <span class="monoText">Animal</span>. This is also why we can use <span class="monoText">self.name</span> and <span class="monoText">self.age</span>.</p>
				<p>All of the above defined, let us test:</p>
				<pre class="language-python"><code>
					wooster = Cat(1)
					wooster.set_name('Wooster')
					print(wooster.get_name())
				</code></pre>
				<pre class="language-bash"><code>
					Wooster
				</code></pre>
				<p>Our hierarchy works so far. Let's define another subclass, <span class="monoText">Rabbit</span>:</p>
				<pre class="language-python"><code>
					class Rabbit(Animal):
						def speak(self):
							print("meep")
						def __str__(self):
							return "rabbit: {self.name} : {self.age}"
				</code></pre>
				<p>Testing:</p>
				<pre class="language-python"><code>
					bugs = Rabbit(2)
					bugs.speak()
				</code></pre>
				<pre class="language-bash"><code>
					meep
				</code></pre>
				<p>Now, suppose we made an instance of <span class="monoText">Animal</span> called <span class="monoText">foobar</span>:</p>
				<pre class="language-python"><code>
					foobar = Animal(1)
					foobar.speak()
				</code></pre>
				<pre class="language-bash"><code>
					AttributeError: 'Animal' object has no attribute 'speak'
				</code></pre>
				<p>We get an <span class="monoText">AttributeError</span>. This is because the <span class="monoText">speak</span> method is found only in <span class="monoText">Cat</span> and <span class="monoText">Rabbit</span>. This is an instance of <span class="monoText">Animal</span>, which contains no such method. Remember: Only the subclasses inherit the superclass's properties.  The superclass does not, in any way, inherit a subclass's properties (that would, after all, defeat the purpose of a hierarchy).</p>
				<p>Let's add one more class, <span class="monoText">Person</span>:</p>
				<pre class="language-python"><code>
					def __init__(self, name, age):
						Animal.__init__(self, age)
						Animal.set_name(self, name)
						self.friends = []
					def get_friends(self):
						return self.friends
					def add_friend(self, fname):
						if fname not in self.friends:
							self.friends.append(fname)
					def speak(self):
						print("hello")
					def age_diff(self, other):
						diff = self.get_age() - other.get_age()
						if self.age > other.age:
							print(f"{self.name} is {diff} years older than {other.name}.")
						else:
							print(f"{self.name} is {-diff} years younger than {other.name}.")
					def __str__(self):
						return f"Person: {self.name} : {self.age}"
				</code></pre>
				<p>Notice here that we used a different form of the <span class="monoText">__init__</span> method. Here, we called <span class="monoText">Animal</span> itself. In this form, we are telling Python to call the <span class="monoText">__init__</span> method for <span class="monoText">Animal</span>. We also called the <span class="monoText">set_name()</span> method associated with <span class="monoText">Animal</span>. The rest of the code, we create new data and procedural attributes for <span class="monoText">Person</span>.</p>
				<p>Finally, let's create the last class, a subclass of <span class="monoText">Person</span> called <span class="monoText">Student</span>:</p>
				<pre class="language-python"><code>
					class Student(Person):
						def __init__(self, name, age, major=None):
							Person.__init__(self, name, age)
							self.major = major
						def change_major(self, major):
							self = major
						def __str__(self):
							return f"student : {self.name} : self.age : self.major"
				</code></pre>
			</section>

			<section id="class_variables" class="grid-item">
				<p><span class="topic">Class Variables v. Instance Variables.</span> In every instance of a class, we have <span class="term">instance variables</span> &mdash; the data attributes stored in each instance. As such, these variables are specific to an instance, created for each instance, and belong to that instance. We ensure that these variables are created and used by referencing the generic name <span class="monoText">self</span> in the class definition.</p>
				<p>In contrast to instance variables are <span class="term">class variables</span> &mdash; these are the variables that <span class="italicsText">belong to the class</span> &mdash; they are defined inside the class, but outside any class methods, including <span class="monoText">__init__</span>. These variables are <span class="italicsText">shared among all instances of the class</span>.</p>
				<p>To illustrate, recall our <span class="monoText">Animal</span> class:</p>
				<pre class="language-python"><code>
					class Animal(object):
						def __init__(self, age):
							self.age = age
							self.name = None
						def get_age(self):
							return self.age
						def get_name(self):
							return self.name
						def set_age(self, newAge):
							self.age = newAge
						def set_name(self, newName):
							self.name = newName
						def __str__(self):
							return f"animal: {self.name} : {self.age}"
				</code></pre>
				<p>Each of the variables above, <span class="monoText">self.age</span>, <span class="monoText">self.name</span>, etc., are <span class="italicsText">instance variables</span>. Now, consider the follow class definition for <span class="monoText">Rabbit</span>, with a <span class="monoText">tag</span> variable:</p>
				<pre class="language-python"><code>
					class Rabbit(Animal):
						tag = 1
						def __init__(self, age, parent1=None, parent2=None)
							Animal.__init__(self, age)
							self.parent1 = parent1
							self.parent2 = parent2
							self.rabbit_id = Rabbit.tag
							Rabbit.tag += 1
				</code></pre>
				<p>The <span class="monoText">tag</span> variable above is a <span class="italicsText">class variable</span>, accessible to all instances of the class <span class="monoText">Rabbit</span>. In this case, <span class="monoText">tag</span>, is used as a unique identifier of each instance of <span class="monoText">class</span> &mdash; every new instance has a <span class="monoText">tag</span> equal to the previous instance's <span class="monoText">tag</span> plus 1.</p>
			</section>
		</article>
	</main>

	<!-- Scripts -->
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js " integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
		<script>
			document.addEventListener("DOMContentLoaded", function () {
				renderMathInElement(document.body, {
					// customised options
					// • auto-render specific keys, e.g.:
					delimiters: [
						{ left: "$$", right: "$$", display: true },
						{ left: "$", right: "$", display: false },
						{ left: "\\(", right: "\\)", display: false },
						{ left: "\\[", right: "\\]", display: true },
					],
					// • rendering keys, e.g.:
					throwOnError: false,
				});
			});
		</script>
		<!-- <script src="https://unpkg.com/function-plot@1.22.2/dist/function-plot.js"></script> -->
		<script src="js/csfoundations.js"></script>
		<script src="js/prism.js"></script>
</body>

</html>
