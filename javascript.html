<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>javascript</title>
	<!-- <base href="http://127.0.0.1:5500/csfoundations/" /> -->
	<link rel="stylesheet" href="css/csfoundations.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous" />
	
</head>
<body>
	<header>
		<h1>Computer Science Fundamentals</h1>
	</header>
	<main>
		<article id="javascript" class="grid" data-colcade="columns: .grid-col, items: .grid-item">
			<div class="grid-col grid-col--1"></div>
			<div class="grid-col grid-col--2"></div>
			<div class="grid-col grid-col--3"></div>
			<div class="grid-col grid-col--4"></div>

			<section class="grid-item">
				<h2>Web Development: JavaScript, Python, and SQL</h2>
				<p>The name "JavaScript" is the par excellence of marketing mayhem. JavaScript was originally referred to by its developers as "Mocha" (an arguably much better name, coffea genericism aside), but because the language was created to entice Java developers, the marketing experts concluded that "JavaScript" was a better fit, as "script" was the word du jour for "ease of use." While there are some similarities between Java and JavaScript, they are two completely different and unrelated languages&mdash;Java is to JavaScript what ham is to hamster.</p>
			</section>

			<section id="html_and_css" class="grid-item">
				<h3>HTML &amp; CSS</h3>
				<p>Most of the materials below address programming constructs. We briefly address <span class="monoText">HTML</span> (&#8220;Hypertext Markup Language&#8221;) and <span class="monoText">CSS</span> (&#8220;Cascading Style Sheets&#8221;), as they central languages in web development. How to use these languages effectively is a topic best left for <span class="italicsText">web design</span>, a separate field deserving of unique treatment. In this section, we look at a broader overview of the two languages, and how they relate to computer science more broadly.</p>
				<p><span class="monoText">HTML</span> is a markup language. It it is not a programming language per se (at least if we define a programming language as one that is Turing complete), but it is a language nevertheless. <span class="monoText">HTML</span> describes the <span class="italicsText">structure</span> of a webpage &mdash; where sections, buttons, paragraphs, and other <span class="italicsText">elements</span> are placed. <span class="monoText">CSS</span>, like <span class="monoText">HTML</span>, is not a programming language on its own, but it provides a means for <span class="italicsText">styling</span> <span class="monoText">HTML</span> content.</p>
				<p>A very basic <span class="monoText">HTML</span> page is written as such:</p>
				<pre class="language-html"><code>
					&lt;!DOCTYPE html&gt;
					&lt;html lang=&quot;en&quot;&gt;
					&lt;head&gt;
					&#x9;&lt;title&gt;Hello!&lt;/title&gt;
					&lt;/head&gt;
					&lt;body&gt;
					&#x9;&lt;p&gt;Hello world!&lt;/p&gt;
					&lt;/body&gt;
					&lt;/html&gt;
				</code></pre>
			</section>

			<section id="programming_introduction" class="grid-item">
				<h3>Programming In JavaScript</h3>
				<p>Recall that a <span class="term">program</span> is a set of instructions directing a computer to perform tasks. Programs are written in a <span class="term">computer language</span>&mdash;a language that can be <span class="term">compiled</span> and understood by the computer.</p>
				<p>Computer languages have <span class="term">syntax</span>, which is the set of rules defining how we spell, arrange, and use words, punctuation, and symbols. This is very much like human language, with the key difference that computer languages have strict contours (e.g., words and characters have exact and undisputed definitions), with little to no room for ambiguity (in that sense, computer languages are much less complex).</p>
				<p>To direct a computer to perform a task, we write <span class="term">statements</span>, following the relevant language's syntax. Statements themselves are composed of one or more <span class="term">expressions</span>, just as English sentences are composed of clauses.</p>
				<p>A program, then, is simply a collection of these statements. Within the collection of <span class="term">statements</span>, there are <span class="term">code blocks</span>. A code block is a group of statements intended to carry out a specific task. In JavaScript, we group statements together with <span class="monoText">{}</span>. For example:</p>
				<pre class="language-javascript">
						<code>
							{
								let x = 4;
								let y = x * 3;
								console.log(y);
							}
							// output: <span class="output">12</span>
						</code>
					</pre>
				<p>When we <span class="term">execute</span> the program, the JavaScript interpreter translates the statements into machine code, the code the computer actually understands.</p>
			</section>

			<section id="syntax_parsers" class="grid-item">
				<p><span class="topic">Syntax Parsers.</span> When we write JavaScript code, we aren't directly interacting with the computer. The computer itself doesn't understand what JavaScript statements are&mdash;it only understands 1s and 0s. Writing entirely in 1s and 0s, however, is difficult for hardware engineers, so an <span class="term">assembly language</span> is used; abstractions of those 1s and 0s. Assembly, however, is difficult to write for non-hardware engineers, and it is specifically suited to programming computer hardware. It is not meant to dynamically display Twitch streams, macros in Word, or stock tickers on Bloomberg. To accomplish this task, a computer language is needed. They are abstractions of that assembly language.</p>
				<p>That programming language, however, can only work if it is written <span class="italicsText">correctly</span>, and performs operations that are <span class="italicsText">permitted</span>. A <span class="term">syntax parser</span>, such as a <span class="term">compiler</span> or <span class="term">interpreter</span> is a program that performs this task. It reads our source code, determines what the code does, and decides whether the code's "grammar" is valid. If the source code's syntax is valid, then it is translated into <span class="italicsText">assembly</span>, which is then translated into 1s and 0s.</p>
				<p>Note what this means. A programming language is at the mercy of the syntax parser, and the syntax parser is a program written by another programmer. That syntax parser can decide to do additional things outside of simply determining the code's syntax is valid. It can also decide what syntax is considered valid. Particularly with JavaScript, this fact can lead to a variety of unexpected consequences.</p>
			</section>

			<section id="lexical_environments" class="grid-item">
				<p><span class="topic">Lexical Environment.</span> The world "lexical" means "having to do with words or grammar." Some programming languages, like JavaScript, have <span class="term">lexical environments</span>. If a programming language has a <span class="italicsText">lexical environment</span>, then the lines where we write code <span class="underlineText">matters</span>. In other words, you cannot just write anything, anywhere. For example:</p>
				<pre class="language-javascript"><code>
					function hello() {
						greeting = "Hello world!"
						console.log(greeting);
					}
				</code></pre>
				<p>Briefly, variables in JavaScript are indicated with the symbols:</p>
				<ul>
					<li><span class="monoText">let</span></li>
					<li><span class="monoText">const</span></li>
					<li><span class="monoText">var</span></li>
				</ul>
				<p>When writing variable names, the convention is to use only ASCII characters, but we are free to use the full set of Unicode characters.</p>
				<p>In the code above, the variable <span class="monoText">greeting</span> sits <span class="italicsText">lexically</span> inside the function <span class="monoText">hello()</span>. Moreover, if a programming language has a <span class="italicsText">lexical environment</span>, then the language gives us an idea of where in the computer's memory our code resides, and how it will interact with other parts of the program. Put simply, whenever we use the term <span class="italicsText">lexical environment</span>, we are referring to <span class="underlineText">where</span> the code is in the program, and <span class="underlineText">what</span> surrounds that code.</p>
			</section>

			<section id="execution_contexts" class="grid-item">
				<p><span class="topic">Execution Contexts.</span> Because programs use multiple statements and span multiple lines, if a programming language has a lexical environment, then it follows that there are multiple lexical environments. Those lexical environments do not all run at the same time. The environment that is currently run is managed through <span class="term">execution contexts</span>. An <span class="italicsText">execution context</span> is simply a wrapper that helps manage the code currently running. To do so, it not only contains your code, but additional code&mdash;that we may or may not have written&mdash;to help the syntax parser process our code.</p>
			</section>

			<section id="basic_syntax_declaring_variables" class="grid-item">
			</section>

			<section id="javascript_values" class="grid-item">
				<h3>JavaScript Types & Values</h3>
				<p>Values in JavaScript (and many other programming languages), are classified by type. A value's type will determine what JavaScript can and cannot do with the value. There are two categories of types: <span class="term">primitive types</span> and <span class="term">object types</span>. These primitive types are:</p>
				<ul>
					<li><span class="monoText">Number</span></li>
					<li><span class="monoText">BigInt</span></li>
					<li><span class="monoText">String</span></li>
					<li><span class="monoText">Boolean</span></li>
					<li><span class="monoText">Null</span></li>
					<li><span class="monoText">Undefined</span></li>
					<li><span class="monoText">Symbol</span></li>
				</ul>
				<p>Any value that is not a <span class="italicsText">number</span>, <span class="italicsText">string</span>, <span class="italicsText">boolean</span>, <span class="italicsText">symbol</span>, <span class="italicsText">null</span>, or <span class="italicsText">undefined</span> is an <span class="term">object type</span> value. Generally, an <span class="term">object</span> (a value of <span class="italicsText">object type</span>), is a collection of <span class="term">properties</span>, where each property consists of a <span class="term">name</span> and its corresponding <span class="term">value</span> (and that value may be a primitive type value or an object).</p>
				<p>The key difference between an object type value and a primitive type value: Object type values are <span class="term">mutable</span> (the value can be changed), while primitive type values are <span class="term">immutable</span> (the value cannot be changed).</p>
				<p>For example, if we have an object with a property <span class="monoText">{emotion: "happy"}</span>, the emotion's assigned value, "happy" can be changed. But, the value <span class="monoText">1</span>, a value of primitive type <span class="italicsText">number</span>, cannot be changed (rightly so&mdash;there is no other value of "1" other than "1"). Below we cover the key features of the primitive types.</p>
				<p>If we are ever unsure what type a particular value is, we can use the <span class="monoText">typeof</span> operator.</p>
				<pre class="language-javascript"><code>
					typeof 3476; // output: <span class="output">"number"</span>
					typeof true; // output: <span class="output">"boolean"</span>
				</code></pre>
			</section>

			<section id="converting_values" class="grid-item">
				<p><span class="topic">Converting Values to a Different Type.</span> JavaScript has no problem converting values from one type to another. This is a double-edged sword. For example, if we give JavaScript a value of type <span class="monoText">number</span> when it expects a value of type <span class="monoText">string</span>, JavaScript will convert the number into a string. This can lead to unexpected results. In other programming languages, these sort of operations will return an error.</p>

				<p><span class="topic">Casting.</span> To cast a value in JavaScript, there are three useful methods:</p>
				<pre class="language-javascript"><code>
					Number(n) // casts n as a number 
					parseFloat() // parses a string, returns float
					parseInt() // parses a string, returns int
					String() // convert number into string
				</code></pre>
			</section>

			<section id="primitive_type_number" class="grid-item">
				<p><span class="topic">Primitive Type: <span class="monoText">number</span>.</span> Unlike some programming languages (e.g., Java), JavaScript only has 1 number type. The primitive type <span class="monoText">number</span> stores integers, floats (decimal numbers), and approximations of real numbers. In other words, <span class="term">immutable numeric data</span>. And when a number appears directly in a JavaScript program is called a <span class="term">numeric literal</span>. Negative integers can be stored by appending a minus sign directly to the number (e.g., <span class="monoText">-17</span>).</p>
				<p>JavaScript's number type is not limited to the base-10 system or to decimal decimal notation:</p>
				<pre class="language-javascript"><code>
					// 12648430 in hex is C0FFEE
					0xC0FFEE

					// 17 in binary is 0011
					0b0011

					// 3.8 * 10^8 in exponential:
					3.8E8
				</code></pre>
				<p>We can also ensure large numbers are more readable with underscores as separators:</p>
				<pre class="language-javascript"><code>
					// The number 10,000,000
					10_000_000
				</code></pre>
			</section>

			<section id="special_number_NaN" class="grid-item">
				<p><span class="topic"><span class="monoText">NaN.</span></span> The value <span class="monoText">NaN</span> ("Not a Number") represents a numeric value that is not a number, but is a value of type <span class="monoText">number</span>. <span class="monoText">NaN</span> is the value returned from undefined operations:</p>
				<pre class="language-javascript"><code>
					// This evaluates to NaN
					0/0

					// This also evaluates to NaN
					NaN+1
				</code></pre>
				<pre class="language-bash"><code>
					NaN
					NaN
				</code></pre>
				<p><span class="monoText">NaN</span> has an unusual feature in JavaScript: it does not equal itself or any other value. This leads to some unusual results:</p>
				<pre class="language-javascript"><code>
					const x = NaN;
					console.log(x === NaN);
				</code></pre>
				<pre class="language-bash"><code>
					false
				</code></pre>
				<p>Thus, to check whether a variable is equal to <span class="monoText">NaN</span>, we need to test for nonequality. The expression will return true if, and only if, the variable has the same value as <span class="monoText">NaN</span>. If it does not, then the variable does not have the value <span class="monoText">NaN</span>.</p>
				<pre class="language-javascript"><code>
					const x = NaN;
					console.log(x != NaN);
				</code></pre>
				<pre class="language-bash"><code>
					true
				</code></pre>
			</section>

			<section id="special_number_infinity" class="grid-item">
				<p><span class="topic"><span class="monoText">infinity.</span></span> The value <span class="monoText">infinity</span> is the value returned from perform indeterminate operations. More specifically, JavaScript stores infinity in two different ways, $\infty^+$ (positive infinity) and $\infty^-$ (negative infinity).</p>
				<pre class="language-javascript"><code>
					// this evaluates to positive infinity
					1/0
					// this evaluates to negative infinity
					-1/0
				</code></pre>
			</section>

			<section id="special_number_0" class="grid-item">
				<p><span class="topic">The Value <span class="monoText">0</span> in JavaScript.</span> Perhaps to the mathematician's disgust, JavaScript has two values for 0:</p>
				<pre class="language-javascript"><code>
					0 	// positive 0
					-0 // negative 0
				</code></pre>
			</section>

			<section id="special_number_BigInt" class="grid-item">
				<p><span class="topic"><span class="monoText">BigInt.</span></span> The data type <span class="monoText">BigInt</span> is a separate primitive type for numeric data. <span class="monoText">BigInt</span> is the primitive type for extraordinarily large numbers (e.g., numbers with thousands or millions of digits):</p>
				<pre class="language-javascript"><code>
					// the number 11,395,430,243,259,821:
					11395430243259821n
				</code></pre>
				<p>The distinguishing syntax for <span class="monoText">BigInt</span> is the symbol <span class="monoText">n</span> appended to the end of the literal.</p>
			</section>

			<section id="math_object_introduction" class="grid-item">
				<p><span class="topic">The Math Object.</span> JavaScript has a built in math object, which provides values and operations (more accurately "<em>methods</em>"). These built-in values and methods allow programs to perform somewhat complex operations without having to write code from scratch. Below are static properties:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>Property</th>
							<th>Evaluates to</th>
						</thead>
						<tbody>
							<tr>
								<td>Math.PI</td>
								<td>${\pi}$</td>
							</tr>
							<tr>
								<td>Math.E</td>
								<td>${e}$ (Euler's constant)</td>
							</tr>
							<tr>
								<td>Math.SQRT2</td>
								<td>${\sqrt{2}}$</td>
							</tr>
							<tr>
								<td>Math.LN2</td>
								<td>${\ln 2}$</td>
							</tr>
							<tr>
								<td>Math.LN10</td>
								<td>${\ln 10}$</td>
							</tr>
							<tr>
								<td>Math.LOG2E</td>
								<td>${\log_{2}e}$</td>
							</tr>
							<tr>
								<td>Math.LOG10E</td>
								<td>${\log_{10}e}$</td>
							</tr>
							<tr>
								<td>Math.SQRT1_2</td>
								<td>${\dfrac{1}{\sqrt{2}}}$</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>And the static methods:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>Method</th>
							<th>Returns</th>
						</thead>
						<tbody>
							<tr>
								<td>Math.sin(x)</td>
								<td>${\sin x}$</td>
							</tr>
							<tr>
								<td>Math.cos(x)</td>
								<td>${\cos x}$</td>
							</tr>
							<tr>
								<td>Math.tan(x)</td>
								<td>${\tan x}$</td>
							</tr>
							<tr>
								<td>Math.hypot(x, y)</td>
								<td>${\sqrt{x^2 + y^2}}$</td>
							</tr>
							<tr>
								<td>Math.abs(x)</td>
								<td>${\lvert x \rvert }$</td>
							</tr>
							<tr>
								<td>Math.ceil(x)</td>
								<td>${\lceil x \rceil}$ (next largest integer)</td>
							</tr>
							<tr>
								<td>Math.floor(x)</td>
								<td>${\lfloor x \rfloor }$ (next smallest integer)</td>
							</tr>
							<tr>
								<td>Math.round(x)</td>
								<td>${ \lfloor x \rceil  }$ (nearest integer function)</td>
							</tr>
							<tr>
								<td>Math.max(x,y,z)</td>
								<td>Given numbers ${x, y, z,}$ returns largest number</td>
							</tr>
							<tr>
								<td>Math.min(x,y,z)</td>
								<td>Given numbers ${x, y, z,}$ returns smallest number</td>
							</tr>
							<tr>
								<td>Math.cbrt(x)</td>
								<td>${x^3}$</td>
							</tr>
							<tr>
								<td>Math.pow(x,y)</td>
								<td>${x^y}$</td>
							</tr>
							<tr>
								<td>Math.random()</td>
								<td>pseudorandom float ${n,}$ where ${0 < n < 1.}$</td>
							</tr>
							<tr>
								<td>Math.sign()</td>
								<td>number's signage</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>In addition to the math object methods, we have the basic arithmetic operators and the unary operators:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>Operator</th>
							<th>Returns</th>
						</thead>
						<tbody>
							<tr>
								<td>a + b</td>
								<td>${a + b}$</td>
							</tr>
							<tr>
								<td>a - b</td>
								<td>${a - b}$</td>
							</tr>
							<tr>
								<td>a * b</td>
								<td>${(a)(b)}$</td>
							</tr>
							<tr>
								<td>a / b</td>
								<td>${\dfrac{a}{b}}$</td>
							</tr>
							<tr>
								<td>a % b</td>
								<td>${a \bmod b}$</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>And the unary operators:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>Unary Operator</th>
							<th>Returns</th>
						</thead>
						<tbody>
							<tr>
								<td>x += n</td>
								<td>x = x + n</td>
							</tr>
							<tr>
								<td>x++</td>
								<td>x = x + 1</td>
							</tr>
							<tr>
								<td>x -= n</td>
								<td>x = x - n</td>
							</tr>
							<tr>
								<td>x--</td>
								<td>x = x - 1</td>
							</tr>
							<tr>
								<td>x *= n</td>
								<td>x = x * n</td>
							</tr>
							<tr>
								<td>x /= n</td>
								<td>${x = x / n}$</td>
							</tr>
							<tr>
								<td>x %= n</td>
								<td>${x = x \bmod n}$</td>
							</tr>
						</tbody>
					</table>
				</figure>
			</section>

			<section id="primitive_type_null" class="grid-item">
				<p><span class="topic">Primitive Type: <span class="monoText">null</span>.</span> The primitive type <b>null</b> is a primitive type consisting of only one value: <em>null</em>. The value <em>null</em> allows the programmer to declare a variable without assigning it a value, so that it may be used later on.</p>
				<pre class="language-javascript"><code>
					let x = null;
					console.log(x);
				</code></pre>
				<pre class="language-bash"><code>
					null
				</code></pre>
			</section>

			<section id="primitive_type_undefined" class="grid-item">
				<h5></h5>
				<p><span class="topic">Primitive Type: <span class="monoText">undefined</span>.</span> The type <b>undefined</b> consists of only one value, <em>undefined</em>. Normally, the programmer does not declare a variable and assign the value <em>undefined</em>. Instead, <em>undefined</em> is a value JavaScript returns. For example:</p>
				<pre class="language-javascript"><code>
					let x;
					console.log(x);
				</code></pre>
				<pre class="language-bash"><code>
					undefined
				</code></pre>
			</section>

			<section id="primitive_type_string" class="grid-item">
				<p><span class="topic">Primitive Type: <span class="monoText">string</span>.</span> A <b>string</b> is a sequence of characters. More specifically, it is an <span class="italicsText">immutable</span> ordered sequence of 16-bit values, where each value represents a Unicode character. Strings are inherently <span class="italicsText">arrays</span> (since they are an <span class="italicsText">ordered</span> sequence). Thus, each character in a string has an <span class="italicsText">index</span>, starting at 0. While the type number represents <em>numeric data</em>, and the type boolean represents <em>logical data</em>, the type <em>string</em> represents <em>textual data</em>.</p>
				<p>Strings can be represented in JS with double quotes (""), single quotes (''), or backticks (``), as long as they are used consistently.</p>
				<pre class="language-javascript"><code>
					firstName = "David";
					lastName = 'Hilbert';
					occupation = `Mathematician`;
					nickName = 'Hilby" // Error here
				</code></pre>
				<p>JavaScript provides many built in methods for manipulating strings. A few of the most often used methods are provided below.</p>
			</section>

			<section id="finding_a_strings_length" class="grid-item">
				<p><span class="topic">String Length.</span> The number of characters in a string is called its <em>length</em>, and JS can return that number with the following:</p>
				<pre class="language-javascript"><code>
					"hello".length; // returns 5
					let greeting = "howdy";
					greeting.length; // returns 5
				</code></pre>
			</section>

			<section id="concatenating_strings" class="grid-item">
				<p><span class="topic">Concatenating Strings.</span> To <em>concatenate</em> a string is simply to append, or combing different strings. Strings can be concatenated with a <span class="monoText">+</span> character.</p>
				<pre class="language-javascript"><code>
					let firstName = "Sherlock";
					let lastName = "Holmes";
					let fullName = firstName + " " + lastName;
					console.log(fullName);
					// JS returns "Sherlock Holmes"
				</code></pre>
			</section>

			<section id="string_indices" class="grid-item">
				<p><span class="topic">String Indices.</span> Strings are an array of characters (i.e., they are an ordered list of characters). Thus, every character in a string has an <em>index</em>—the number of its position.</p>
				<p>Recall that in computer science, we always count from 0. Thus, the first character in a string has index 0, the second character index 1, the third index 4, etc. Furthermore, because strings are <em>indexed</em>, JavaScript can search for parts of a string. A string's indices also allow JavaScript to copy parts of the string, and store those copies into a new variable. For example:</p>
				<pre class="language-javascript"><code>
					let word = "quadratic";
					// Return first character in word, q:
					word[0];
				</code></pre>
			</section>

			<section id="other_useful_string_methods" class="grid-item">
				<p><span class="topic">Common String Methods.</span> JavaScript provides numerous methods for use with strings. Below are examples of some of the most common methods:</p>
				<pre class="language-javascript"><code>
					let word = "hello";
					// capitalize all characters in string
					word.toUpperCase
					// lowercase all characters in string
					word.toLowerCase

					let phrase = " excuse me ";
					// remove white spaces before the string
					phrase.trimStart()
					// remove white spaces after the string 
					phrase.trimEnd()
					
					let greet = "Hello world!"
					// determine if string contains a substring
					greet.includes("World!") // returns false
					greet.includes("world!") // returns true

					let sport = "basketball";
					let law = "contracts law";
					// take a slice of the string
					sport.slice(6) // returns 'ball'
					law.slice(0, 9) // returns 'contracts'

					let quote = 'Call me Bond';
					// replace a substring
					quote.replace('Bond', 'Ishmael') // return 'Call me Ishmael'

					let food = 'hotdog'
					// find starting index of a substring or character
					food.indexOf('hot') // returns 0
					food.indexOf('dog') // returns 3
				</code></pre>
			</section>

			<section id="variables_introduction" class="grid-item">
				<h3>Variables in JavaScript</h3>
				<p>Unlike many other programming languages (e.g., Java), JavaScript variables and constants are <span class="term">untyped</span>&mdash;we do not specify the type of the value to be assigned in a declaration. <span class="term">Variables</span> are essentially boxes with labels, that we can then use to store data. By storing data in a variable, we can recall the data later on, use it, or change it.</p>
				<p>As aforementioned, there are three ways to declare variables in JavaScript: <span class="monoText">let</span>, <span class="monoText">const</span>, and <span class="monoText">var</span>. We cover each of their uses below. To do so, however, we need to give the variable a <span class="term">name</span>.</p>
			</section>

			<section id="naming_variables" class="grid-item">
				<p><span class="topic">Naming Variables.</span> There are a few rules that should always be followed when naming variables:</p>
				<ol>
					<li>Variable names should be concise, descriptive, and balanced between being concise and descriptive.</li>
					<li>The first character in a variable name should be a letter.</li>
					<li>Do not use reserved words.</li>
					<li>camelCasing, PascalCasing, or pothole_casing should be used for variables of multiple words. In particular:</li>
					<ul>
						<li>Functions and methods generally follow camelCasing.</li>
						<li>Classes and components generally follow PascalCasing.</li>
						<li>Private variables, functions, and methods are generally prefixed with an underscore.</li>
						<li>Constants follow UPPERCASE.</li>
						<li>Variables <span class="underlineText">cannot</span> be named with kebab-casing (dashes for spaces).</li>
						<li>JavaScript files, however, can use kebab-casing.</li>
					</ul>
					<li>For Boolean variables or functions, use of quantifiers is helpful:</li>
					<ul>
						<li>
							<pre class="language-javascript"><code>
								const isVisible = true;
								const isSubmitted = true;
								const hasEncryption = true;
								const form_is_filled = true;
							</code></pre>
						</li>
					</ul>
				</ol>
			</section>

			<section id="declaring_with_let" class="grid-item">
				<p><span class="topic">Declaring a Variable with <span class="monoText">let</span>.</span> We can declare variables in JavaScript with the symbol <span class="monoText">let</span>:</p>
				<pre class="language-javascript"><code>
					let x = 0;
				</code></pre>
				<p>There are, however, limitations with using <span class="monoText">let</span>. In the example above, because <span class="monoText">x</span> we declared with <span class="monoText">let</span>, we cannot redeclare <span class="monoText">x</span> with <span class="monoText">let</span> later down the program:</p>
				<pre class="language-javascript"><code>
					let x = 0;
					
					// This returns an uncaught syntax error
					let x = 1;
				</code></pre>
				<p>But, we can reassign values to a declared variable:</p>
				<pre class="language-javascript"><code>
					let x = 0;
					x = x + 1;
					console.log(x)
				</code></pre>
				<pre class="language-bash"><code>
					1
				</code></pre>
			</section>

			<section id="declaring_with_const" class="grid-item">
				<h3>
					Declaring a Variable with
					<span class="monoText">const</span>
				</h3>
				<p>The keyword <span class="monoText">const</span> is yet another way to declare a variable.</p>
				<pre class="language-javascript">
							<code>
								const acceleration = 9.807;
							</code>
						</pre>
			</section>

			<section id="limitations_of_const" class="grid-item">
				<h4>Limitations of <span class="monoText">const</span></h4>
				<p>
					Because you cannot change the assigned value to a variable declared with
					<span class="monoText">const</span>, operations such as t he following are disallowed:
				</p>
				<pre class="language-javascript">
							<code>
								const acceleration = 9.807;
								acceleration += 1; // returns an error
								acceleration ++; // also returns an error
							</code>
						</pre>
			</section>

			<section id="when_to_use_const" class="grid-item">
				<h4>When Should <span class="monoText">const</span> Be Used?</h4>
				<ul>
					<li>The keyword <span class="monoText">const</span> should be used as its name implies—when a variable should be a <span class="term">constant</span>.</li>
					<li>
						In other words,
						<span class="monoText">const</span> should be used when a variable and its value remain unchanged.
					</li>
					<li>Otherwise, use <span class="monoText">let</span>.</li>
				</ul>
			</section>

			<section id="difference_const_and_let" class="grid-item">
				<h4>
					What is the difference between
					<span class="monoText">const</span> and <span class="monoText">let</span> ?
				</h4>
				<p>Unlike <span class="monoText">let</span>, once a variable is declared and assigned a value with <span class="monoText">const</span>, the assignment is <em>permanent</em>. In other words, the variable's assigned value cannot be changed later down the program.</p>
				<pre class="language-javascript">
							<code>
								const acceleration = 9.807;
								acceleration = 10; // This returns an error
							</code>
						</pre>
			</section>

			<section id="declaring_with_var" class="grid-item">
				<h3>
					Declaring a Variable with
					<span class="monoText">var</span>
				</h3>
				<p>
					A third way to declare variables in JavaScript is with
					<span class="monoText">var</span>.
				</p>
				<pre class="language-javascript">
							<code>
								var mass = 4.5;
							</code>
						</pre>
			</section>

			<section id="regular_expressions_introduction" class="grid-item">
				<h2>Regular Expressions</h2>
				<p>A <span class="term">regular expression</span> is a sequence of characters instructing JavaScript on what to search for in a set of data. Regular expressions effectively allow us to describe patterns in string type data.</p>
				<p>
					There are two ways to create regular expressions: (1) with a
					<span class="term">regular expression constructor</span>
					or (2) with a
					<span class="term">regular expression literal</span>.
				</p>
				<p>
					The result from using a regular expression is a
					<span class="term">regex object</span>.
				</p>
			</section>

			<section id="regular_expression_constructor" class="grid-item">
				<h3>The Regular Expression Constructor</h3>
				<p>
					The regular expression constructor takes the form
					<code class="language-javascript">new RegExp(<em>pattern</em>[, <em>flags</em>])</code>.
				</p>
			</section>

			<section id="regular_expression_literal" class="grid-item">
				<h3>The Regular Expression Literal</h3>
				<p>
					The regular expression literal, on the other hand, takes the form
					<code class="language-javascript">/<em>pattern</em>/<em>flags</em></code>
				</p>
			</section>

			<section id="primitive_type_boolean" class="grid-item">
				<h2>JavaScript Booleans and Logic</h2>
				<h3>Primitive Type: Boolean</h3>
				<p>The primitive type <b>boolean</b> covers only 2 values: <span class="monoText">true</span> or <span class="monoText">false</span>.</p>
				<p>Because the boolean type has only two values, they are an effective way of representing strictly binary values:</p>
				<ul>
					<li>true or false</li>
					<li>yes or no</li>
					<li>1 or 0</li>
				</ul>
			</section>

			<section id="boolean_operators" class="grid-item">
				<h3>Boolean Operators</h3>
				<p><span class="term">Boolean operators</span> allow us to make simple decisions in JavaScript.</p>
			</section>

			<section id="comparison_operators" class="grid-item">
				<h4>Comparison Operators</h4>
				<p>
					Being able to compare values is critical to making simple decisions. The
					<span class="term">comparison operators</span>
					are what allow us to compare numbers.
				</p>
			</section>

			<section id="greater_than_operator" class="grid-item">
				<h5>
					The greater than operator
					<span class="monoText">></span>
				</h5>
				<p>
					The boolean operator
					<span class="monoText">></span> determines whether the first value is <em>greater than</em> the second value.
				</p>
				<pre class="language-javascript">
							<code>
								10 > 9 // returns true
								5 > 7 // returns false
								-1 > 0 // returns false
								-3 > -12 // returns true
							</code>
						</pre>
			</section>

			<section id="less_than_operator" class="grid-item">
				<h5>The less than operator <span class="monoText"><</span></h5>
				<p>
					The boolean operator
					<span class="monoText"><</span> determines whether the first value is <em>less than</em> the second value.
				</p>
				<pre class="language-javascript">
							<code>
								5 < 8 // returns true
								2 < 1 // returns false
								1 < 1 // returns false
							</code>
						</pre>
			</section>

			<section id="greater_than_or_equal_to_operator" class="grid-item">
				<h5>
					The greater than or equal to operator
					<span class="monoText">>=</span>
				</h5>
				<p>
					The boolean operator
					<span class="monoText">>=</span> determines whether or not the first value is <em>greater than or equal to</em> the second value.
				</p>
				<pre class="language-javascript">
							<code>
								7 >= 8 // returns false--7 is neither greater than nor equal to 8
								8 >= 8 // returns true--8 is not greater than 8, but it is equal to 8
								10 >= 7 // returns true--10 is not equal to 7, but it is greater than 8
							</code>
						</pre>
			</section>

			<section id="less_than_or_equal_to_operator" class="grid-item">
				<h5>
					The less than or equal to operator
					<span class="monoText"><=</span>
				</h5>
				<p>
					The boolean operator
					<span class="monoText"><=</span> determines whether or not the first value is <em>less than or equal to</em> the second value.
				</p>
				<pre class="language-javascript">
							<code>
								9 <= 10 // returns true; 9 is not equal to 10, but it is less than 10.
								10 <= 10 // returns true; 10 is not less than 10, but it is equal to 10. 
								11 <= 10 // returns false; 11 is neither less than nor equal to 10. 
							</code>
						</pre>
			</section>

			<section id="equality_operator" class="grid-item">
				<h5>The equality operator <span class="monoText">==</span></h5>
				<p>
					The equality operator
					<span class="monoText">==</span> determines whether two values are <em>equal in value</em>, but it does not check whether the values are <em>equal in type</em>.
				</p>
				<pre class="language-javascript">
							<code>
								7 == "7" // returns true; JavaScript forces the values into a common type
								0 == "s" // returns false
								0 == "" // returns true
								0 == false // returns true
								null == undefined // returns true
							</code>
						</pre>
			</section>

			<section id="strict_equality_operator" class="grid-item">
				<h5>
					The strict equality operator
					<span class="monoText">===</span>
				</h5>
				<p>
					The strict equality operator
					<span class="monoText">===</span> determines whether two values <em>equal in value</em> AND <em>equal in type</em>.
				</p>
				<pre class="language-javascript">
							<code>
								5 === 5 // returns true
								1 === 2 // returns false
								2 === "2" // returns false
								0 === false // returns false
								null === undefined // returns false
							</code>
						</pre>
			</section>

			<section id="nonequality_operator" class="grid-item">
				<h5>
					The Nonequality Operator
					<span class="monoText">!=</span>
				</h5>
				<p>
					The nonequality operator
					<span class="monoText">!=</span> determines whether two values are <em>nonequal in value</em>, but it does not determine whether the values are <em>nonequal in type</em>; this is the analog of the equality operator, <span class="monoText">==</span>.
				</p>
				<pre class="language-javascript">
							<code>
								null != undefined; // returns false
								2 != "2"; // returns false
								2 != 3; // returns true
								
							</code>
						</pre>
			</section>

			<section id="strict_nonequality_operator" class="grid-item">
				<h5>
					The Strict Nonequality Operator
					<span class="monoText">!==</span>
				</h5>
				<p>
					The strict nonequality operator
					<span class="monoText">!==</span> determines whether two values are <em>nonequal in value</em> and <em>nonequal in type</em>.
				</p>
				<pre class="language-javascript">
							<code>
								null !== undefined; // returns true
								2 !== "2"; // returns true
								2 !== 3; // returns true
							</code>
						</pre>
			</section>

			<section id="conditional_statements" class="grid-item">
				<h3>Conditional Statements</h3>
				<p>
					Logic provides the foundation to programs.
					<span class="term">Conditional statements</span> are what provide the necessary logic.
				</p>
			</section>

			<section id="if_statement" class="grid-item">
				<h4>The <span class="monoText">if</span> statement</h4>
				<p>
					The <em>if statement</em> tells JavaScript to run a given block of code <span class="term">if</span> a given condition is <span class="greenText">true</span>. If the condition is <span class="redText">false</span>, then the code block is never run. The <span class="monoText">if <em>statement</em></span>
					takes the following format:
				</p>
				<pre class="language-javascript">
							<code>
								if ("<em>condition-is-true</em>") {
									"<em>run-this-code-block</em>";
								}
							</code>
						</pre>
				<p>Examples:</p>
				<pre class="language-javascript">
							<code>
								if (2 > 1) {
									console.log("True");
								}
								// This code says, "If 2 is greater than 1, display in the console 'True.'"

								if (1 !== 1) {
									console.log("True");
								}
								// This code says, "If 1 is not equal to 1 in value or type, then display in the console 'True.'" Because the condition is false, the code block never runs.
							</code>
						</pre>
				<details>
					<summary>Common Code: Check if a Number is an Odd or Even Number</summary>
					<p>To check if a number is odd or even, we can use the following code:</p>
					<pre class="language-javascript">
							<code>
								let num = 39;
								if (num % 2 != 0) {
									console.log("Odd number");
								}
								// This returns "Odd number" in the console
							</code>
						</pre>
				</details>
			</section>

			<section id="else_if_statement" class="grid-item">
				<h4>The <span class="monoText">else if</span> Statement</h4>
				<p>The <em>else if statement</em> tells JavaScript: If the first condition (to the <em>if statement</em>) is <span class="greenText">true</span>, run the <em>if statement</em>'s block of code. If the first condition (to the <em>if statement</em>) is <span class="redText">false</span>, check this second condition (to the <em>else statement</em>), and if it is true, run the <em>else statement</em>'s block of code. The <em>else if</em> statement takes the following form:</p>
				<pre class="language-javascript">
							<code>
								if ("condition-is-true") {
									"run-this-block-of-code";
								}
								else if ("this-condition-is-true") {
									"run-this-block-of-code";
								}
							</code>
						</pre>
			</section>

			<section id="limitations_else_if" class="grid-item">
				<h5 class="warning-heading">
					&#9888; Warning: Limitation of
					<span class="monoText">else if</span> Statements
				</h5>
				<p>JavaScript will only look at the <em>else if statement</em>'s condition if the first condition, from the <em>if statement</em>, is <span class="redText">false</span>. This means that an <em>else if statement</em> must always accompany an <em>if statement</em>.</p>
			</section>

			<section id="multiple_else_ifs" class="grid-item">
				<h5>
					Multiple
					<span class="monoText">else if</span> Statements:
				</h5>
				<p>An <em>if statement</em> can be accompanied by multiple <em>else if</em> statements:</p>
				<pre class="language-javascript">
							<code>
								if ("condition1-is-true") {
									"run-this-code-block";
								}
								// Condition 1 is false? Check condition 2.
								else if ("condition2-is-true") {
									"run-this-code-block";
								}
								// Condition 2 is false? Check condition 3.
								else if ("condition3-is-true") {
									"run-this-code-block";
								}
							</code>
						</pre>
			</section>

			<section id="else_statement" class="grid-item">
				<h4>The <span class="monoText">else</span> Statement</h4>
				<p>The <em>else statement</em> acts like an "otherwise." I.e., the <em>else statement</em> effectively tells JavaScript that this is the code that should be run if all the conditions before it fail. In a way, it sort of sets the "default" instruction to a set of conditionals. The <em>else statement</em> takes the following form:</p>
				<pre class="language-javascript">
							<code>
								if ("condition1-is-true") {
									"run-this-block-of-code";
								}
								else {
									"run-this-block-of-code";
								}
							</code>
						</pre>
			</section>

			<section id="limitation_of_else" class="grid-item">
				<h5 class="warning-heading">
					&#9888; Warning: Limitation of
					<span class="monoText">else</span> Statements
				</h5>
				<p>Because JavaScript only executes an <em>else statement</em> after checking an <em>if statement</em>, the <em>else statement</em> must always be preceded by an <em>if statement</em> or an <em>else if statement</em>. Thus, an <em>else statement</em> can never stand on its own. Furthermore, because an <em>else statement</em> effectively provides the default, or fallback, instruction to JavaScript in a set of conditionals, there can only be <span class="term">one</span> <em>else statement</em> in a given block of conditionals.</p>
			</section>

			<section id="nesting_conditional_statements" class="grid-item">
				<h4>Nesting Conditional Statements</h4>
				<p>Conditional statements can be nested within conditional statements. For example, below is some code that attempts to verify a password.</p>
				<pre class="language-javascript">
							<code>
								let password;
								// First condition: Check if the password has at least 6 characters:
								if (password.length >= 6) {
								/* 
								If it meets this condition, run this code below.
								First condition: Check if the password contains spaces. We can do this by using indexOf. If it does not contain spaces, it will return -1. If it does contain spaces, it will return a number other than -1. 
								*/
									if (password.indexOf(' ') === -1) {
										console.log("Valid password!");
									}
								/* 
								If the password contains a space (i.e., the first condition is not strictly equal to 1, run this code below.)
								*/
									else {
										console.log("Password cannot contain a space.")
									}
								}
								/*
								If the password is not at least 6 characters (i.e., the first condition is not satisfied), run this code.
								*/
								else {
									console.log("Password must be longer.");
								}
							</code>
						</pre>
			</section>

			<section id="inherent_boolean_values" class="grid-item">
				<h4>Inherent Boolean Values</h4>

				<p>
					In JavaScript, all values have an inherently
					<span class="greenText">true</span> or <span class="redText">false</span> value. Values that are inherently <span class="redText">false</span>:
				</p>
				<ul>
					<li><span class="monoText">false</span></li>
					<li><span class="monoText">0</span></li>
					<li><span class="monoText">""</span> (an empty string)</li>
					<li><span class="monoText">null</span></li>
					<li><span class="monoText">undefined</span></li>
					<li><span class="monoText">NaN</span></li>
				</ul>
				<p>
					Every value other than the above has an inherently
					<span class="greenText">true</span> value. Example:
				</p>
				<pre class="language-javascript">
							<code>
								let x = 3;
								if (x) {
									console.log("true");
								}
								/*
								The console displays "true" because 3 is inherently true, the if statement's condition is satisfied, and so JavaScript executes its code block.
								*/

								let y = NaN;
								if (y) {
									console.log("true");
								}
								else {
									console.log("false");
								}
								/* The console displays "false" because NaN is inherently false---because the condition is not satisfied (the if statement's condition is false), the else statement's code block is run.
								*/
							</code>
						</pre>
			</section>

			<section id="logical_operators" class="grid-item">
				<h3>JavaScript Logical Operators</h3>
				<p>The <em>logical operators</em> provide a way to arrange, or connect, conditional statements. With the ability to connect and arrange conditional statements, we can write programs with more complex conditional statements. This in turn allows us to write more concise and efficient code.</p>
			</section>

			<section id="and_operator" class="grid-item">
				<h4>
					The <em>and</em> Operator:
					<span class="monoText">&&</span>
				</h4>
				<p>
					The <span class="monoText">&&</span> operator allows us to streamline nested
					<span class="italicsText">if statements:</span>
				</p>
				<pre class="language-javascript">
							<code>
								// Here is code that attempts to verify a password.
								let password = "masterProgrammer";

								/*
								First condition: Check if these two sub-expressions are true:

								(1) The password has at least 6 characters.

								(2) The password contains no spaces.
								*/

								if( password.length >= 6 && 
									password.indexOf(' ') === -1
								) {
									console.log("Valid password");
								}
								else {
									console.log("Invalid password");
								}
							</code>
						</pre>

				<p>The <em>and operator</em> <span class="monoText">&&</span> allows us to connect conditional statements into a single conditional expression, called a <span class="term">conditional AND expression</span>. We can connect as many conditional expressions (i.e., conditions) as we want with <span class="monoText">&&</span>. For the <em>conditional AND expression</em> to be true, all of its <span class="term">sub-expressions</span> (the connected conditions) must all be true. Thus, if a single sub-expression is false, the entire <em>conditional AND expression</em> is false. Example:</p>
				<pre class="language-javascript">
							<code>
								/*
								Condition 1: Check if these two sub-expressions are true:
									(1) Is 1 <= 4?
									(2) Is 'a' strictly equal to 'a'?
								*/
								if (1 <= 4 && 'a' === 'a') {
									console.log("true");
								}
								/*
								Default code: If Condition 1 is false, run this code block.
								*/
								else {
									console.log("false");
								}
								/*
								Running this code, the console returns true. Why is that? Because 1 <= 4 is true, and 'a' is strictly equal to 'a'.
								*/
							</code>
						</pre>
			</section>

			<section id="limitation_of_and" class="grid-item">
				<h5 class="warning-heading">
					&#9888; Warning: Limitation of
					<em>Conditional AND Expressions</em>
				</h5>
				<p>Remember, if just <span class="underlineText">one</span> of the sub-expressions is <span class="redText">false</span>, then the entire <span class="italicsText">conditional AND statement</span> is <span class="redText">false.</span> Example:</p>
				<pre class="language-javascript">
								<code>
									/*
									Condition 1: Check if these two sub-expressions are true:
										(1) Is 9 <= 10?
										(2) Is 'a' strictly equal to 'a'?
									*/
									if (9 > 10 && 'a' === 'a') {
										console.log("true");
									}
									/*
									If Condition 1 is false, run this code block.
									*/
									else {
										console.log("false");
									}
									/*
									Here, the console returns "false". Why? Because even though sub-expression (2) is true, sub-expression (1) is false, so the entire condition (1), a <span class="italicsText">conditional AND statement</span>, is false. Because condition (1) is false, the <span class="italicsText">else statement</span>'s code block is run.
									*/
								</code>
							</pre>
			</section>

			<section id="or_operator" class="grid-item">
				<h3>
					The <span class="italicsText">OR</span> Operator:
					<span class="monoText">||</span>
				</h3>
				<p>The <span class="monoText">||</span> operator allows us to connect sub-expressions into a single conditional expression, called a <span class="term">conditional OR expression</span>. If just <span class="underlineText">one</span> of the sub-expressions is <span class="greenText">true</span>, then the entire <span class="italicsText">OR expression</span> is <span class="greenText">true</span>. Example:</p>
				<pre class="language-javascript">
							<code>
								1 !== 1 || 10 === 10;
								// Returns true, since one of the sub-expressions, 10 === 10, is true.
								10 / 2 === 5 || null;
								// Returns true, because one of the sub-expressions, 10 /2 === 5, is true.
								0 || undefined;
								// Returns false, because both 0 and undefined are inherently false (i.e., none of the sub-expressions are true.)
							</code>
						</pre>
				<p>
					Below is a code example using the
					<span class="monoText">||</span> operator.
				</p>
				<pre class="language-javascript">
							<code>
								/*
								Suppose we provide a service that gives users under 6 or over 60 a discount. We want to let the user know, after inputting their age, that they get a discount.
								*/
								let age = 64;
								/*
								First condition: Check if <span class="underlineText">at least one</span> of these sub-expressions is true:
									(1) The person's age is less than or equal to 6. 
									(2) The person's age is greater than or equal to 60.
								*/
								if (
									age <= 6 ||
									age >= 60
								) {
									console.log("You get a discount!");
								}
								// If none of the above sub-expressions is true, run this code block.
								else {
									console.log("Proceeding to checkout")
								}
							</code>
						</pre>
			</section>

			<section id="not_operator" class="grid-item">
				<h3>
					The <span class="italicsText">NOT</span> Operator:
					<span class="monoText">!</span>
				</h3>
				<p>
					The <span class="italicsText">NOT operator</span> reverses the values for a conditional expression. Thus, if a conditional expression is <span class="greenText">true</span>, if the
					<span class="italicsText">NOT operator</span>
					<span class="monoText">!</span> is attached to the expression, then the conditional expression returns the opposite—<span class="redText">false</span>. Illustration:
				</p>
				<pre class="language-javascript">
							<code>
								!null; // Returns true; null is an inherently false value, and so its opposite is true.
								!0; // Returns true
								!'' // Returns true
								!45 // Returns false
							</code>
						</pre>
				<p>
					We can attach the
					<span class="italicsText">NOT operator</span> to <span class="italicsText">AND conditionals</span> or <span class="italicsText">OR conditionals</span> :
				</p>
				<pre class="language-javascript">
							<code>
								/*
								Suppose we are running a bubble tea stand. We only have two flavors: taro or tea.
								*/
								let flavor = "blueberry";
								// Condition 1: If the flavor inputted by the user is NOT "taro" or "tea", then run this code block.
								if (
									!(flavor === "taro" || flavor === "tea")
								) {
									console.log("Sorry, we only have taro and tea at the moment.");
								}
								// Default: Otherwise, run this code block.
								else {
									console.log(`One ${flavor} bubble tea, coming right up!`);
								}
							</code>
						</pre>
			</section>

			<section id="operator_precedence" class="grid-item">
				<h3>Logical Operator Precedence</h3>

				<p>
					JavaScript follows a strict rule, called
					<span class="term">operator precedence</span>, when evaluating complex conditional statements. For example, what does JavaScript return for the following:
				</p>
				<pre class="language-javascript">
							<code>
								let x = 7;
								x == 7 || x === 3 && x > 10;
							</code>
						</pre>
				<p>
					<span class="italicsText">Operator precedence</span>
					applies:
				</p>
				<ul>
					<li>Conditional expressions contained inside parantheses are always evaluated first.</li>
					<li>The <span class="italicsText">NOT operator</span> is evaluated before the <span class="italicsText">AND operator</span>.</li>
					<li>The <span class="italicsText">AND operator</span> is evaluated before the <span class="italicsText">OR operator</span>.</li>
				</ul>
				<p>Thus, in the above code, JavaScript evaluates the above code as:</p>
				<pre class="language-javascript">
							<code>
								let x = 7;
								(x == 7 || x === 3) && (x > 10);
							</code>
						</pre>
				<p>If we want to change this behavior, we need to use parentheses:</p>
				<pre class="language-javascript">
							<code>
								let x = 7;
								(x == 7) || (x === 3 && x > 10);
							</code>
						</pre>
			</section>

			<section id="switch_statement" class="grid-item">
				<h3>The <span class="monoText">switch</span> Statement</h3>
				<p>The <span class="italicsText">switch statement</span> allows us to perform different actions based on different conditions. The switch statement takes the following form:</p>
				<pre class="language-javascript">
							<code>
								// First, evaluate the <span class="italicsText">expression</span>.
								switch ("<span class="italicsText">expression</span>") {
								// Next, compare the returned value with each of the values in the cases below.
								// If there is a match, run that case's code block.
									case "1":
										"Run this code block";
									break;

									case "2":
										"Run this code block";
									break;

									case "3":
										"Run this code block";
									break;
								// If there is no match, run the default's code block.
									default:
										"Run this code block"
								}
							</code>
						</pre>
				<p>For example, consider the following code:</p>
				<pre class="language-javascript">
							<code>
								/*
								Suppose we have a program where the user enters a number from 1 to 7, and gets back out a day of the wee. We could do the following:
								*/

								let day = 8;
								if (day === 1) {
									console.log("Monday");
								}
								else if (day === 2) {
									console.log("Tuesday");
								}
								else if (day === 3) {
									console.log("Wednesday");
								}
								else if (day === 4) {
									console.log("Thursday");
								}
								else if (day === 5) {
									console.log("Friday");
								}
								else if (day === 6) {
									console.log("Saturday");
								}
								else if (day === 7) {
									console.log("Sunday");
								}
								else {
									console.log("Invalid---enter a number from 1 to 7.");
								}
							</code>
						</pre>
				<p>The above code accomplishes the task, but it can be written much more compactly with a switch statement:</p>
				<pre class="language-javascript">
							<code>
								let day = 1;
								switch (day) {
									case 1: // If the value for day is 1, run this block of code.
										console.log("Monday");
										break;
									case 2: // If the value for day is 2, run this block of code. 
										console.log("Tuesday");
										break; 
									case 3: // If the value for day is 3, run this block of code.
										console.log("Wednesday");
										break; 
									case 4: // If the value for day is 4, run this block of code.
										console.log("Thursday");
										break; 
									case 5: // If the value for day is 5, run this block of code.
										console.log("Friday");
										break;
									case 6: // If the value for day is 6, run this block of code.
										console.log("Saturday");
										break; 
									case 7: // If the value for day is 7, run this block of code.
										console.log("Sunday");
										break;
									default: // If there are no matching cases, run this block of code.
										console.log("Please enter a number from 1 to 7.")
								}
								// Note how each of the cases contains a "break" statement. This is because without the break statement, the moment JavaScript arrives at a matching case, it will run the code block for everything thereafter. This default behavior is prevented by using the <span class="italicsText">break statement</span>.
							</code>
						</pre>
			</section>

			<section id="ternary_operator" class="grid-item">
				<h3>The <span class="italicsText">Ternary</span> Operator</h3>
				<p>
					If we have a single
					<span class="italicsText">if statement</span> accompanied with an <span class="italicsText">else statement</span>, we can write the statements as a single line of code with the <span class="term">ternary operator</span>. The <span class="italicsText">ternary operator</span> takes the following form:
				</p>
				<figure>
					<code class="language-javascript"
						>condition ?
						<span class="greenText">("code block for when condition is true")</span>
						:
						<span class="redText">("code block for when condition is false")</span></code
					>
				</figure>
				<p>For example:</p>
				<pre class="language-javascript">
							<code>
								/*
								Here is a program that displays in the console "Lucky Number 7" if the user picks 7. 
								*/
								let num = 7;
								if (num === 7) {
									console.log("Lucky Number 7!");
								}
								else {
									console.log("Sorry, no lucky number.");
								}

								// We can write the above with a <span class="italicsText">switch statement</span>:
								let num = 7;
								num === 7 ? console.log("Lucky Number 7!") : console.log("Sorry, no lucky number.");
							</code>
						</pre>
			</section>

			<section id="for_loop" class="grid-item">
				<h4>The <span class="monoText">for</span> Loop</h4>
				<p>The <span class="monoText">for</span> loop tells JavaScript to loop through a code block a number of times (or infinitely). The <span class="monoText">for</span> loop takes the following form:</p>
				<pre class="language-javascript">
							<code>
								for (
									[<span class="greyText italicsText">initial expression</span>];
									[<span class="greyText italicsText">condition</span>];
									[<span class="greyText italicsText">final expression</span>];
								) {
									<span class="greyText italicsText">statement</span>
								}
							</code>
						</pre>
				<p>
					The <span class="term">initial expression</span> is the statement that JavaScript executes exactly once before entering the <span class="monoText">for</span> loop. E.g., declaring a variable to be used in the <span class="italicsText">condition</span> and <span class="italicsText">final expression</span>. Most often, the initial expression is used to create a <span class="monoText">for</span> loop's <span class="italicsText">counter</span>. The <span class="term">condition</span>, or <span class="term">test statement</span>, is a boolean expression that determines whether JavaScript should proceed with the loop. The condition is checked before each execution of the loop. If the condition is <span class="greenText">true</span>, JavaScript continues (the loop executes). If the condition is <span class="redText">false</span>, JavaScript stops, and goes to the next statement in the program (the loop terminates). The
					<span class="term">final expression</span> is the expression that JavaScript evaluates after each loop iteration. Usually, the <span class="italicsText">final expression</span> contains code to update the counter variable declared in the <span class="italicsText">initial expression</span>. The <span class="monoText">for</span> loop's <span class="term">statement</span> is the code that the loop executes, or, more generally, the code we want repeated.
				</p>
			</section>

			<section id="incrementing_counter" class="grid-item">
				<p class="subheading-1">Incrementing Counter</p>
				<p>Here is a simple incrementing counter in JavaScript.</p>
				<pre class="language-javascript">
							<code>
								for (let i = 0; i < 3; i++) {
									console.log("execution");
								}
								/*
								This loop works as such:

								Initial Expression: Declare a variable i, and assign it 0.
								Check condition: Is i less than 3? Yes, 0 < 3. Update counter (i is now 1), and run the loop. 
								Console output: "execution"

								Check condition: Is i less than 3? Yes, 1 < 3. Update counter (i is now 2), and run the loop. 
								Console output: "execution"

								Check condition: Is i less than 3? Yes, 2 < 3. 
								Update counter (i is now 3), and run the loop. 
								Console output: "execution"

								Check condition: is i less than 3? No, 3 ≮ 3. 
								Terminate loop. 

								The console should display:
								"execution"
								"execution"
								"execution"
								*/
							</code>
						</pre>
			</section>

			<section id="common_for_loop_mistakes" class="grid-item">
				<h5>Common <span class="monoText">for</span> Loop Mistakes</h5>
				<p>If a variable is declared with <span class="monoText">let</span> in a <span class="monoText">for</span> loop's <span class="italicsText">initial expression</span>, the variable is scoped to the loop—it is destroyed once the loop has finished executing. If a <span class="monoText">for</span> loop's condition is left out, JavaScript will interpret the loop's "condition" as always true, resulting in an <a href="#infinite_loops">infinite loop</a>.</p>
			</section>

			<section id="for_loops_and_arrays" class="grid-item">
				<h3><span class="monoText">for</span> Loops and Arrays</h3>
				<p>We can use a <span class="monoText">for</span> loop to iterate over an array. For example, iterating over an array of strings:</p>
				<pre class="language-javascript">
							<code>
								const vectors = ['velocity', 'acceleration', 'weight'];
								for (let i = 0; i < vectors.length; i++) {
									console.log(i, vectors[i]);
								}
								/*
								The above code outputs the following to the console:
								0 velocity
								1 acceleration
								2 weight
								*/
							</code>
						</pre>
				<p>Here is another example, iterating over an array of numbers:</p>
				<pre class="language-javascript">
							<code>
								/*
								Here is a program that adds pairs of primes, one after another, and (1) divides by them two, and (2) returns the distance between the two primes.
								*/
								let primes = [1, 3, 5, 7, 11];
								for (let i = 0; i < primes.length - 1; i++) {
									console.log(`Pair of primes: ${primes[i]} and ${primes[i + 1]}`)
									console.log(`Half of the sum: ${(primes[i] + primes[i + 1]) / 2}`)
									console.log(`Distance: ${primes[i + 1] - primes[i]}`);
								}
								/*
								The above code outputs the following to the console:
								Pair of primes: 1 and 3
								Half of the sum: 2
								Distance: 2
								Pair of primes: 3 and 5
								Half of the sum: 4
								Distance: 2
								Pair of primes: 5 and 7
								Half of the sum: 6
								Distance: 2
								Pair of primes: 7 and 11
								Half of the sum: 9
								Distance: 4
								*/
							</code>
						</pre>
			</section>

			<section id="nested_loops" class="grid-item">
				<h5>
					Style Convention: Variable Names for
					<span class="monoText">for</span> Loops
				</h5>

				<p>
					It is a common convention to use i for a
					<span class="monoText">for</span> loop's incrementing variable, then j and k for inner loops.
				</p>
				<p>This convention originates in mathematics, where $i$ is used for the first index in summation notation, $j$ for the second, etc.:</p>
				<figure>
					<p>$$\sum_{i=1}^{n}i = \frac{n^2+n}{2}$$</p>
				</figure>
			</section>

			<section id="nested_for_loops" class="grid-item">
				<h3>Nested <span class="monoText">for</span> Loops</h3>
				<p>We can nest a <span class="monoText">for</span> loop inside another <span class="monoText">for</span> loop:</p>
				<pre class="language-javascript">
							<code>
								for (let i = 1; i <= 3; i++) {
									console.log('Outer Loop:', i);

									for (let j = 1; j <= 2; j++) {
										console.log(' Inner Loop:', j);
									}
								}
								/*
								The above code will out put to the console:
								Outer Loop: 1
								Inner Loop: 1
								Inner Loop: 2
								Outer Loop: 2
								Inner Loop: 1
								Inner Loop: 2
								Outer Loop: 3
								Inner Loop: 1
								Inner Loop: 2
								*/
							</code>
						</pre>
				<p>Nested <span class="monoText">for</span> loops are useful for targeting nested arrays:</p>
				<pre class="language-javascript">
							<code>
								/*
								Here is an array of number arrays. Suppose we want to find the sum of the numbers in each of the array.
								*/
								let arrNum = [
									[4, 32, 8, 4],
									[64, 8, 32, 2],
									[8, 32, 16, 4],
									[2, 8, 4, 2]
								];
								// First, we need to declare a variable that will store the sums we want.
								let sumNum = 0;
								// Next, we need to loop through the outer array (by targeting each of the individual arrays)
								for (let i = 0; i < arrNum.length; i++) {
								/*
								The outer loop loops through each of the nested arrays. There are 4 arrays (represented by arrNum.length), so the loop first looks at array of index 0, then 1, then 2, then 3, then 4. Now we need to loop through each of the elements in the nested array. First, we declare a variable named nestedArrNum, which will store each of the targeted nested arrays.
								*/
									let nestedArrNum = arrNum[i];
								/* 
								For the targeted nested array with index 0, loop through each of the elements, then continue until i is less than arrNum.length (all nested arrays have been looped through):
								*/
									for (let j = 0; j < nestedArrNum.length; j++) {
										// Then add to sumNum each element of the targeted nested array.
										sumNum += nestedArrSum[j]; 
									}
									console.log(sumNum);
								}
								/*
								The above will output to the console:
								48
								154
								214
								230
								*/
							</code>
						</pre>
			</section>

			<section id="when_to_use_which_loop" class="grid-item">
				<h4>
					When should we use a
					<span class="monoText">while</span> loop instead of a <span class="monoText">for</span> loop?
				</h4>
				<p>The <span class="monoText">while</span> loop is best used when we do not know how many times the loop should run. This is accomplished with the following form:</p>
				<pre class="language-javascript">
								<code>
									while (<span class="greyText italicsText">condition</span>) {
									
									<span class="greyText italicsText">code block that eventually causes the condition to be false</span>

									}
								</code>
							</pre>
			</section>

			<section id="while_loop_introduction" class="grid-item">
				<h3>The <span class="monoText">while</span> Loop</h3>
				<p>The <span class="monoText">while</span> loop, in some situations, is a more efficient version of a <span class="monoText">for</span> loop. The <span class="monoText">while</span> loop takes the following form:</p>
				<pre class="language-javascript">
							<code>
								while (<span class="greyText italicsText">condition</span>) {
									<span class="greyText italicsText">code block</span>;
								}
							</code>
						</pre>
				<p>In some cases, a <span class="monoText">while</span> loop may be more efficient than a <span class="monoText">for</span> loop:</p>
				<pre class="language-javascript">
								<code>
									// Here is a for loop:
									for (let i = 0; i < 3; i++) {
										console.log(`for loop: ${i}`);
									}
									// The same structure, with a while loop:
									let j = 0;
									while (j < 3) {
										console.log(`while loop: ${j}`);
										j++
									}
									/*
									This outputs the following to the console:
									for loop: 0
									for loop: 1
									for loop: 2

									while loop: 0
									while loop: 1
									while loop: 2
									*/
								</code>
							</pre>
			</section>

			<section id="break_keyword" class="grid-item">
				<h3>The <span class="monoText">break</span> Keyword</h3>
				<p>The <span class="monoText">break</span> keyword is a special keyword in JavaScript that tells JavaScript to break out of a loop (i.e., terminate the loop). This is often used to terminate infinite loops or loops at risk of infinite iteration. The keyword is often used in the following form:</p>
				<pre class="language-javascript">
							<code>
								while (<span class="greyText italicsText">condition is true</span>) {
									if (<span class="greyText italicsText">condition</span>) break;
									<span class="greyText italicsText">code block</span>;
								}
							</code>
						</pre>
			</section>

			<section id="for_of_loop" class="grid-item">
				<h3>The <span class="monoText">for...of</span> Loop</h3>
				<p>
					The
					<span class="monoText">for<span class="greyText italicsText">...</span>of</span>
					loop is a more efficient way to loop through an
					<span class="term">iterable</span>. An <span class="term">iterable</span> is an object that has properties and can be looped through or iterated (e.g., an <a href="#arrays_introduction">array</a>). The
					<span class="monoText">for<span class="greyText italicsText">...</span>of</span>
					loop takes the following form:
				</p>
				<pre class="language-javascript">
							<code>
								for (<span class="greyText italicsText">variable-name</span> of <span class="greyText italicsText">iterable</span>) {
									<span class="greyText italicsText">code block</span>;
								}
							</code>
						</pre>
				<p>Here is an example:</p>
				<pre class="language-javascript">
							<code>
								/*
								We want to display in the console each of the elements in the array <span class="italicsText">iterable</span>. One way to do this is with a regular for loop.
								*/
								let iterable = ['A', 'B', 'C', 'D'];
								for (let i = 0; i < iterable.length; i++) {
									console.log(iterable[i]);
								}
								/*
								We can do this more efficient (i.e., with less code) with a for of loop.
								*/
								for (let element of iterable) {
									console.log(element);
								}
								/*
								The word "element" is simply the variable name we use to store the value or property in the iterable. It can be anything, but the most common names are "element", "value", or "i".
								*/
							</code>
						</pre>
			</section>

			<section id="warning_for_of_loop" class="grid-item">
				<h4><span class="monoText">for...of</span> Loops and Objects</h4>
				<p>
					You cannot use a
					<span class="monoText">for<span class="greyText">...</span>of</span>
					loop with an
					<a href="#objects_introduction">object</a> directly. This is because objects are <span class="underlineText">not iterable</span>.
				</p>
				<pre class="language-javascript">
							<code>
								/*
								Say we want to display in the console each of the key value pairs in an object called <span class="italicsText">vectors</span>:
								*/
								const vectors = {
									velocity: 9.5,
									acceleration: 8.2,
									weight: 44.4,
									momentum: 52.3
								};
								for (let values of vectors) {
									console.log(values);
								}
								// This displays a TypeError in the console: vectors is not iterable
							</code>
						</pre>
				<p>
					To iterate over an object's keys, we need to use the
					<span class="monoText">object.keys(<span class="greyText italicsText">object-name</span>)</span>
					and the
					<span class="monoText">object.values(<span class="greyText italicsText">object-name</span>)</span>
					methods:
				</p>
				<pre class="language-javascript">
							<code>
								const vectors = {
									velocity: 9.5,
									acceleration: 8.2,
									weight: 44.4,
									momentum: 52.3
								};
								for (let prop of Object.keys(vectors)) {
									console.log(elements);
								}
								for (let values of Object.values(vectors)) {
									console.log(values);
								}
								/*
								The above outputs the following: 

								velocity
								acceleration
								weight
								momentum
								9.5
								8.2
								44.4
								52.3
								*/
							</code>
						</pre>
				<p>
					The problem: We can only iterate through either the object's values or the object's keys. Alternatively, we can iterate over an object without with a
					<span class="monoText">for<span class="greyText italicsText">...</span>in</span>
					loop.
				</p>
			</section>

			<section id="for_in_loop" class="grid-item">
				<h3>The <span class="monoText">for...in</span> Loop</h3>
				<p>
					The
					<span class="monoText">for<span class="greyText italicsText">...</span>in</span>
					loop allows us to loop through the properties of an
					<a href="#objects_introduction">object</a>. It takes the following form:
				</p>
				<pre class="language-javascript">
							<code>
								for (<span class="greyText italicsText">variable-name</span> in <span class="greyText italicsText">object-name</span>) {
									<span class="greyText italicsText">code block</span>;
								}
							</code>
						</pre>
				<p>Here is an example:</p>
				<pre class="language-javascript">
							<code>
								/*
								Here is an object with some common mathematical constants. We want to output in the console both the object's properties (i.e., the keys and their assigned values).
								*/
								let mathConstants = {
									tau: 6.28,
									aperys: 1.20,
									euler_mascheroni: 0.57,
									gauss: 0.83
								};
								// Using a for...in loop:
								for (let prop in mathConstants) {
									console.log(prop + ': ' + mathConstants[prop]);
								}
								/*
								This outputs to the console:
								tau: 6.28
								aperys: 1.2
								euler_mascheroni: 0.57
								gauss: 0.83
								*/
							</code>
						</pre>
			</section>

			<section id="for_in_loops_arrays" class="grid-item">
				<h5><span class="monoText">for...in</span> Loops and Iterables</h5>
				<p>
					It is best practice not to use a
					<span class="monoText">for<span class="greyText italicsText">...</span>in</span>
					loop for arrays. This is because the
					<span class="monoText">for<span class="greyText italicsText">...</span>in</span>
					loop is implemented in JavaScript specifically to loop through an object's properties, and that iteration is not guaranteed to be in order (and order matters for iterables like arrays). In sum: Do not use a
					<span class="monoText">for<span class="greyText italicsText">...</span>in</span>
					loop for iterables—use a
					<span class="monoText">for<span class="greyText italicsText">...</span>of</span>
					loop.
				</p>
			</section>

			<section id="infinite_loops" class="grid-item">
				<h3>Infinite Loops</h3>
				<p>An <span class="term">infinite loop</span> is a loop that never ends. Infinite loops have their place in programming, but before writing an infinite loop, we need to always check why we're using an infinite loop in the first place. Here is an example:</p>
				<pre class="language-javascript">
							<code>
								for (let i = 5; i >= 0; i++) {
									<span class="greyText italicsText">code block</span>
								}
								/* This is an infinite loop. i is assigned the value 5, the condition checks if i is greater than or equal to 0, and if it is, i is incremented by 1. An infinite loop occurs because i will always be greater than 0 (the condition is always true), so JavaScript never escapes the loop, and the code block is executed an infinite amount of times (or, more realistically, however long the machine can handle).
								*/
							</code>
						</pre>
			</section>

			<section id="arrays_introduction" class="grid-item">
				<h2>Data Structures: Arrays</h2>
				<h3>What Are <span class="italicsText">Arrays</span>?</h3>
				<p><span class="term">Arrays</span> are the simplest <span class="italicsText">data structure</span>; they are a collection of values, where <span class="italicsText">order matters</span>. Examples of an array include: list of comments on a post, a collection of levels in a game, or a playlist of songs. Every value can be collected and placed in an order. The resulting ordered collection is called an <span class="italicsText">array</span>. Arrays can also collect and order other arrays.</p>
			</section>

			<section id="creating_arrays" class="grid-item">
				<h4>Creating Arrays</h4>

				<p>
					To create an array in JavaScript, we use square brackets
					<span class="monoText">[]</span>. Here is an empty array:
				</p>
				<pre class="language-javascript">
						<code>
							let special_numbers = [];
						</code>
					</pre>
				<p>An array of strings:</p>
				<pre class="language-javascript">
						<code>
							let colors = ['red', 'orange', 'blue', 'green'];
						</code>
					</pre>
				<p>An array of numbers:</p>
				<pre class="language-javascript">
						<code>
							let primes = [1, 3, 5, 7, 11];
						</code>
					</pre>
				<li>A mixed array:</li>
				<pre class="language-javascript">
						<code>
							let randomStuff = [true, 68, "bird", null];
						</code>
					</pre>
			</section>

			<section id="array_indices" class="grid-item">
				<h4>Indices in an Array</h4>
				<p>The values in an array are <span class="term">indexed</span>, meaning that each value in the array has an <span class="term">index</span>, or position within the array, starting from 0. So, for example:</p>
				<pre class="language-javascript">
						<code>
							let colors = ['red', 'orange', 'yellow', 'blue'];
							colors[0] // returns 'red'
							colors[1] // returns 'orange'
							colors[2] // returns 'yellow'
							colors[3] // returns 'blue'
						</code>
					</pre>
			</section>

			<section id="methods_and_arrays" class="grid-item">
				<h4>Methods and Arrays</h4>
				<p><a>Methods</a> an be applied to arrays, much like how they can be applied to strings and variables. We can find the length of an array (how many values it holds) with the <span class="monoText">.length</span> method.</p>
				<pre class="language-javascript">
						<code>
							let colors = ['red', 'orange', 'yellow', 'blue'];
							colors.length; // Returns 4, the array named <span class="italicsText">colors</span> contains 4 values.
						</code>
					</pre>
				<p>If we want to get the last value in an array:</p>
				<pre class="language-javascript">
						<code>
							let colors = ['red', 'orange', 'yellow', 'blue'];
							colors[colors.length - 1] // returns 'blue';
							/*
							This works because colors.length returns a number value. That number value is 4, the number of values in the array. Subtract 1, and you have the number 3. So, the code is telling JavaScript, get the value with index of 3 in the array of colors (the index of 3 is the last item in the array.)
							*/
						</code>
					</pre>
			</section>

			<section id="modifying_arrays" class="grid-item">
				<h3>Modifying Arrays</h3>
				<p>Say that we've set an array. We can change the values inside that array by going back and manually changing them, but that would be horribly inefficient (and you likely do no want to do that for a very large program). Instead of manually changing the values in the array, we can use their indices:</p>
				<pre class="language-javascript">
						<code>
							let colors = ['red', 'blue', 'green'];
							colors[0] = 'purple';
							colors[1] = 'violet';
							colors[2] = 'black';
							// The above will change the array <span class="italicsText">colors</span> to the following:
							colors = ['purple', 'violet', 'black'];
						</code>
					</pre>
				<p>We can also use methods to change the values in an array:</p>
				<pre class="language-javascript">
						<code>
							// Here is our initial shopping list
							shoppingList = ['Bud Light', 'Merlot', 'Vodka', 'Tequila'];

							// Guest called, wants Cabernet, not Merlot: 
							shoppingList[1] = 'Cabernet';
							// Another guest called, wants Rum, not Tequila:
							shoppingList[shoppingList.length - 1] = 'Rum';
							// Yet another guest called, requesting Tequila to be added
							shoppingList[shoppingList.length] = 'Tequila';

							/* From the above changes, the array <span class="italicsText">shoppingList</span> now looks like:
							shoppingList = ['Bud Light', 'Cabernet', 'Vodka', 'Rum', 'Tequila']
							*/
						</code>
					</pre>
			</section>

			<section id="push()_method" class="grid-item">
				<h4>
					Adding a Value to the End of an Array:
					<span class="monoText">push()</span>
				</h4>
				<p>The <span class="monoText">push()</span> method adds one or more elements to the end of an array, and returns the new length of the array.</p>
				<pre class="language-javascript">
						<code>
							let vectors = ['w', 'x', 'y'];
							vectors.push('z');

							/* Vectors is now changed:
							vectors = ['w', 'x', 'y', 'z']
							*/
						</code>
					</pre>
			</section>

			<section id="pop()_method" class="grid-item">
				<h4>
					Removing a Value from the End of an Array:
					<span class="monoText">pop()</span>
				</h4>
				<p>The <span class="monoText">pop()</span> method removes a value at the end of an array.</p>
				<pre class="language-javascript">
						<code>
							let procedures = ['w', 'x', 'y', 'z'];
							procedures.pop('z');
							/*
							The array <span class="italicsText">procedures</span> has changed to:
							procedures = ['w', 'x', 'y']
							*/
						</code>
					</pre>
			</section>

			<section id="shift()_method" class="grid-item">
				<h4>
					Remove a Value from the Start of an Array:
					<span class="monoText">shift()</span>
				</h4>
				<p>The <span class="monoText">shift()</span> method removes a value from the start of an array:</p>
				<pre class="language-javascript">
						<code>
							let procedures = ['w', 'x', 'y', 'z'];
							procedures.shift('w');
							/*
							The array <span class="italicsText">procedures</span> has now changed to:
							procedures = ['x', 'y', 'z']
							*/
						</code>
					</pre>
			</section>

			<section id="unshift()_method" class="grid-item">
				<h4>
					Add a Value to the Start of an Array:
					<span class="monoText">unshift()</span>
				</h4>
				<p>The <span class="monoText">unshift()</span> method adds a value to the start of an array:</p>
				<pre class="language-javascript">
						<code>
							let procedures = ['w', 'x', 'y', 'z'];
							procedures.unshift('v');
							/*
							The <span class="italicsText">procedures</span> array has now changed to:
							procedures = ['v', 'w', 'x', 'y', 'z']
							*/
						</code>
					</pre>
			</section>

			<section id="concat()_method" class="grid-item">
				<h4>
					Merging or Combining Arrays:
					<span class="monoText">concat()</span>
				</h4>
				<p>
					The <span class="monoText">concat()</span> method
					<span class="underlineText">creates a new array</span>
					from merging two arrays; there is no change to the original.
				</p>
				<pre class="language-javascript">
						<code>
							let x = ['a', 'b', 'c'];
							let y = ['d', 'e', 'f'];
							let x_and_y = x.concat(y);
							console.log(x_and_y);
							/*
							The above code creates a new array called <span class="italicsText">x_and_y</span>, from the arrays <span class="italicsText">x</span> and <span class="italicsText">y</span>:
							x_and_y = ['a', 'b', 'c', 'd', 'e', 'f']
							*/
						</code>
						</pre>
				<p>
					When using the <span class="monoText">concat()</span> method, <span class="underlineText">order matters</span>. So, for example, suppose you have the following: <code class="language-javascript">array1.concat(array2).concat(array3)</code>The new array will look like:
					<code class="language-javascript">merged_array = [ array1-values --> array2-values --> array3-values ]</code>
				</p>
			</section>

			<section id="includes()_method" class="grid-item">
				<h4>
					Looking for a Value in an Array:
					<span class="monoText">includes()</span>
				</h4>
				<p>The <span class="monoText">includes()</span> method is a Boolean method—it returns either <span class="greenText">true</span> or <span class="redText">false</span>. If the value is found in the array, the method returns <span class="greenText">true</span>. If the value is not found in the array, the method returns <span class="redText">false</span>.</p>
				<pre class="language-javascript">
						<code>
							let subjects = ['math', 'physics', 'cs', 'chemistry'];
							subjects.includes('physics'); 
							// This returns true, because the value 'physics' is inside the array <span class="italicsText">subjects</span>.
						</code>
						</pre>
				<p>The <span class="monoText">includes()</span> method can also take a number as a second argument. The number passed in represents the <span class="italicsText">starting index</span> for JavaScript's search. By passing in a number $x$, we essentially ask JavaScript: "Is the value contained in the part of the array starting from index $x$? For example:</p>
				<pre class="language-javascript">
						<code>
							let var_Array = ['w', 'x', 'y', 'z'];
							var_Array.includes('w', var.Array.length / 2);
							/*
							The above code essentially asks JavaScript:

							"JavaScript, is this true or false:
							The value 'w' is inside the array, and, 
							more specifically, in the part of the array starting from index = 2."

							This returns false, since 'w' is in the first half of the array, starting from index = 0.
							*/
						</code>
						</pre>
			</section>

			<section id="indexOf()_array_method" class="grid-item">
				<h4>Return the <span class="italicsText">index</span> of a Value in an Array</h4>
				<p>The <span class="monoText">indexOf()</span> method works in the same way with arrays as it does with strings. In other words, the <span class="monoText">indexOf()</span> method finds the index of a value in the array. If the method finds the value, it returns its index (an integer $x$, where $x \geq 0$). If the method does not find the value, it returns -1. Like the <span class="monoText">includes()</span> method, we can pass through a second argument, an integer, into the method's arguments, to specify where the method should operate.</p>
				<pre class="language-javascript">
					<code>
						let frequencies = ['1Mhz', '3Mhz', '7Mhz', '15Mhz'];

						frequencies.indexOf('1Mhz'); 
						// This returns 0, the index of '1Mhz'
						
						frequencies.indexOf('3Mhz', frequencies.length / 2);
						// This returns -1, because we told JavaScript to only search for '3Mhz' in the part of the array starting from index = 2, and there is no such value in that part of the array.

						frequencies.indexOf('7Mhz', frequencies.length / 2); 
						// This returns 2. We told JavaScript, "Search for '7Mhz' in the part of the array starting from index = 2. JavaScript found the value, and returned its index, 2."
					</code>
					</pre>
			</section>

			<section id="reverse()_method_arrays" class="grid-item">
				<h4>
					Reverse the Values in an Array:
					<span class="monoText">reverse()</span>
				</h4>
				<p>The <span class="monoText">reverse()</span> method changes the original array by reversing the order of its values. Note that the <span class="monoText">reverse()</span> method changes the original array; once applied, the original array is replaced by the new array resulting from the method.</p>
				<pre class="language-javascript">
						<code>
							let arr = [1, 2, 3, 4, 5];
							arr.reverse();
							/*
							This changes the original array into:
							arr = [5, 4, 3, 2, 1]
							*/
						</code>
					</pre>
			</section>

			<section id="join()_method_arrays" class="grid-item">
				<h4>
					Turn an Array Into a String:
					<span class="monoText">.join()</span>
				</h4>
				<p>The <span class="monoText">join()</span> method takes all the values in an array, and combines them into a single string, as originally ordered. Remember, the return from a <span class="monoText">join()</span> method is a string. Thus, if you us the <span class="monoText">join()</span> method with an array of numbers, the result is a string of those numbers.</p>
				<pre class="language-javascript">
						<code>
							let letters = ['q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c'];
							
							letters.join('');
							// This returns a single string, joined with an empty string: 'quadratic'
							
							letters.join('-');
							// This returns a single string, joined with the string '-': 'q-u-a-d-r-a-t-i-c'

							letters.reverse().join('');
							// This reverses the array <span class="italicsText">letters</span>, and returns a single string, joined with an empty string: 'citardauq'
						</code>
						</pre>
			</section>

			<section id="slice()_method_arrays" class="grid-item">
				<h4>
					Copy a Portion of an Array:
					<span class="monoText">.slice()</span>
				</h4>

				<p>Like the <span class="monoText">slice()</span> method applied to strings, the <span class="monoText">slice()</span> method applied to arrays takes a portion of an array, and creates a new array with that portion, without changing or affecting the original array. The <span class="monoText">slice()</span> method usually takes two arguments:</p>
				<ol>
					<li>The starting index in the original array to start the slice; and</li>
					<li>The end index in the original array (but, in the slice, it does not include the value with the end index).</li>
				</ol>
				<p>
					If no numbers are passed into the
					<span class="monoText">.slice()</span> method, then an entire copy of the array is made. So, for example:
				</p>
				<pre class="language-javascript">
							<code>
								let sets = ['A', 'B', 'C', 'D', 'E'];
								let slicedSets = sets.slice(1, 3);
								/* We've created a new array called <span class="italicsText">slicedSets</span>:
								slicedSets = ['B', 'C']
								*/
							</code>
						</pre>
				<p>
					By passing a negative number, say $-x$ into the
					<span class="monoText">slice()</span> method, we essentially tell JavaScript: "For this array, slice the portion starting $x$ from the last index." For example:
				</p>
				<pre class="language-javascript">
							<code>
								let sets = ['A', 'B', 'C', 'D', 'E'];
								let subSet = sets.slice(-2);
								/*
								This code says, make a slice starting 2 from the last index (here, the last index is 5, so the slice starts at 3). This will include the last index.
								
								So, the resulting array:
								subset = ['C', 'D', 'E']
								*/
							</code>
						</pre>
				<p>
					If 2 negative numbers are passed as arguments into the
					<span class="monoText">slice()</span> method, say $-x$ and $-y$, then the slice starts at $x$ index from the last index of the array, and the slice ends at $y$ index from the last index of the array. Illustration:
				</p>
				<pre class="language-javascript">
							<code>
								let sets = ["A", "B", "C", "D", "E"];
								let subSet = sets.slice(-3, -1);
								/*
								Here, we tell JavaScript, start the slice at the index 3 units from the last index (in this case, index = 2), and end the slice 1 unit from the last index (index = 4).

								Thus:
								subSet = ['C', 'D']
								*/
							</code>
						</pre>
			</section>

			<section id="splice()_method" class="grid-item">
				<h3>
					Remove, Replace, or Add a Value to an Array:
					<span class="monoText">splice()</span>
				</h3>
				<p>The <span class="monoText">splice()</span> method can either remove, replace, or add new values in an array. <span class="monoText">splice()</span> is primarily used for changes to the middle of an array, since changes to the beginning or end of an array are usually handled with <span class="monoText">push()</span>, <span class="monoText">pop()</span>, <span class="monoText">shift()</span>, and <span class="monoText">unshift()</span>. Splice can take at least three different values:</p>
				<ol>
					<li>the start index (an integer)</li>
					<li>the specific value we want to delete</li>
					<li>the specific value we want to insert</li>
				</ol>
				<p>So, for example:</p>
				<pre class="language-javascript">
							<code>
								let vectors = ['velocity', 'acceleration', 'momentum'];
								vectors.splice(1, 0, 'weight');
								/*
								In the above code, we changed the original array vectors to the following: 
								vectors = ['velocity', 'weight', 'acceleration', 'momentum']
								*/
							</code>
						</pre>
				<p>The <span class="monoText">splice()</span> method changes the original array. I.e., once applied, the original array is no more---it is now the modified, spliced array.</p>
			</section>

			<section id="sort()_method" class="grid-item">
				<h3>Sort the Values in an Array: <code>.sort()</code></h3>
				<p>The <span class="monoText">sort()</span> method sorts the elements of an array in place, and returns the sorted array. The sort order can be alphabetic, numeric, ascending, or descending. By default, <span class="monoText">sort()</span> sorts an array's elements as strings in alphabetic and ascending order. To sort the string elements of an array alphabetically:</p>

				<pre class="language-javascript">
								<code>
									let shapes = ['square', 'circle', 'triangle', 'pentagon', 'rhombus'];
									shapes.sort();
									/* 
									This returns a sorted array: 
									['circle', 'pentagon', 'rhombus', 'square', 'triangle']
									*/
								</code>
							</pre>
			</section>

			<section id="arrays_reference_type" class="grid-item">
				<h3>Reference Types</h3>
				<p>
					When a variable is declared and assigned a primitive type value, a
					<span class="term">value type variable</span> is created. Once a <span class="italicsText">value type variable</span> is created, JavaScript stores it in memory, and more specifically, JavaScript <span class="italicsText">stores the variable's assigned value</span>.
					<span class="boldText"><span class="redText">This is not the case for variables declared and assigned an array.</span></span>
				</p>
				<p>
					Arrays are too large and take up memory unnecessarily. Instead of storing the array, JavaScript stores the array's
					<span class="term">reference</span>. An array's <span class="italicsText">reference</span> is a string of numbers, akin to a memory address. This has a significant impact on the way <code>const</code> works with arrays.
				</p>
				<p>
					Because assigning an array to a variable does not actually store the array in the variable (it stores the array's reference), we can change the elements within an array, even if we assign the array to a variable declared with
					<span class="monoText">const</span>.This is because once an array is created and stored in a variable, its reference <span class="underlineText">never</span> changes.
				</p>
				<p>
					As such, because the variable declared and assigned with
					<span class="monoText">const</span> is storing a reference (which never changes), rather than the actual array itself, the array can be changed later down the program.
				</p>
				<p>
					This also means that if you declare a variable with
					<span class="monoText">const</span> and assign an array to it, you cannot change that reference later (i.e., assigning to the variable an entirely new array). Because of this behavior, it is almost always the case that <span class="monoText">const</span> should be used for arrays, unless there is a reason for needing a variable to point to different arrays (in which case, <span class="monoText">let</span> should be used).
				</p>
			</section>

			<section id="nested_arrays" class="grid-item">
				<h3>Nested Arrays</h3>
				<p>It is perfectly fine to have arrays containing arrays (but, before nesting an array, consider whether there is an alternative or better data structure).</p>

				<pre class="language-javascript">
								<code>
									/*
									Here is an array containing three arrays.
									*/
									const courses = [
										['mechanics', 'E & M', 'thermodynamics'],
										['calculus', 'differential equations', 'real analysis'],
										['algorithms', 'data structures', 'operating systems']
									]
								</code>
							</pre>

				<p>To access the elements of a nested array, we can perform the following:</p>

				<pre class="language-javascript"><code>
									const arr1 = [
										[1, 3, 5, 9],
										[3, 2, 9, 10],
										[11, 3, 6, 9]
									]
									// Suppose we want the third element of the second array:
									arr1[1][2];
									/*
									This returns 9.
									[1] tells JavaScript, look at the element with index of 1---in this case, the second array.
									[2] tells JavaScript, inside that array, look at the element with index of 2---in this case, the number 9.
									*/
								</code></pre>
			</section>

			<section id="objects_introduction" class="grid-item">
				<h2>Objects</h2>
				<p>
					An object is a collection of
					<span class="term">properties</span>. An object's property consists of a<span class="term">key value pair</span>—a <span class="term">key</span> and the data stored in it.
				</p>
				<p>The name of a <span class="term">key</span> is a <span class="italicsText">string</span>, and that name is referred to as a <span class="term">property name</span>. The value stored to a key is called the <span class="term">property value</span>.</p>

				<p>Suppose we have data for a particular event:</p>
				<ul>
					<li><span class="monoText">velocity</span></li>
					<li><span class="monoText">acceleration</span></li>
					<li><span class="monoText">momentum</span></li>
					<li><span class="monoText">weight</span></li>
				</ul>
				<p>Now suppose that we have the same exact kind of data for another event. This might look like the following:</p>
				<table class="dataTable">
					<thead>
						<td></td>
						<th>Event 1</th>
						<th>Event 2</th>
					</thead>
					<tr>
						<td>Velocity</td>
						<td>1.14</td>
						<td>1.26</td>
					</tr>
					<tr>
						<td>Acceleration</td>
						<td>1.09</td>
						<td>1.05</td>
					</tr>
					<tr>
						<td>Momentum</td>
						<td>2.33</td>
						<td>2.43</td>
					</tr>
					<tr>
						<td>Weight</td>
						<td>13.4</td>
						<td>13.9</td>
					</tr>
				</table>
				<p>How do we store this data? One option is to store each of the values individually with their own variables. Problem: While that may work for a handful of data values, it would quickly become cumbersome, even infeasible, for thousands of data values.</p>
				<p>Another option is to use an array. Problem: This would still be tedious. We would need some sort of key (with comments), distinguishing between the data and distinguishing between the events.</p>
				<p>
					The solution to this problem is to use an
					<span class="term">object</span>. <span class="italicsText">Objects</span> allow us to group data together, but more importantly, rather than relying on each of the data value's index, we can <span class="term">label</span> the data. By labeling the data, we can access the assigned values with custom keys, rather than with an index.
				</p>
			</section>

			<section id="nameValuePairs_objects" class="grid-item">
				<h3>Name Value Pairs &amp; and Objects</h3>
				<p>
					Objects are so important in JavaScript that we need to be just a little more clear about what they are. JavaScript objects contain a
					<span class="term">name/value pair</span>. A <span class="term">name</span> is an identifier mapped to a unique <span class="term">value</span>. That name can be defined more than once, but it can only have <span class="underlineText">one</span> value in any given <span class="italicsText">execution context</span>. That value itself can be numeric data, textual data, an array, or more name/value pairs.
				</p>
				<p>
					Where do objects fit in this picture? An object is a
					<span class="term">collection</span> of name value pairs. An object can contain name/value pairs, names paired with other name/value pairs, or names paired with names paired with other name/valur pairs. For example:
				</p>

				<pre class="language-javascript"><code>
							Class = 
							{
								Title: "Discrete Mathematics",
								Topics:
								{
									Logic: {
										Weeks: [0, 1, 2],
										Difficulty: Moderate
									},
									numberTheory: {
										Weeks: [3, 4, 5],
										Difficulty: High
									}

								}
							}
						</code></pre>
			</section>

			<section id="the_global_object" class="grid-item">
				<h3>The Global Object</h3>
				<p>
					In JavaScript, there is an execution context called the
					<span class="term">global execution context</span>. This is the <span class="italicsText">base</span> execution context. All execution contexts "lie on top" of the global execution context. Code written in the global execution context is accessible to everything everywhere else in the program.
				</p>
				<p>
					The global execution context creates two things: (1) a
					<span class="term">global object</span> and (2) a variable called <span class="monoText">this</span>. These are created by the JavaScript engine whenever code is executed, since all code, in JavaScript, is exists in an execution context.
				</p>
				<p>
					If we execute JavaScript in the browser, we can see the global object by simply typing the keyword
					<span class="monoText">this</span>:
				</p>

				<pre class="language-javascript"><code>
							this
							/* Output:
							Window {window: Window, self: Window, document: document, name: "", location: Location, …}
							*/
						</code></pre>

				<p>
					On the browser, the global object is the
					<span class="monoText">window</span> object. However, the global object is not always the <span class="monoText">window</span> object. It depends on where we execute JavaScript code. If we ran JavaScript in a separate tab or window, the global object would still be called the <span class="monoText">window</span> object, but it is a different object&mdash;it's a different execution context. In NodeJS, the global object is something else entirely. Nevertheless, in every situation, there is <span class="underlineText">always</span> a global object whenever we run JavaScript.
				</p>
				<p>
					Note that in JavaScript, when we use the word "global," we are referring to an execution context
					<span class="underlineText">not inside a function</span>. Thus, if we have code that is <span class="italicsText">not</span> inside a function, that code resides in the global execution context.
				</p>
				<p>Thus, suppose we wrote the following code:</p>

				<pre class="language-javascript"><code>
							var x = 'Hello world!';
							function b() {

							};
						</code></pre>

				<p>Then, in our console, we wrote:</p>

				<pre class="language-javascript"><code>
							window
							/*
							Output:
							Window {
								...
								a: "Hello World!"
								b: function b() {}
							}
							*/
						</code></pre>

				<p>We see that the variable we wrote, <span class="monoText">x</span>, and the function we wrote, <span class="monoText">b</span>, reside in the <span class="monoText">Window</span> object, the global object. Because they are inside the global object, we can reference them by writing:</p>

				<pre class="language-javascript"><code>
							window.a
							// Output: "Hello world!"
							window.b
							// Output: 
							ƒ b() {
								
							}
						</code></pre>
			</section>

			<section id="creation_hoisting" class="grid-item">
				<h3>Hoisting</h3>
				<p>Write the following in a JavaScript file linked to an HTML document:</p>

				<pre class="language-javascript"><code>
							var greeting = "Hello world!";
							function bye() {
								console.log("Goodbye!");
							}
							
							bye();
							console.log(greeting);
							/*
							Output:
							"Goodbye!"
							"Hello world!"
							*/
						</code></pre>

				<p>Now suppose we rearranged the code:</p>

				<pre class="language-javascript"><code>
							bye();
							console.log(greeting);

							var greeting = "Hello world!";
							function bye() {
								console.log("Goodbye!")
							}
							/*
							Output:
							"Goodbye!"
							undefined
							*/
						</code></pre>

				<p>Notice that the function <span class="monoText">bye()</span> is actually executed, and the console displays <span class="monoText">undefined</span> for the variable <span class="monoText">greeting</span>. This is unusual behavior. In most programming languages, the function <span class="monoText">bye()</span> would not have been executed, since executions go from top down. Similarly, we do not get an error from executing a method with a variable declared later down the code. We do, however, get an error if we completely removed the variable declaration:</p>

				<pre class="language-javascript"><code>
							bye();
							console.log(greeting);

							var greeting = "Hello world!";
							function bye() {
								console.log("Goodbye!")
							}
							/*
							Output:
							"Goodbye!"
							Uncaught ReferenceError: greeting is not defined
							*/
						</code></pre>

				<p>
					In JavaScript, this phenomenon of allowing functions to execute "before" the function is defined or variables declared is called
					<span class="term">hoisting</span>. This phenomenon occurs because JavaScript execution contexts are created in two phases:
				</p>
				<ol>
					<li>The Creation Phase; and</li>
					<li>The Execution Phase</li>
				</ol>

				<h4>The Creation Phase</h4>
				<p>
					In the <span class="term">creation phase</span>, three things are created: (1) the <span class="italicsText">global object</span>, (2) the variable <span class="monoText">this</span>, and (3) the <span class="italicsText">outer environment</span>. During the creation phase, the syntax parser runs through all of the code, setting everything up for translation. During that run, the parser recognizes where we've created variables, and where we've created functions. To keep track of everything it's doing, it takes memory space for variables and functions. This is what we see as <span class="italicsText">hoisting</span>. Contrary to what many think (and teach), the parser does not actually move code to the top of the page. What's actually going on is that before the code is even executed line by line, the parser has already stored the variables and functions we've written in memory. Because the variables and functions already exist in memory, when the code actually
					executes line by line, the functions we've written after a particular line (in the global object) are accessible.
				</p>

				<p>
					Variables, however, are treated somewhat differently. A function and its entirety are stored in a memory space when the parser runs through the code. This is why they can be executed when called before they are occupied. Variables, however, are only partly stored&mdash;the variable declaration and its identifier (its name) are stored in memory during the parser's run, but a variable's assignment is stored only during the second phase,
					<span class="italicsText">execution</span>. This means that the JavaScript engine does not actually know what a variable's assigned value until it reaches it during execution.
				</p>

				<p>
					Rather than storing the variables assigned value, the parser stores a placeholder value in memory space &mdash;
					<span class="monoText">undefined</span>. Storing the placeholder value is effectively JavaScript's way of saying "I don't know what the value of this variable is yet, but it does have a value." This is the same placeholder value that we would have if we never assigned a value to a variable. This means that <span class="underlineText">all</span> variables in JavaScript are initially set to <span class="monoText">undefined</span>.
				</p>
			</section>

			<section id="javascript_and_undefined" class="grid-item">
				<h3>JavaScript and <span class="monoText">undefined</span></h3>
				<p>We've noted that variables, when first created, are assigned the value <span class="monoText">undefined</span>. What does this mean? We can see that this is the case when we write the following:</p>

				<pre class="language-javascript"><code>
							var a;
							console.log(a);
							// Output: undefined
						</code></pre>

				<p>If, however, we do not declare the variable, we notice that the console actually throws an error: </p>

				<pre class="language-javascript"><code>
							console.log(a);
							/* 
							Output: 
							<span class="redText">Uncaught ReferenceError: a is not defined</span>
							*/
						</code></pre>

				<p>But isn't the value <span class="monoText">undefined</span> a value? Yes, it is, but it's a special value in Javascript. Specifically, it's a value that means that the value has not been set. We can see this with the following code:</p>

				<pre class="language-javascript"><code>
							var a;
							console.log(a);
							if (a === undefined) {
								console.log('a is undefined!');
							}
							else {
								console.log('a is defined');
							}
							/*
							Output:
							undefined
							a is undefined
							*/
						</code></pre>

				<p>We see that <span class="monoText">a</span> is <span class="monoText">undefined</span>. The above code confirms that a variable, declared but unassigned, has the default value of <span class="monoText">undefined</span> If we completely declined to declare the variable <span class="monoText">a</span> and tried to pass it as an argument, we get an <span class="monoText">uncaught reference error</span>. We get an error because we attempted to use a variable that the parser did not store in memory during its initial run. Why didn't the parser store it in memory? Because we didn't declare at all in the first place.</p>
				<p>
					Note what all of this means. The value
					<span class="monoText">undefined</span> doesn't mean "does not exist." It is an actual value&mdash;the value of reserved memory space. More specifically, it's a value that means "a value set by Javascript." This is also indicative of a warning. We should never write something like this:
				</p>

				<pre class="language-javascript"><code>
							a = undefined; 
						</code></pre>

				<p>Writing the code above is a sure fire way to get into a lot of messy problems. For example, something like this can occur:</p>

				<pre class="language-javascript"><code>
							var a = 'Hello world';
							console.log(a);
							a = undefined;

							if (a === undefined) {
								console.log('a is undefined');
							}
							else {
								console.log('a is defined!');
							}
						</code></pre>

				<p>
					When we ourselves assign the value
					<span class="monoText">undefined</span> to a variable, it can quickly become very difficult to decipher whether a variable's value of <span class="monoText">undefined</span> was set by us or JavaScript. It is always best practice to leave the value <span class="monoText">undefined</span> to JavaScript. By complying with this practice, whenever we see the value <span class="monoText">undefined</span>, we know that we did not set a value for a particular variable&mdash;it was set by JavaScript.
				</p>
			</section>

			<section id="execution_context_js" class="grid-item">
				<h2>The Execution Context</h2>
				<p>
					In the sections above, we discussed the
					<span class="italicsText">creation phase</span>. Once the creation phase ends, the <span class="term">execution phase</span> begins. This is where the JavaScript interpret begins translating the code into assembly language&mdash;code that the computer can understand. Once translated, the code is then executed.
				</p>
				<p>Suppose we had the following code:</p>

				<pre class="language-javascript"><code>
							function b() {
								console.log('Called b!')
							}
							b();
							console.log(a);
							var a = 'Hello world!';
							console.log(a);
						</code></pre>

				<p>In the code above, the output looks like the following:</p>

				<pre class="language-javascript"><code>
							"Called b!"
							undefined
							"Hello world!"
						</code></pre>

				<p>The function <span class="monoText">b()</span> is executed, then the method <span class="monoText">console.log()</span> is executed (with a value of <span class="monoText">undefined</span>), then the second <span class="monoText">console.log()</span> is executed, with the value <span class="monoText">"Hello world!"</span>.</p>
				<p>
					Why are there two different values for the variable
					<span class="monoText">a</span>? Because initially, the value of <span class="monoText">a</span> was <span class="monoText">undefined</span>, as set by the parser in the <span class="italicsText">creation phase</span>. In the line just after that, however, we assigned <span class="monoText">a</span> the value <span class="monoText">"Hello world!"</span>, so the value is no longer <span class="monoText">undefined</span>, but a string instead.
				</p>
			</section>

			<section id="single_threaded" class="grid-item">
				<h2>Single Threaded, Synchronous Execution</h2>
				<p>
					In a single program, multiple commands are executed. We say that a language's execution is
					<span class="italicsText">single threaded</span> when the language executes only <span class="underlineText">one</span> command at a time.
				</p>
				<p>When it comes to browsers, there are multiple programs running. JavaScript is not the only program running. If we were to look at JavaScript's operations under the browser's hood, it may appear that JavaScript is anything but a single-threaded language. Nevertheless, it behaves and is a single-threaded language.</p>
				<p>
					Moreover, not only is JavaScript single-threaded, it is also
					<span class="term">synchronous</span>. This just means it's a language that executes only <span class="underlineText">one</span> line of code at a time.
				</p>
				<p>In conjunction, JavaScript is a single-threaded and synchronous programming language. This means only one thing happens at a time.</p>
			</section>

			<section id="function_exection_and_execution_stack" class="grid-item">
				<h3>Function Execution & Execution Stack</h3>
				<p>
					Invocation is just another word for "running a function." In JavaScript, we invoke a function with parentheses
					<span class="monoText">()</span>. Once we write something like <span class="monoText">functionName()</span>, we have <span class="italicsText">invoked</span> a function&mdash;we've told JavaScript to <span class="italicsText">run</span> a function. So what exactly happens when you invoke a function in JavaScript?
				</p>
				<p>Suppose we have the following code:</p>

				<pre class="language-javascript"><code>
							function b() {

							};
							function a() {
								b();
							}
							a();
						</code></pre>

				<p>
					In the above code, we have two functions: function
					<span class="monoText">b</span>, which does nothing, and function <span class="monoText">a</span>, which invokes function <span class="monoText">b</span>. Then, we call function <span class="monoText">a</span>. What is the output here?
				</p>
				<p>
					First, we know that when we run this code, a
					<span class="italicsText">global execution context</span> is created. The parser creates the variable <span class="monoText">this</span>, and a global object (in the browser, the <span class="monoText">window</span> object). The function's we've written above are global, so they are included in the <span class="monoText">window</span> object, and memory is reserved for the functions. This all occurs in the <span class="italicsText">creation phase</span>. Once this is all done, the interpreter begins executing the program line by line. Remember, this is just the creation phase. That very last line, <span class="monoText">a()</span>, is a function call, but it is not executed. This is just the phase where the parser readies the program.
				</p>
				<p>
					Once the interpreter begins the execution phase, it goes line by line. It goes down the program, then encounters, the statement
					<span class="monoText">a();</span>. This statement tells the interpreter that we're invoking a function. When the interpreter sees a function invocation, it places the function in a data structure called the <span class="term">execution stack</span>. A <span class="italicsText">stack</span> is just what it sounds like&mdash;one function on top of the other. Whichever function is at the top is the function that it is currently running.
				</p>

				<p>
					Once the function is placed in the
					<span class="term">call stack</span>, the interpreter begins executing the function, line by line. If, while executing the current function, the interpreter encounters another function, the interpreter undergoes the same process. It places the nested function in the <span class="italicsText">call stack</span>, creates an execution context for that nested function (i.e., it reenters another creation phase), and begins executing that function. This is how every function in JavaScript is handled&mdash;the interpreter undergoes a creation phase for every function, then executes the code line by line.
				</p>
				<p>
					Thus, in the code above, the interpreter executions function
					<span class="monoText">a()</span>, then begins executing function <span class="monoText">b()</span>. Once function <span class="monoText">b()</span> finishes executing, it is <span class="term">popped off</span> the stack.
				</p>
				<p>Now suppose we had the following code:</p>

				<pre class="language-javascript"><code>
							function a() {
								b();
								var c;
							}
							function b() {
								var d;
							}
							a();
							var d;
						</code></pre>

				<p>What are the steps the interpreter goes through with the code above?</p>
				<p>
					First, the interpreter enters creation phase. It creates a
					<span class="italicsText">global execution context</span>, and pushes that into the call stock.
				</p>
				<p>Then it begins executing the code (inside the global execution context).</p>
				<p>In the global execution context, it reenters the creation phase. It sees a function called <span class="monoText">a</span>, and saves it to memory. It then sees a function called <span class="monoText">b</span>, and allocates that to memory. The interpreter sees a function call, <span class="monoText">a()</span>, but it does not execute, since it's still in the creation phase. It moves on and sees <span class="monoText">var d</span>, a variable that we have declared but not assigned. The interpreter saves the variable <span class="monoText">a</span> to memory, and assigns it the value <span class="monoText">undefined</span>.</p>
				<p>
					Now that the interpreter has finished going through all of our lines during the creation phase, it begins the execution phase. This is where the interpreter acts synchronously&mdash;it goes line by line through the global execution context. The first few lines do not output anything&mdash;they merely define the functions
					<span class="monoText">a</span> and <span class="monoText">b</span>. Once the interpreter moves past these definitions, it encounters our function call, <span class="monoText">a()</span>. The function <span class="monoText">a</span> is invoked, so the interpreter creates an execution context for that function&mdash;it reenters a creation phase. It moves past the function call <span class="monoText">b()</span>, allocates memory for <span class="monoText">var c</span>, and assigns it the value <span class="monoText">undefined</span>. The interpreter then pushes this new execution context to the call stack, and begins executing.
				</p>
				<p>
					During the function <span class="monoText">a</span>'s execution, the interpreter encounters the function call <span class="monoText">b()</span>. The interpreter then reenters another creation phase, creating the execution context for the function <span class="monoText">b</span>. While parsing through function <span class="monoText">b</span> It sees <span class="monoText">var d</span>. So, it saves it to memory (local to the function <span class="monoText">b</span>), and assigns it the value <span class="monoText">undefined</span>. The interpreter then pushes the function <span class="monoText">b</span>'s execution context to the stack, and begins executing <span class="monoText">b</span>. The function <span class="monoText">b</span> does not output anything (it merely declares a variable <span class="monoText">d</span>), but the function finishes executing <span class="monoText">b</span> nevertheless. Once the function <span class="monoText">b</span> has finished executing,
					its execution context is <span class="italicsText">popped off</span> the call stack, and the interpreter continues executing function <span class="monoText">a</span>.
				</p>
				<p>The function <span class="monoText">a</span> does not output anything, it merely declares a variable called <span class="monoText">c</span>. The interpreter finishes executing <span class="monoText">a</span>.</p>
				<p>Now that all of the functions have finished executing, the interpreter has finished executing the global execution context, and it is popped off the call the stack.</p>
			</section>

			<section id="variable_environments" class="grid-item">
				<h3>Variable Environments</h3>
				<p>
					The the term
					<span class="term">variable environment</span> refers to <span class="italicsText">where</span> a variable lives. The variable environment determines how variables relate to each other in memory. Suppose we had the following code:
				</p>

				<pre class="language-javascript"><code>
							function b() {
								var X;
								console.log(X);
							}
							function a() {
								var X = 2;
								console.log(X);
								b();
							}
							var X = 1;
							console.log(X);
							a();
						</code></pre>

				<p>
					In the code above, we declared a variable
					<span class="monoText">X</span> inside the function <span class="monoText">b</span> without assigning it any value, then declared another variable, with the same name, <span class="monoText">X</span>, outside the function <span class="monoText">b</span>, but assigned it the value <span class="monoText">1</span>. Furthermore, we called the function <span class="monoText">a</span>, and inside the function <span class="monoText">a</span>, we call the function <span class="monoText">b</span>. What's going to happen here? More specifically, what is the value of the variable <span class="monoText">X</span> at any point in time?
				</p>
				<p>It all comes down to execution contexts.</p>
				<p>
					First, the interpreter begins creating a global execution context. The interpreter runs through the code: (1) It sees the function
					<span class="monoText">b</span>, and assigns it to memory. (2) It sees the function <span class="monoText">a</span>, and assigns it to memory. (3) It sees the variable <span class="monoText">var x</span>, and assigns it to memory with the value <span class="monoText">undefined</span>. (4) It sees a function call, <span class="monoText">a();</span>, but it moves past this (this is the creation phase). Thus, the interpreter finishes creating the global execution context, and pushes it into the call stack.
				</p>
				<p>Once the global execution context has been created, the interpreter begins executing the code. The first few lines are simply function definitions, so the interpreter moves past these lines. It then sees that we've assigned the value <span class="monoText">1</span> to the variable <span class="monoText">a</span>, so it executes the line: <span class="monoText">var a</span> has the value <span class="monoText">1</span>. The interpreter moves on to the next line, and sees a function call <span class="monoText">a()</span>. So, it begins creating an execution context for the function <span class="monoText">a</span>.</p>
				<p>During the function <span class="monoText">a</span>'s creation phase, the interpreter encounters a variable called <span class="monoText">X</span>. The interpreter saves <span class="monoText">X</span> to memory, with the value <span class="monoText">undefined</span>. More specifically, the <span class="term">variable environment</span> for the function <span class="monoText">a</span>'s execution context. This is a crucial point to remember: Every execution context has its own variable environment. The interpreter continues, sees a function call, <span class="monoText">b()</span>, but does not execute (we're still in the creation phase). This concludes the creation phase, and the interpreter places <span class="monoText">a</span> to the call stack, to be executed.</p>
				<p>Once the creation phase has finished, the interpreter begins executing function <span class="monoText">a</span>. It sees the statement <span class="monoText">var X = 2</span>, so it assigns to <span class="monoText">X</span> the value <span class="monoText">2</span>. Then it sees a function call, <span class="monoText">b()</span>, and begins another creation phase.</p>
				<p>During <span class="monoText">b</span>'s creation phase, the interpreter sees <span class="monoText">var X</span>, and saves it to memory, with the value <span class="monoText">undefined</span>. And again, saved as <span class="monoText">X</span> specific to <span class="monoText">b</span>'s variable environment.</p>
				<p>
					The variable environment determines
					<span class="term">scope</span>&mdash;where exactly can JavaScript see the variable. Each of the <span class="monoText">X</span>s above are unique to the functions. Every time you call a function, you get your own execution context. Thus, even though the <span class="monoText">X</span>s are declared three separate times, they are all distinct.
				</p>
				<p>These concepts are made apparent with the output from the code above:</p>

				<pre class="language-javascript"><code>
							1
							2
							undefined
						</code></pre>

				<p>We see the value <span class="monoText">1</span> first because the interpreter executed the function <span class="monoText">console.log(X)</span>, and the value of <span class="monoText">X</span> is the value of <span class="monoText">X</span> in the global execution context's variable environment, which is <span class="monoText">1</span>. Then we see the value <span class="monoText">2</span>, because the interpreter executed function <span class="monoText">a</span> next. Function <span class="monoText">a</span> outputs to the console its value of the variable <span class="monoText">X</span>, which is 2. Then we see <span class="monoText">undefined</span>, because within function <span class="monoText">a</span>, function <span class="monoText">b</span> is executed. Function <span class="monoText">b</span> outputs to the console its value of <span class="monoText">X</span>, which is <span class="monoText">undefined</span>.</p>
			</section>

			<section id="scope_chain" class="grid-item">
				<h3>The Scope Chain</h3>
				<p>Suppose we had the following code:</p>

				<pre class="language-javascript"><code>
							function b() {
								console.log(x);
							};
							function a() {
								var x = 2;
								b();
							};
							var x = 1;
							a();
						</code></pre>

				<p>
					The code is similar to the previous example, accept that in function
					<span class="monoText">b</span>, we're not declaring the variable <span class="monoText">x</span>. Instead, we're only going to output it to the console. What do we think is going to happen in the console?
				</p>
				<p>Well, the console outputs:</p>

				<pre class="language-javascript"><code>
							1
						</code></pre>

				<p>Our code is outputting 1 because we didn't initialize any variable called <span class="monoText">x</span> in the function <span class="monoText">b</span>. When we do something like this (using a variable that we haven't declared inside the function itself), JavaScript doesn't just stop and say, "I don't know what to do, you didn't initialize this variable." Recall that when JavaScript's interpreter creates an execution context, it does a few extra things: it creates that execution context as an object, a variable called <span class="monoText">this</span>, and an <span class="term">outer environment</span>.</p>
				<p>
					In JavaScript, every execution context has a
					<span class="term">reference</span> to its outer environment. Here, the function <span class="monoText">b</span>'s outer environment is its global execution context. The global execution context is also function <span class="monoText">a</span>'s outer environment. What kind of outer environment are we referring to?
				</p>
				<p>
					We're referring to the
					<span class="term">lexical environment</span>. Function <span class="monoText">b</span> sits on top of the global environment. In other words, it is not inside function <span class="monoText">a</span>. It is inside the the global execution context, sitting at the same level as the line <span class="monoText">var x = 1</span>.
				</p>
				<p>If we use a variable inside a funtion but do not declare it beforehand (inside the function), JavaScript will look for the variable in its outer environment.</p>
			</section>

			<section id="kinds_of_objects" class="grid-item">
				<h4>Kinds of Objects</h4>
				<p>
					As mentioned in the section on
					<a href="#values">primitive types</a>, objects are a <span class="italicsText">type</span> in JavaScript. Arrays are a special kind of object, where the "keys" are the indices of the values. Another kind of object is the <span class="term">Set object</span>. The <span class="italicsText">Set object</span> is a set of values. <span class="italicsText"><a href="#set_object">See supra Set Objects</a></span
					>. Yet another kind of object is the <span class="term">Map object</span>. The <span class="italicsText">Map object</span> is an object that maps keys to values.
				</p>
			</section>

			<section id="difference_objects_and_arrays" class="grid-item">
				<h4>Differences Between Objects and Arrays</h4>
				<p>Compared to <span class="italicsText">object literals</span>, <span class="italicsText">arrays</span> are strict and sharp---they order data strictly by index. <span class="italicsText">Objects</span>, on the other hand, are more fluid-like. As a data structure, they morph into whatever we put into the object.</p>
			</section>

			<section id="creating_an_object" class="grid-item">
				<h4>Assigning an Object to a Variable</h4>
				<p>
					Just like an array, when an object is assigned to a variable, the variable does not store the object itself---it stores the object's
					<a href="#arrays_reference_type">reference</a>. There are many different kinds of objects. For this section, we focus on how to create <span class="term">object literals</span>. The <span class="italicsText">object literal</span> takes the following form:
				</p>
				<pre class="language-javascript">
							<code>
								const <span class="greyText italicsText">object-name</span> = {
									<span class="greyText italicsText">key</span>: <span class="greyText italicsText">value</span>,
									<span class="greyText italicsText">key</span>: <span class="greyText italicsText">value</span>,
									<span class="greyText italicsText">key</span>: <span class="greyText italicsText">value</span>,
								}
							</code>
						</pre>
				<p>When an object literal is created, the keys are automatically converted into strings (except for symbols). Just like arrays, when a variable is assigned an object, the variable does not actually store the object; it stores the object's reference. Thus, if you assign <span class="italicsText">object $w$</span> to a variable $x$, then also assign $x$ to another variable $y$, you can make changes to <span class="italicsText">object $w$</span> with both variables $x$ and $y$.</p>
				<p>This is because both variables are pointing to the same object.</p>
			</section>

			<section id="accessing_an_objects_data" class="grid-item">
				<h3>Accessing an Object Literal's Data</h3>
				<p>
					There are two ways to access an object literal's data:
					<code class="language-javascript">object.key // This is the general way</code>
					<code class="language-javascript">object[key] // This is good for keys with a number as a name</code>
					So, for example:
				</p>
				<pre class="language-javascript">
							<code>
								const vectors_event1 = {
									velocity: 1.14,
									acceleration: 1.09,
									momentum: 2.33,
									weight: 13.4
								};
								// Suppose we want to access the value for acceleration:
								vectors_event1.acceleration; // This returns 1.09, the value we assigned.

								// Now suppose that we have an object with numbers as their keys:
								const numbers = {
									100: 'one hundred',
									16: 'sixteen'
								};
								// If we try to use the general way of accessing the value, JavaScript will give us an error:
								numbers.100; // This returns an error

								// Thus, we must use bracket notation for these keys:
								numbers[100]; // This works
							</code>
						</pre>
			</section>

			<section id="modifying_objects" class="grid-item">
				<h3>Modifying an Object Literal's Properties</h3>
				<p class="subheading-1">Changing Properties</p>

				<p>Because a variable assigned with an object only stores the object's reference, we can change an object's properties by simply assigning new values to the properties:</p>
				<pre class="language-javascript">
							<code>
								const vectors_event2 = {
									velocity: 1.26,
									acceleration: 1.05,
									momentum: 2.43,
									weight: 13.9
								};
								// Suppose we want to update the object's velocity:
								vectors_event2.velocity = 1.47;
								// Update the acceleration:
								vectors_event2.acceleration = 1.11;
							</code>
						</pre>

				<p>To add a property, we write the following:</p>
				<pre class="language-javascript">
							<code>
								const vectors_event2 = {
									velocity: 1.26,
									acceleration: 1.05,
									momentum: 2.43,
									weight: 13.9
								};
								// Suppose we want to add a new vector, whether the temperature is increasing:
								vectors_event2.temperature_increasing = true;
								/*
								Now the object <span class="italicsText">vectors_event2</span> looks like the following:
									vectors_event2 = {
										velocity: 1.26,
										acceleration: 1.05,
										momentum: 2.43,
										weight: 13.9
										temperature_increasing: true;
									}
								*/
							</code>
						</pre>
			</section>

			<section id="nesting_arrays_and_objects" class="grid-item">
				<h3>Nesting Arrays and Objects</h3>
				<p>
					As with many other kinds of data structures, objects are receptive to nesting: we can place arrays inside objects, objects inside objects, arrays inside arrays inside objects inside objects,
					<span class="italicsText">ad nauseam</span>.
				</p>
				<pre class="language-javascript">
							<code>
								// Returning to our previous table:
								const experiment_results = {
									event1 = {
										velocity: 1.14,
										acceleration: 1.09,
										momentum: 13.4
									},
									event2 = {
										velocity: 1.26,
										acceleration: 1.05,
										momentum: 2.43,
										weight: 13.9
									}
								};
							</code>
						</pre>
				<p>
					A common data structure is an
					<span class="term">array of objects</span>, and that is likely what would be best for the data above (since "event" suggests a chronological order).
				</p>
				<pre class="language-javascript">
							<code>
								const experiment_results = [ // Initialize an array
									event1 = { // This is the first element of the array
										velocity: 1.14,
										acceleration: 1.09,
										momentum: 13.4
									},
									event2 = { // This is the second element of the array
										velocity: 1.26,
										acceleration: 1.05,
										momentum: 2.43,
										weight: 13.9
									}
								];
							</code>
						</pre>
			</section>

			<section id="object_array_equality" class="grid-item">
				<h3>Object/Array Equality</h3>

				<p>
					Recall that the
					<span class="italicsText">strict equality operator</span>
					<span class="monoText">===</span> tests whether two values are strictly equal in both value and type.
				</p>
				<p>Because of the way objects and arrays are stored (i.e., only their references are stored), neophytes are often surprised when two arrays or objects, consisting of entirely the same values, value types, and keys, are not strictly equal.</p>
				<pre class="language-javascript">
							<code>
								let primes = [1, 3, 5, 7];
								let morePrimes = [1, 3, 5, 7];
								primes === morePrimes // This returns false
								primes == morePrimes // Still false

								/*
								This is happening because the arrays <span class="italicsText">primes</span> and <span class="italicsText">morePrimes</span> have different references. The strict equality operator is not checking the actual arrays, it's only checking the references, and those references are different.
								*/

								// To check whether the arrays are strictly equal, we must ensure that both <span class="italicsText">primes</span> and <span class="italicsText">morePrimes</span> are storing the same reference:
								let morePrimes2 = primes;
								morePrimes2 === primes; // This returns true
								morePrimes2 == primes; // This returns true

								// From the above, if we make changes to morePrimes2, we change the array assigned to primes, since both variables are pointing to the same array:
								morePrimes2.push(11);
								/*
								Now the array looks like: 
								primes = [1, 3, 5, 7, 11]
								*/
							</code>
						</pre>
			</section>

			<section id="invoking_a_function" class="grid-item">
				<h4>Semantics: "Invoking" vs. "Calling" a Function</h4>
				<p>
					The terms "invoking" and "calling" a function are generally interchangeable. The difference is, when we intentionally use the function, we "call" the (and "invoke") the function. A function, however, can be "invoked" without being "called" (i.e., all function
					<span class="italicsText">calls</span> are <span class="italicsText">invocations</span>, but not all <span class="italicsText">invocations</span> are <span class="italicsText">calls</span>).
				</p>
			</section>

			<section id="javascript_functions" class="grid-item">
				<h3>JavaScript Functions</h3>
				<p>A <span class="term">function</span> is essentially a reusable block of code. Once we define a function (and we only do so once), we can execute, or <span class="term">call</span>, the function however many times we want. A <span class="italicsText">function</span> in JavaScript is much like a <span class="italicsText">procedure</span> or <span class="italicsText">subroutine</span> in other programming languages. A function can take several forms.</p>
				<pre class="language-javascript">
						<code>
							function <span class="greyText italicsText">function name</span>(<span class="greyText italicsText">parameter(s)</span>) {
								<span class="greyText italicsText">code block</span>;
							}
						</code>
					</pre>
				<p>
					A function's
					<span class="term">parameter</span> is an identifier, or parameter, is a variable (scoped to the function) to be used in the function's body. That is to say, a placeholder name to be used by the function. By including a parameter, we can pass through <span class="term">arguments</span>, or inputs, such as code or data, to be used as local variables in the function's body (i.e., the block of code to be executed). Parameters are optional—we can have functions that do not take any arguments. Example:
				</p>
				<pre class="language-javascript">
						<code>
							/*
							Here is a simple function that executes a rudimentary calculation of velocity.
							*/
							function velocity(displacement, time) {
								console.log(displacement / time + " " + "m/s");
							}

							velocity(157, 5); // Call the function
							/*
							This outputs to the console:
							31.4 m/s
							*/
						</code>
					</pre>
				<p>A function without parameters:</p>
				<pre class="language-javascript">
						<code>
							/*
							Here is another function that rolls a die with 20 faces.
							*/
							function rollDice() {
								let roll = Math.floor(Math.random() * 20) + 1;
								console.log(`You rolled: ${roll}`);
							}
							rollDice();

							/*
							This outputs to the console a random number between 1 and 20. We add 1 because the random number could be 0, and we are assuming that the dice does not have a side with the number 0.
							*/
						</code>
					</pre>
				<p>A <span class="term">parameter</span> is an <span class="italicsText">alias</span> used for the values, or code, that will be passed through to the function. An <span class="term">argument</span> is the actual value or code passed through to the function.</p>
			</section>

			<section id="functions_v_methods" class="grid-item">
				<h3>Functions vs. Methods</h3>
				<p>
					What is the difference between a
					<span class="italicsText">function</span> and a <span class="italicsText">method</span>? Functions look similar to <span class="italicsText">methods</span>. In fact, methods are just one kind of function. The difference: a method is function limited to an object (a <span class="term">receiver</span>). For example, the methods accompanying the
					<a href="#math_object_introduction">math object</a>
					only execute when called with its object.
				</p>
			</section>

			<section id="javascript_return_statement" class="grid-item">
				<h4>The <span class="monoText">return</span> Statement</h4>
				<p>The <span class="monoText">return</span> statement is what allows us to store the output from a function, and pass it on to other functions. A <span class="monoText">return</span> statement is interpreted by JavaScript as an end to the function's execution. Thus, once JavaScript reaches a <span class="monoText">return</span> statement, code after that <span class="monoText">return</span> statement (in the same code block) will not execute.</p>
				<pre class="language-javascript">
							<code>
							/*
							Here is a function that verifies whether a password is at least 8 characters long, contains no spaces, and is not the same as the username. 
							*/

							function isPasswordValid(password, username) {
								if (password.length < 8) {
									return false;
								}
								if (password.includes(" ")) {
									return false;
								}
								if (password === username) {
									return false;
								}
								return true;
							}
							console.log(isPasswordValid("boogabooga", "eustice"));
							console.log(isPasswordValid("eustice", "eustice"));
							console.log(isPasswordValid("Cowardly Dog", "muriel"));							

							/*
							This outputs to the console:

							true
							false
							false
							*/
							</code>
						</pre>
				<p>But, you can have multiple return statements in a function, as long as they are in separate code blocks.</p>
				<pre class="language-javascript">
								<code>
									/*
									Here is a function that checks whether a name starts with the letter "N"
									*/
									function isFirstLetterX(firstName) {
										if (firstName.toUpperCase()[0] === "X") {
											return true;
										} 
										
										else {
											return false;
										}
									}
									console.log(isFirstLetterX("norman"));
									console.log(isFirstLetterX("xeno"));
									/*
									This outputs the following to the console:
									
									false
									true
									*/
								</code>
							</pre>
			</section>

			<section id="javascript_function_expressions" class="grid-item">
				<p>
					Another way to write a function is with a
					<span class="term">function expression</span>. This follows the syntax:
				</p>
				<pre class="language-javascript">
							<code>
								const <span class="greyText italicsText">variable-name</span> = function(<span class="greyText italicsText">parameter</span>) {
									<span class="greyText italicsText">statements</span>;
								}
								// We can then call the function:
								<span class="greyText italicsText">variable-name</span>(<span class="greyText italicsText">argument</span>);
							</code>
						</pre>
				<p>
					Notice the difference between a
					<span class="italicsText">function expression</span> and a <span class="italicsText">function declaration</span>: in a <span class="italicsText">function expression</span>, the function itself does not have a name. Instead, we store the function in a variable, and then use the variable name to call the function. This works because <span class="underlineText">functions are objects</span>. Example:
				</p>
				<pre class="language-javascript">
								<code>
									/*
									Here is a function that calculates the distance between two points on a plane (the distance formula)
									*/
									const distanceFormula = function (x1, y1, x2, y2) {
										const x_distance = Math.pow(x2 - x1, 2);
										const y_distance = Math.pow(y2 - y1, 2);
										const sum_x_y_distance = x_distance + y_distance;
										return Math.sqrt(sum_x_y_distance);
									};
									console.log(distanceFormula(0, 0, 1, 2));
									/*
									This outputs to the console:
									2.23606797749979
									*/
								</code>
							</pre>
				<p>Because functions are essentially objects, we can store as many functions as we want in an array, or in an object.</p>
			</section>

			<section id="when_to_use_a_function_expression" class="grid-item">
				<h4>When Should We Use a Function Expression Instead of a Function Declaration?</h4>
				<p>If the most efficient way to accomplish a task is to pass a function as an argument, then function expressions are much more ideal than function declarations. This is because function expressions can be passed through as arguments, stored in objects and iterables, as well as shorter:</p>
				<pre class="language-javascript">
								<code>
									/*
									Suppose we have several chunks of code that we routinely use in our program. It would be very helpful to store these functions in an object, and then call the functions whenever we need to. 
									*/
									const distanceFormula = function (x1, y1, x2, y2) {
										const x_distance = Math.pow(x2 - x1, 2);
										const y_distance = Math.pow(y2 - y1, 2);
										const sum_x_y_distance = x_distance + y_distance;
										return Math.sqrt(sum_x_y_distance);
									};
									const lineSlope = function (x1, y1, x2, y2) {
										const y_distance = y2 - y1;
										const x_distance = x2 - x1;
										return y_distance / x_distance;
									};
									const rectangleArea = function (length, width) {
										return length * width;
									};
									const circleArea = function (radius) {
										return Math.PI * Math.pow(radius, 2);
									};
									const circleCircumference = function (radius) {
										return 2 * Math.PI * radius;
									};

									// Let's store the functions we've created in an object. When we do this, we create methods.
									const mathOps = {
										distanceLinePoints: distanceFormula,
										slopeLine: lineSlope,
										areaRectangle: rectangleArea,
										areaCircle: circleArea,
										perimeterCircle: circleCircumference,
									};
									// We can now call the functions with the object:
									console.log(mathOps.distanceLinePoints(2, 1, 4, 5)); // Returns 4.47213595499958
									console.log(mathOps.slopeLine(3, 3, 5, 8)); // Returns 2.5
									console.log(mathOps.areaRectangle(3.3, 5.89)); // Returns 19.436999999999998
									console.log(mathOps.areaCircle(7.93)); // Returns 197.55873986172875
									console.log(mathOps.perimeterCircle(4.325)); // Returns 27.17477645355171
								</code>
							</pre>
				<p>By storing the functions in an object, we have turned the functions into <span class="term">methods</span>. Similarly, we can store functions in an array:</p>
				<pre class="language-javascript">
									<code>
										/*
										Here is an array of functions. By placing functions inside arrays, we can create a more complex function where the order of performing the functions matters.
										*/
										const isInteger = function (num) {
											if (num - Math.floor(num) !== 0) {
												return false;
											}
											return true;
										};
										const isEven = function (num) {
											if (num % 2 === 0) {
												return true;
											}
											return false;
										};
										const isDivisibleBy4 = function (num) {
											if (num % 4 === 0) {
												return true;
											}
											return false;
										};
										const integerTest = [isInteger, isEven, isDivisibleBy4];
	
										for (let i = 0; i < integerTest.length; i++) {
											console.log(integerTest[i](9));
										}
										/*
										This displays in the console:
	
										true
										false
										false
										*/									
									</code>
								</pre>
				<p>
					Placing functions inside arrays is a powerful tactic for creating complex functions. Because order matters in an array, combining a
					<span class="monoText">for</span> loop with an array of functions allows us to perform complicated computations where order matters&ndash;essentially, <span class="term">algorithms</span>.
				</p>
			</section>

			<section id="arrow_functions" class="grid-item">
				<h4>Arrow Functions</h4>
				<p>An <span class="term">arrow function</span> is just a more compact way of writing a function expression. The arrow function's general syntax (this website's code formatting automatically converts "=>" into a block arrow; the actual syntax is "=>"):</p>
				<pre class="language-javascript">
							<code>
								const <span class="greyText italicsText">variable-name</span> = (<span class="greyText italicsText">parameter</span>) => {
									<span class="greyText italicsText">statements</span>;
								}
							</code>
						</pre>
				<p>Example:</p>
				<pre class="language-javascript">
							<code>
								const square = (x) => {
									return x * x;
								}
								console.log(square(4));
								/*
								Console output:
								16
								*/
							</code>
						</pre>
				<p>Another example:</p>
				<pre class="language-javascript">
							<code>
								const evenTest = (num) => {
									return num % 2 === 0;
								}
								console.log(evenTest(8));
								/*
								This function tests whether a number is even. Here, we passed the number 8, and the output:

								true
								*/
							</code>
						</pre>
				<p>If you have <span class="underlineText">only one</span> parameter, you can omit the parentheses:</p>
				<pre class="language-javascript">
								<code>
									const circumference = radius => {
										return 2 * Math.PI * radius;
									}
									console.log(circumference(3));
	
									/*
									Console output:
	
									18.84955592153876
									*/
								</code>
							</pre>
				<p>
					However, note that we can write arrow functions without parentheses
					<span class="underlineText">if and only if</span> we have one parameter to the function. If the arrow function is an anonymous function, you <span class="underlineText">must</span> include parentheses.
				</p>
			</section>

			<section id="arrow_functions_and_implicit_returns" class="grid-item">
				<h3>Arrow Functions and Implicit Returns</h3>
				<p>
					We can write arrow functions even more compactly with
					<span class="term">implicit returns</span>.This will only work in certain situations. To see how implicit returns are more compact, examine:
				</p>
				<pre class="language-javascript">
							<code>
								const circumference = function (radius) { // A regular function expression
									return 2 * Math.PI * radius;
								};

								const circumference = (radius) => { // An regular arrow function
									return 2 * Math.PI * radius;
								}

								const circumference = radius => { // An arrow function without parentheses
									return 2 * Math.PI * radius;
								}

								const circumference = radius => ( // An implicit return (no return statement)
									2 * Math.PI * radius
								);

								const circumference = radius => 2 * Math.PI * radius; // A one-line implicit return
								console.log(circumference(3));					
								/*
								For all of these expressions, the output to the console:

								18.84955592153876
								*/
							</code>
						</pre>
				<p>
					Notice how for <span class="term">implicit returns</span>, there are no parentheses around the function's alias, and there is no <span class="monoText">return</span> statement. They can also be written in one line. Implicit returns (particularly one-line syntax) are attractive because they're short, concise, and take up less lines. But, if the function takes many parameters, consider writing the function in other syntax: readable code is much easier to debug and work with. More importantly, use arrow functions
					<span class="underlineText">only if the function's body consists of 1 expression. JavaScript does not know what to do if you wrote the following:</span>
				</p>
				<pre class="language-javascript">
								<code>
									/*
									Say I want to square a number and also determine whether the passed through number is divisible by 4
									*/
									const specialSquare = num => (
										num * num
										if (num % 4 === 0) {
											return true;
										}
									);
									console.log(specialSquare(4));
									/*
									On the console, we get the following error:

									SyntaxError: Unexpected token 'if'
									*/
								</code>
							</pre>
				<p>The above error is occurring because we put in more than one expression.</p>
			</section>

			<section id="implicit_returns_and_arrays" class="grid-item">
				<h4>Using Implicit Returns and Arrays</h4>
				<p>Implicit returns allow us to concisely write functions operating on arrays. Consider the following code using the map method, written in regular function syntax:</p>
				<pre class="language-javascript">
							<code>
								/*
								I have an array of Fibonacci numbers, and I want to multiply each of them by euler's constant, and map the returned values into a new array.
								*/
								const fibonacciNumbers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
								const fibonacciEulerProducts = fibonacciNumbers.map(function (n) {
									return n * Math.E;
								});
								console.log(fibonacciEulerProducts);
								/*
								The console output:

								[
								0,
								2.718281828459045,
								2.718281828459045,
								5.43656365691809,
								8.154845485377136,
								13.591409142295225,
								21.74625462767236,
								35.337663769967584,
								57.08391839763995,
								92.42158216760754,
								149.50550056524747,
								241.927082732855,
								391.4325832981025
								]
								*/
							</code>
						</pre>
				<p>The code above can be written shorter with an arrow function:</p>
				<pre class="language-javascript">
							<code>
								const fibonacciNumbers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];		
								const fibonacciEulerProducts = fibonacciNumbers.map(n => {
									return n * Math.E;
								});
								console.log(fibonacciEulerProducts);									
							</code>
						</pre>
				<p>And it can be written even shorter with an implicit return:</p>
				<pre class="language-javascript">
							<code>
								const fibonacciNumbers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
								const fibonacciEulerProducts = fibonacciNumbers.map(n => n * Math.E);
								console.log(fibonacciEulerProducts);
							</code>
						</pre>
				<p>Bottom line: Implicit returns when used with array methods are conducive to concise code. But, remember: We can only have one expression with arrow functions (and by implication, implicit returns). Thus, to get around this problem, we need to write code in a single expression. If that is not possible, then we need to use a regular function expression, or define a function elsewhere in the code, and pass that function as an argument.</p>
			</section>

			<section id="ternary_operators_implicit_returns" class="grid-item">
				<h4>Implicit Returns and Ternary Operators</h4>
				<p>
					If the function to be used in a
					<span class="monoText">.map()</span> or <span class="monoText">.forEach()</span> method consists of a Boolean expression that only returns one of two values given the array, then we can use a <a href="#ternary_operator">ternary operator</a> to short the code even further. Suppose:
				</p>
				<p></p>
				<pre class="language-javascript">
							<code>
								/*
								Here is an array of the values for the partition function for the numbers 1 to 8. (The partition function tells us the number of possible partitions for a number; e.g., the number 3 has 3 partitions: 3+0, 1+2, 1+1+1). Say I want to determine if the each of the values are odd or even.
								*/
								const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
								// We can write the map method's function with regular function notation:
								const partitionNumParity = partitionNum.map(function (n) {
									if (n % 2 === 0) return 'even';
									return 'odd';
								});
								console.log(partitionNumParity);			
								
								/*
								Console output: 
								[
								'odd', 'even',
								'odd', 'odd',
								'odd', 'odd',
								'odd', 'even'
								]
								*/
							</code>
						</pre>
				<p>Shortening the code above:</p>
				<pre class="language-javascript">
							<code>
								const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
								const partitionNumParity = partitionNum.map((n) => {
									if (n % 2 === 0) return 'even';
									return 'odd';
								});
								console.log(partitionNumParity);		
							</code>
						</pre>
				<p>We can write it with an implicit return, but to do so, we cannot have multiple return statements (those are multiple expressions!). To get around this problem, we use a ternary operator:</p>
				<pre class="language-javascript">
								<code>
							const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
							const partitionNumParity = partitionNum.map((n) =>
								n % 2 === 0 ?  'even' : 'odd'
							);
							console.log(partitionNumParity);		
								</code>
							</pre>
				<p>Or, in a single line:</p>
				<pre class="language-javascript">
								<code>
									const partitionNum = [1, 2, 3, 5, 7, 11, 15, 22];
									const partitionNumParity = partitionNum.map((n) => n % 2 === 0 ? 'even' : 'odd');
									console.log(partitionNumParity);	
								</code>
							</pre>
			</section>

			<section id="default_parameters" class="grid-item">
				<h3>Setting Default Parameters</h3>

				<p>In many situations, we want to add default parameter values to a function.</p>
				<pre class="language-javascript">
							<code>
								// Suppose we have a rudimentary function for calculating a spring's tension: 
								function springTension(k, x) {
									return -k * x;
								}
								// In the function above, we want to make sure that the values passed in are numbers. 
								// Passing the number 3.4 and 6.9:
								// Test
								console.log(springTension(3.4, 6.9)); // Output: -23.46

								// But, if we leave a number out:
								console.log(springTension(1)); // Output: NaN
								// We get NaN because we did not pass a second argument in, so x is set to undefined.

								// One way to avoid this problem is to display in the console instructions:
								function springTension2(k, x) {
									if (typeof k === 'undefined' || typeof x === 'undefined') {
										console.log('2 numbers must be passed');
									} else {
										return -k * x;
									}
								};
								// Test:
								console.log(springTension2(3.4, 6.9)); // Output: -23.46
								console.log(springTension2(3)); // Output: 2 numbers must be passed

								// Another way to avoid this problem is to set a default value:
								function springTension3(k, x = 1) { // Notice that we set x = 1. This is the default value.
									return -k * x;
								};
								// Test: 
								console.log(springTension3(3.4, 6.9)); // Output: -23.46
								console.log(springTension3(3.4)); // Output: -3.4								
							</code>
						</pre>
			</section>

			<section id="higher_order_functions" class="grid-item">
				<h3>Higher Order Functions</h3>
				<p><span class="term">Higher order functions</span> are simply functions that operate <span class="italicsText">on</span> or <span class="italicsText">with other</span> functions. These are functions that take other functions as arguments, or return functions as output. <span class="italicsText">Higher order functions</span> are a staple programming pattern; they are used routinely for a wide variety of tasks. For example, a function that takes a function as an argument is a higher order function:</p>
				<pre class="language-javascript">
							<code>
								/*
								Here is an example of a function that takes a function as an argument.
								*/
								// First, let's make a generic function to pass through to the higher order function.
								function shake() {
									console.log("shake shake shake shake bird! shake shake shake");
								}
								// Then, let's create a higher order function:
								function tooMuchAdderall(func) { // Remember, "func" is just a placeholder name!
									func(); //That placeholder name is attached to the parentheses
									func();
								}
								// Call the higher order function:
								tooMuchAdderall(shake);
								/*
								This outputs to the console:

								shake shake shake shake bird! shake shake shake
								shake shake shake shake bird! shake shake shake
								*/
							</code>
						</pre>
				<p>
					We can have a higher order function execute a function passed as an argument an $x$ amount of times by using a
					<span class="monoText">for</span> loop in the higher function:
				</p>
				<pre class="language-javascript">
							<code>
								// Function to be passed as an argument:
								function shake() {
									console.log("shake shake shake shake bird! shake shake shake");
								}
								// The higher order function that will take the function as an argument:
								function tooMuchAdderall(func, numberOfExecutions) {
									for (let i = 0; i < numberOfExecutions; i++) {
										func();
									}
								}
								// Call the higher order function:
								tooMuchAdderall(shake, 5);

								/*
								Console output:

								shake shake shake shake bird! shake shake shake
								shake shake shake shake bird! shake shake shake
								shake shake shake shake bird! shake shake shake
								shake shake shake shake bird! shake shake shake
								shake shake shake shake bird! shake shake shake
								*/
							</code>
						</pre>
				<p>Another higher order function is a function that returns a function. These higher order functions are essentially "function factories"&mdash;they take the arguments passed to them, and output a function. Remember: Functions are essentially data like numbers or strings, so they can be passed to other functions as arguments, and returned by other functions.</p>
				<pre class="language-javascript">
								<code>
									/*
									Suppose we have an array containing objects. The objects list the math fields the college currently has expert mathematicians in, and the number of mathematicians in those fields.
									*/
									const popularMathFields = [
										{ field: "nonassociative rings and algebras", mathematicians: 1 },
										{ field: "category theory", mathematicians: 1 },
										{ field: "lie groups", mathematicians: 4 },
										{ field: "ordinary differential equations", mathematicians: 12 },
										{ field: "partial differential equations", mathematicians: 14 },
										{ field: "operator theory", mathematicians: 12 },
										{ field: "statistics", mathematicians: 28 },
										{ field: "probability theory", mathematicians: 3 },
									];
									/* 
									I'm now reviewing some job applicants for a new position in my math department. The applicants have applied for the fields in the array above, but there are still a lot of applicants. I want to make sure I'm only hiring an applicant if their field has a minimum of x and a maximum of y mathematicians in my department, to be determined later on. How do we do this? One way is to use a higher order function.
									*/
									function inBetweenFunc(min, max) { // The higher order function
										return function (applicantField) { // The outputted function
											for (let element of popularMathFields) { // Target objects in array
												while (applicantField === element.field) { // Make sure field is offered
													if ( // Check if the number of mathematicians is within range
														element.mathematicians >= min &&
														element.mathematicians <= max) 
													{ // Within range? Do this.
														return console.log(`${applicantField} meets range.`); 
													} 
													else { // Not within range? Do this.
														return console.log(`${applicantField} outside range.`); 
													}
												}
											}
										};
									}
									/* 
									Then let's store the inBetweenFunc in a variable, "isFieldNeeded". We've decided that, based on student and market demand and the number of mathematicians, we want the applicant's field to have a minimum of 4 mathematicians in our department, and a maximum of 17 mathematicians:
									*/
									const isFieldNeeded = inBetweenFunc(2, 17);
									// Let's test the function:
									isFieldNeeded("ordinary differential equations");
									isFieldNeeded("lie groups");
									isFieldNeeded("probability theory");
									isFieldNeeded("category theory");
									/*
									The output on the console:
		
									ordinary differential equations meets range.
									lie groups meets range.
									probability theory meets range.
									category theory outside range.
									*/
								</code>
							</pre>
			</section>

			<section id="callback_functions" class="grid-item">
				<h3>Callback Functions</h3>
				<p>A <span class="term">callback function</span> is a function that is passed into another function as an argument, which is then invoked inside the outer function. Example:</p>
				<pre class="language-javascript">
							<code>
								/*
								A common use for callback functions is passing a function into the setTimeout function built in to JavaScript. The setTimeout function calls a function after a certain amount of milliseconds.
								*/
								function poke() {
									console.log("Ouch! Don't poke me.");
								}
								setTimeout(poke, 2000);

								/*
								After 2000 milliseconds (2s), the console displays:

								Ouch! Don't poke me.
								*/
							</code>
						</pre>
			</section>

			<section id="for_each_method" class="grid-item">
				<h4>The <span class="monoText">.forEach()</span> Method</h4>

				<p>The <span class="monoText">.forEach()</span> method tells JavaScript: "For each element in the array, execute this function." The general syntax of the <span class="monoText">.forEach()</span> method:</p>
				<pre class="language-javascript">
								<code>
									<span class="greyText italicsText">array-name</span>.forEach(<span class="greyText italicsText">function-name</span>);
								</code>
							</pre>
				<p>Here's an example:</p>

				<pre class="language-javascript">
							<code>
								/*
								I have an array of primes, and I want to square each of the primes and modulate that square by pi. We could use a for loop or pass each of the elements into a function one by one, but there's a faster way: the forEach method.
								*/

								// Suppose we have this array of primes:
								const primes = [1, 3, 5, 7, 11, 13];
								function primePiModulate(n) {
									console.log((n * n) % Math.PI);
								}
								primes.forEach(primePiModulate);		
								/*
								Outputted to the console:

								1
								2.7168146928204138
								3.008851424871448
								1.8761101961531033
								1.6194791635878616
								2.495589359740965
								*/						
							</code>
						</pre>
			</section>

			<section id="map_method" class="grid-item">
				<h4>The <span class="monoText">.map</span> Method</h4>

				<p>
					The <span class="monoText">.map()</span> method creates a new array with the results of calling a<span class="italicsText">call back function</span>
					on every element in the array.
				</p>
				<p>
					The general syntax for the
					<span class="monoText">.map()</span> method:
				</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText italicsText">array-name</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>]; 
									const <span class="greyText italicsText">variable-name</span> = <span class="greyText italicsText">array-name</span>.map(function() {
										<span class="greyText italicsText">statements</span>;
									});
								</code>
							</pre>
				<p>Application:</p>
				<pre class="language-javascript">
								<code>
									/*
									I have an array of different radii, and I want to find the circumference for their corresponding circles. 
									*/
									const radii = [1, 3, 5, 7, 11, 13, 17];
									const circumferences = radii.map(function (num) {
										return num * 2 * Math.PI;
									});
									console.log(circumferences);		
									
									/*
									Console output:
									[
										6.283185307179586,
										18.84955592153876,
										31.41592653589793,
										43.982297150257104,
										69.11503837897544,
										81.68140899333463,
										106.81415022205297
									]
									*/

									// Remember: num is just an alias (or placeholder)---each of the elements in the array are passed through to the function and are used as "num"
								</code>
							</pre>
			</section>

			<section id="find_method" class="grid-item">
				<h4>The <span class="monoText">.find()</span> Method</h4>

				<p>The <span class="monoText">.find()</span> method returns the value of the first element in an array that satisfies a test condition. General syntax:</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
									const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.find(<span class="greyText italicsText">alias</span> => <span class="greyText italicsText">test-condition</span>);
								</code>
							</pre>
				<p>
					Of course, we can write the
					<span class="monoText">.find()</span> method with the usual function notations: Using the <span class="monoText">.find()</span> method with a regular function expression:
				</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
									const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.find(function(element) {
										return <span class="greyText italicsText">test-condition</span>;
									});
								</code>
							</pre>
				<p>Example:</p>
				<pre class="language-javascript">
								<code>
									// Here's an array of objects containing different hydrogen compounds. 
									const chemicals = ['hydrogen peroxide', 'hyponitrous acid', 'hydrogen fluoride', 'hydrogen cyanide', 'hydrogen sulfide', 'lead hydrogen arsenate'];
									// I want to find the first element that contains "sulfide".
									let firstSulfide = chemicals.find(element => {
										return element.includes('sulfide')
									});
									console.log(firstSulfide);
									/*
									Console output:

									hydrogen sulfide
									*/
								</code>
							</pre>
				<p>The <span class="monoText">.find()</span> method does not change the array, since its only performing a simply find/search. Here's another example, an array containing objects with data:</p>
				<pre class="language-javascript">
								<code>
									// Here I have an array of objects, containing chemicals and their atomic masses.
									const chemicals = [
										{chemical: 'krypton', atomic_mass: 83.8},
										{chemical: 'hydrogen', atomic_mass: 1.0079},
										{chemical: 'zirconium', atomic_mass: 91.224},
										{chemical: 'phosphorus', atomic_mass: 30.9738},
										{chemical: 'boron', atomic_mass: 10.811},
										{chemical: 'erbium', atomic_mass: 167.259},
										{chemical: 'sodium', atomic_mass: 22.9897},
										{chemical: 'sulfur', atomic_mass: 32.065},
										{chemical: 'barium', atomic_mass: 137.327},
									]
									// I want to find the first element with an atomic mass greater than 13.982 and less than 43.764
									const specialChemical = chemicals.find(element => 
										element.atomic_mass > 13.982 && 
										element.atomic_mass < 43.764
									);
									console.log(specialChemical);
									/*
									Console output:

									{ chemical: 'phosphorus', atomic_mass: 30.9738 }
									*/									
								</code>
							</pre>
				<p>Note that the <span class="monoText">.find()</span> method is case sensitive. Further note: The <span class="monoText">.find()</span> method only searches for the first element that matches the provided condition, and returns that element. This implies several things:</p>
				<ol>
					<li>The <span class="monoText">.find()</span> method only works if we provide it a condition&mdash;an expression that will only evaluate to true or false.</li>
					<li>The <span class="monoText">.find()</span> method stops its search at the first match. It will not continue searching for other matches.</li>
				</ol>
			</section>

			<section id="filter_method" class="grid-item">
				<h3>The <span class="monoText">.filter()</span> Method</h3>

				<p>The <span class="monoText">.filter()</span> method creates a new array of elements that satisfies a condition. Filter allows us to "filter out" subsets of elements inside an array. The method works as such:</p>
				<ol>
					<li>
						We have an array, and we execute the
						<span class="monoText">.filter()</span> method on the array.
					</li>
					<li>
						In our .filter() method, we have a
						<span class="term">test function</span>. That test function contains a condition.
					</li>
					<li>JavaScript looks at each of the array's elements, and checks whether the element meets the condition.</li>
					<li>If the element meets the condition, the element is put into a new array, and JavaScript moves to the next element.</li>
					<li>If the element does not meet the condition, the element is ignored, and JavaScript moves to the next element.</li>
					<li>JavaScript continues until it has gone through the entire array.</li>
				</ol>
				<p>The <span class="monoText">.filter()</span> method takes the following form:</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
									const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.filter(<span class="greyText italicsText">alias</span> => <span class="greyText italicsText">test-condition</span>);									
								</code>
							</pre>
				<p>Or, with a regular function expression:</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
									const <span class="greyText italicsText">variableName</span> = <span class="greyText italicsText">arrayName</span>.filter(function(element) {
										return <span class="greyText italicsText">test-condition</span>;
									});									
								</code>
							</pre>
				<p>Simple example:</p>
				<pre class="language-javascript">
								<code>
									// Here's an array of numbers.
									// I want all of the even numbers stored in a new array. 
									const nums = [1, 5, 9, 8, 7, 3, 5, 11, 17, 14];
									const evenNums = nums.filter(elements => elements % 2 === 0); 
									// Check if it worked:
									console.log(evenNums);
									/*
									Console output: 

									[ 8, 14 ]
									*/

									/*
									What is the above code doing? We told JavaScript: "JS, for the array <span class="italicsText">nums</span>, I want you to do the following:
									(1) look at each of the elements in the array one by one, 
									(2) check if the element meets this condition: elements % 2 === 0, 
									(3) if the element meets the condition, place it in a new array; otherwise, ignore it, 
									(4) move to the next element, 
									(5) continue until you've gone through the entire array, and 
									(4) store that resulting array in this variable <span class="italicsText">evenNums</span>".
									*/									
								</code>
							</pre>
				<p>A more complex example:</p>

				<pre class="language-javascript">
							<code>
								/* I have an array of different polymers (materials made of large molecules bonded together; e.g., plastics and resins), and some of their properties.
								*/
								const polymers = [
									{
										polymer: 'polyvinyl chloride (PVC)',
										melting_point: 100,
										uses: ['pipes', 'fencing', 'bottles', 'raincoats', 'toys'],
										food_safe: false
									},
									{
										polymer: 'polypropylene (PP)',
										melting_point: 130,
										uses: ['auto parts', 'food containers', 'dishware'],
										food_safe: true
									},
									{
										polymer: 'polyethylene terephthalate (PET)',
										melting_point: 260,
										uses: ['bottles', 'fleece', 'carpet'],
										food_safe: true
									},
									{
										polymer: 'high-density polyethylene (HDPE)',
										melting_point: 130.8,
										uses: ['bottles', 'containers', 'plastic bags'],
										food_safe: true
									},
									{
										polymer: 'low-density polyethylene (LDPE)',
										melting_point: 110,
										uses: ['bottles', 'toys', 'six pack rings', 'pipes'],
										food_safe: true
									},
									{
										polymer: 'polystyrene',
										melting_point: 270,
										uses: ['petri dishes', 'plastic cutlery'],
										food_safe: false
									}
								];
								// I want to see all of the polymers that have a melting point greater than 113, but only show me their names.
								const hotPolymers = polymers.filter(elements => elements.melting_point > 113);
								for (let element of hotPolymers) {
									console.log(element.polymer);
								};
								/*
								Console output:

								polypropylene (PP)
								polyethylene terephthalate (PET)
								high-density polyethylene (HDPE)
								polystyrene
								*/

								// Now I want to see all of the polymers that are food safe. 
								const foodSafePolymers = polymers.filter(elements => elements.food_safe === true);
								for (let element of foodSafePolymers) {
									console.log(element.polymer)
								};

								/*
								Console output: 

								polypropylene (PP)
								polyethylene terephthalate (PET)
								high-density polyethylene (HDPE)
								low-density polyethylene (LDPE)
								*/

								// Finally, show me all of the polymers that are good for bottles.
								// Finally, show me all of the polymers that are good for bottles.
								const bottlePolymers = polymers.filter(elements => (
									elements.uses.includes("bottles")
								));
								for (let element of bottlePolymers) {
									console.log(element.polymer)
								};

								/*
								Console output: 

								polyvinyl chloride (PVC)
								polyethylene terephthalate (PET)
								high-density polyethylene (HDPE)
								low-density polyethylene (LDPE)
								*/
							</code>
						</pre>
			</section>

			<section id="filter_method_and_search_inputs" class="grid-item">
				<h4>Using the <span class="monoText">.filter()</span> Method for Search Inputs</h4>

				<p>Suppose we have a search feature, and when the user inputs a word in the text field, that input is used to search for a match.</p>
				<p>
					How do we implement this feature in JavaScript? We can use the
					<span class="monoText">.filter()</span> method:
				</p>

				<pre class="language-javascript">
						<code>
							/* 
							Let's use the same array from the preceding example. 
							We want a user to input the polymer use they want, and then we output the polymer.
							*/
							const polymers = [
								{
									polymer: 'polyvinyl chloride (PVC)',
									melting_point: 100,
									uses: ['pipes', 'fencing', 'bottles', 'raincoats', 'toys'],
									food_safe: false
								},
								{
									polymer: 'polypropylene (PP)',
									melting_point: 130,
									uses: ['auto parts', 'food containers', 'dishware'],
									food_safe: true
								},
								{
									polymer: 'polyethylene terephthalate (PET)',
									melting_point: 260,
									uses: ['bottles', 'fleece', 'carpet'],
									food_safe: true
								},
								{
									polymer: 'high-density polyethylene (HDPE)',
									melting_point: 130.8,
									uses: ['bottles', 'containers', 'plastic bags'],
									food_safe: true
								},
								{
									polymer: 'low-density polyethylene (LDPE)',
									melting_point: 110,
									uses: ['bottles', 'toys', 'six pack rings', 'pipes'],
									food_safe: true
								},
								{
									polymer: 'polystyrene',
									melting_point: 270,
									uses: ['petri dishes', 'plastic cutlery'],
									food_safe: false
								}
							];
							// JavaScript receives the user's input, and we store it in a variable:

							let query = 'toys';

							// Then we do the search (remember, .filter is case sensitive, so we want to make sure the user's input is all lower case--otherwise, if the user inputs a use in capital letters, JavaScript won't be able to find matches)

							const results = polymers.filter(elements => {
								return elements.uses.includes(query.toLowerCase())
							});

							// The search returns the array with the matching objects with all of their properties. 
							// Let's store the name of the matching polymers in a separate array:

							const resultPolymerNames = results.map(function (elements) {
								return elements.polymer;
							})

							// Check if it works:

							console.log(resultPolymerNames); 

							/*
							console output: 

							[ 'polyvinyl chloride (PVC)', 'low-density polyethylene (LDPE)' ]
							*/		
						</code>
					</pre>
			</section>

			<section id="every_method" class="grid-item">
				<h4>The <span class="monoText">.every()</span> Method</h4>

				<p>The <span class="monoText">.every()</span> method tests whether <span class="underlineText">all</span> of the elements in an array satisfy a condition, and returns a Boolean value (either <span class="greenText">true</span> or <span class="redText">false</span>). Because the <span class="monoText">.every()</span> method only returns Boolean values, it is called a <span class="term">Boolean method</span>. The <span class="monoText">.every()</span> method takes the following form:</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText">array-name</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
									<span class="greyText">array-name</span>.every(element => {
										<span class="greyText italicsText">test-condition</span>;
									});
								</code>
							</pre>
				<p>A simple example:</p>
				<pre class="language-javascript">
								<code>
									// Here's an array of shapes:
									const words = ['circle', 'square', 'rhombus', 'triangle', 'pentagon', 'hexagon', 'octagon'];
									// Say I want to check if every word is more than 4 letters long:
									const all_words_are_three = words.every(word => word.length >= 4);
									console.log(all_words_are_three);
									/*
									Output: 

									true
									*/									
								</code>
							</pre>
				<p>Another example:</p>
				<pre class="language-javascript">
								<code>
									/* We're conducting research on the history of science for certain metallic elements, and our researchers enter the names of the chemicals they worked on, which are then passed into an array. We want to make sure that every element entered by a researcher ends with "um" (all metallic elements discovered after 1811 have names ending in "um"). Suppose the inputs are passed into the array below:
									*/
									const studiedElements = ['cadmium', 'lanthanum', 'lithium', 'thallium', 'radium', 'aluminum'];
									const testEndUm = studiedElements.every(element => {
										return element.includes('um') === true;
									});
									console.log(testEndUm);
									/*
									Console output: 

									true
									*/

									// If we put "arsenic" in the array:
									const studiedElements = ['cadmium', 'lanthanum', 'lithium', 'thallium', 'radium', 'aluminum', 'arsenic'];
									const testEndUm = studiedElements.every(element => {
										return element.includes('um') === true;
									});
									console.log(testEndUm);
									/*
									Console output: 

									false
									*/
								</code>
							</pre>
			</section>

			<section id="some_method" class="grid-item">
				<h4>The <span class="monoText">.some()</span> Method</h4>
				<p>The <span class="monoText">.some()</span> method tests whether <span class="underlineText">at least one</span> element in an array satisfies a condition. The general syntax of the <span class="monoText">.some()</span> method:</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText">array-name</span> = [<span class="greyText italicsText">element-1</span>, <span class="greyText italicsText">element-2</span>, <span class="greyText italicsText">element-3</span>];
									<span class="greyText">array-name</span>.some(element => {
										<span class="greyText italicsText">test-condition</span>;
									});									
								</code>
							</pre>
				<p>Illustration:</p>
				<pre class="language-javascript">
								<code>
									// We've made a piece of software, and we want to put it to a focus group. But we want to ensure that there is at least someone in the focus group that does not work in STEM. Below is the array of participants so far, with their data. 
									const focusGroup = [
										{ participantID: '1432', field: 'STEM' },
										{ participantID: '8723', field: 'retail' },
										{ participantID: '9823', field: 'STEM' },
										{ participantID: '9242', field: 'STEM' },
										{ participantID: '7699', field: 'STEM' },
									];
									// We can check this requirement with the some method.
									// Test condition: There is <span class="underlineText">at least one</span> element with a field that is <span class="underlineText">not</span> 'STEM'.
									const groupTest = focusGroup.some(participant => {
										return participant.field !== 'STEM';
									});
									console.log(groupTest);
									/*
									Output: 
									true
									*/

									// If we remove the element with the field 'retail':
									const focusGroup = [
										{ participantID: '1432', field: 'STEM' },
										{ participantID: '9823', field: 'STEM' },
										{ participantID: '9242', field: 'STEM' },
										{ participantID: '7699', field: 'STEM' },
									];
									const groupTest = focusGroup.some(participant => {
										return participant.field !== 'STEM';
									});
									console.log(groupTest);
									/*
									Output: 
									false
									*/							
								</code>
							</pre>
			</section>

			<section id="sort_method_with_callbacks" class="grid-item">
				<h4>Using the <span class="monoText">.sort()</span> Method with Callback Functions</h4>

				<p>
					Recall that the <span class="monoText">.sort()</span> method, by default, converts numbers into their UTF codes (values of type string), and orders them alphabetically ascending. <a href="#sort()_method"><span class="italicsText">See infra</span> Sort the Values in an Array: .sort()</a>. To review: In order to use execute the <span class="monoText">.sort()</span> method on an array of numbers, such that the numbers are sorted according to their numeric values, we need to use a <span class="term">compare function</span>. The <span class="term">compare function</span> takes the form:
				</p>
				<pre class="language-javascript">
							<code>
								<span class="greyText italicsText">arrayName</span>.sort(<span class="greyText italicsText">compareFunc</span>(<span class="greyText italicsText">a</span>, <span class="greyText italicsText">b</span>))
							</code>
						</pre>

				<p>If <span class="italicsText">compareFunc</span>(<span class="italicsText">a</span>, <span class="italicsText">b</span>) returns a number less than 0, JavaScript sorts <span class="italicsText">a</span> before <span class="italicsText">b</span>. If <span class="italicsText">compareFunc</span>(<span class="italicsText">a</span>, <span class="italicsText">b</span>) returns 0, JavaScript leaves the order of <span class="italicsText">a</span> and <span class="italicsText">b</span> as is. If <span class="italicsText">compareFunc</span>(<span class="italicsText">a</span>, <span class="italicsText">b</span>) returns a number greater than 0, JavaScript sorts <span class="italicsText">b</span> before <span class="italicsText">a</span>.</p>

				<p>Illustration:</p>
				<pre class="language-javascript">
							<code>
								const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
								const ascendingSort = randomNums.sort((a, b) => a - b);
								console.log(ascendingSort);
								/*
								Output:
								[ 0.43, 1.546, 2.334, 5.566, 7.89, 8.22, 9.32, 9.823, 14.234, 14.321, 15.442 ]
								*/									
							</code>
						</pre>
				<p>Above, we sorted the numbers from least to greatest. But, we can also sort the numbers from greatest to least:</p>
				<pre class="language-javascript">
							<code>
								const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
								const descendingSort = randomNums.sort((a, b) => b - a);
								console.log(descendingSort);

								/*
								Output:
								[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
								*/									
							</code>
						</pre>
				<p>
					What did we do differently? We switched
					<span class="italicsText">b</span> and <span class="italicsText">a</span>.
				</p>
				<p>
					If we apply the
					<span class="monoText">.sort()</span> method to an existing array, without any other code instructing JavaScript on what to do with the outputted array, the original array is changed.
				</p>
				<p>You can see this with the array from the example above:</p>
				<pre class="language-javascript">
							<code>
								const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
								const descendingSort = randomNums.sort((a, b) => b - a);
								// If we display in the console the descending sorted array:
								console.log(descendingSort);
								/*
								Output:
								[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
								*/

								// If we display in the console the original array, <span class="italicsText">randomNums</span>
								console.log(randomNums);
								/*
								Output: 
								[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
								*/										
							</code>
						</pre>
				<p>There are several ways to prevent this from happening. One way is to make a separate variable containing the array to be sorted:</p>
				<pre class="language-javascript">
						<code>
							const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
							const randomNumsDescending = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442]; 
							const descendingSort = randomNumsDescending.sort((a, b) => b - a);
							console.log(descendingSort);
							/*
							Output:
							[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
							*/
							console.log(randomNums);
							/*
							Output: 
							[8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442]
							*/									
						</code>
					</pre>
				<p>
					Another way is to use a method to copy the data into a new array. For example, using the method
					<span class="monoText">.slice()</span>:
				</p>
				<pre class="language-javascript">
						<code>
							const randomNums = [8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442];
							const descendingSort = randomNums.slice().sort((a, b) => b - a);
							console.log(descendingSort);
							/*
							Output: 
							[ 15.442, 14.321, 14.234, 9.823, 9.32, 8.22, 7.89, 5.566, 2.334, 1.546, 0.43 ]
							*/
							console.log(randomNums);
							/*
							Output:
							[ 8.22, 9.32, 1.546, 14.321, 0.43, 2.334, 5.566, 7.89, 9.823, 14.234, 15.442 ]
							*/										
						</code>
					</pre>
			</section>

			<section id="reduce_method" class="grid-item">
				<h3>The <span class="monoText">.reduce()</span> Method</h3>

				<p>The <span class="monoText">.reduce()</span> method takes an array of values, and <span class="italicsText">reduces</span> them down to a single value. The <span class="monoText">.reduce()</span> method has the following syntax:</p>
				<pre class="language-javascript">
								<code>
									const <span class="greyText italicsText">arrayName</span> = [<span class="greyText italicsText">value1</span>, <span class="greyText italicsText">value2</span>, <span class="greyText italicsText">value3</span>];
									<span class="greyText italicsText">arrayName</span>.reduce((<span class="greyText italicsText">accumulator</span>, <span class="greyText italicsText">currentValue</span>) => {
										<span class="greyText italicsText">statements</span>;
									});
								</code>
							</pre>
				<p>The <span class="monoText">.reduce()</span> method has two parameters: the <span class="italicsText">accumulator</span>, which stores the returned value from executing the method, and <span class="italicsText">currentValue</span>, the alias for each of the individual elements in the array. Here is an example of how this method works:</p>
				<pre class="language-javascript">
								<code>
								// Suppose we have an array of numbers:
								const nums = [3, 2, 4, 9, 11, 17];
								const reduceResult = nums.reduce((accumulator, currentValue) => {
									return accumulator + currentValue;
								});
								console.log(reduceResult);
								/*
								Output: 
								46
								*/									
								</code>
							</pre>
				<p>We can visualize what happens in this method with a table:</p>
				<table>
					<thead>
						<th><span class="italicsText">Iteration</span></th>
						<th><span class="monoText">accumulator</span></th>
						<th><span class="monoText">currentValue</span></th>
						<th><span class="monoText">return</span></th>
					</thead>
					<tr>
						<td>first</td>
						<td><span class="monoText">3</span></td>
						<td><span class="monoText">2</span></td>
						<td>
							<span class="monoText">return 3 + 2 = 5</span>
						</td>
					</tr>
					<tr>
						<td>second</td>
						<td><span class="monoText">5</span></td>
						<td><span class="monoText">4</span></td>
						<td>
							<span class="monoText">return 5 + 4 = 9</span>
						</td>
					</tr>
					<tr>
						<td>third</td>
						<td><span class="monoText">9</span></td>
						<td><span class="monoText">9</span></td>
						<td>
							<span class="monoText">return 9 + 9 = 18</span>
						</td>
					</tr>
					<tr>
						<td>fourth</td>
						<td><span class="monoText">18</span></td>
						<td><span class="monoText">11</span></td>
						<td>
							<span class="monoText">return 18 + 11 = 29</span>
						</td>
					</tr>
					<tr>
						<td>fifth</td>
						<td><span class="monoText">29</span></td>
						<td><span class="monoText">17</span></td>
						<td>
							<span class="monoText">return 29 + 17 = 46</span>
						</td>
					</tr>
					<tr>
						<td colspan="4">
							<span class="monoText">return 46</span>
						</td>
					</tr>
				</table>
				<p>
					After the fifth call, the
					<span class="monoText">.reduce()</span> method stops&mdash;it has gone through the entire array (which makes sense, since there are 5 indices in the array). Of course, we are not limited to addition, we can also use the <span class="monoText">.reduce()</span> method with other operators:
				</p>
				<pre class="language-javascript">
								<code>
									// Suppose we have an array of numbers:
									const nums = [3, 2, 4, 9, 11, 17];

									const reduceResult = nums.reduce((accumulator, currentValue) => {
										return accumulator * currentValue;
									});

									console.log(reduceResult);

									/*
									Output: 
									40392
									*/									
								</code>
							</pre>
				<p>
					We can also use the
					<span class="monoText">.reduce()</span> method for more complex computations:
				</p>
				<pre class="language-javascript">
								<code>
									// Suppose we have an array of prices:
									let prices = [1.24, 1.98, 1.46, 1.78, 2.01, 1.92, 2.03 ];
									// I want to find the highest price in the array:
									const peakPrice = prices.reduce((maxPrice, currentValue) => {
										if (currentValue > max) return currentValue;
										return max;
									});
									console.log(peakPrice);
									/*
									Output:
									2.03
									*/									
								</code>
							</pre>
				<p>This table demonstrates what happens in the code above:</p>
				<table>
					<thead>
						<th><span class="italicsText">Iteration</span></th>
						<th><span class="monoText">maxPrice</span></th>
						<th><span class="monoText">currentValue</span></th>
						<th><span class="monoText">return</span></th>
					</thead>
					<tr>
						<td>first</td>
						<td><span class="monoText">1.24</span></td>
						<td><span class="monoText">1.98</span></td>
						<td>
							<ul class="nobullets">
								<li>
									<span class="monoText">1.24 !> 1.98</span>
								</li>
								<li>
									<span class="monoText">return 1.98</span>
								</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>second</td>
						<td><span class="monoText">1.98</span></td>
						<td><span class="monoText">1.46</span></td>
						<td>
							<ul class="nobullets">
								<li>
									<span class="monoText">1.98 > 1.46</span>
								</li>
								<li>
									<span class="monoText">return 1.98</span>
								</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>third</td>
						<td><span class="monoText">1.98</span></td>
						<td><span class="monoText">1.78</span></td>
						<td>
							<ul class="nobullets">
								<li>
									<span class="monoText">1.98 > 1.78</span>
								</li>
								<li>
									<span class="monoText">return 1.98</span>
								</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>fourth</td>
						<td><span class="monoText">1.98</span></td>
						<td><span class="monoText">2.01</span></td>
						<td>
							<ul class="nobullets">
								<li>
									<span class="monoText">1.98 !> 2.01</span>
								</li>
								<li>
									<span class="monoText">return 2.01</span>
								</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>fifth</td>
						<td><span class="monoText">2.01</span></td>
						<td><span class="monoText">1.92</span></td>
						<td>
							<ul class="nobullets">
								<li>
									<span class="monoText">2.01 > 1.92</span>
								</li>
								<li>
									<span class="monoText">return 2.01</span>
								</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>sixth</td>
						<td><span class="monoText">2.01</span></td>
						<td><span class="monoText">2.03</span></td>
						<td>
							<ul class="nobullets">
								<li>
									<span class="monoText">2.01 !> 2.03</span>
								</li>
								<li>
									<span class="monoText">return 2.03</span>
								</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td colspan="4">
							<span class="monoText">return 2.03</span>
						</td>
					</tr>
				</table>
				<p>
					We can write the above code more concisely with the
					<span class="monoText">Math.max()</span> method and an implicit return:
				</p>
				<pre class="language-javascript">
								<code>
									let prices = [1.24, 1.98, 1.46, 1.78, 2.01, 1.92, 2.03 ];
									const peakPrice = prices.reduce((maxPrice, currentValue) => (
										Math.max(maxPrice, currentValue)
									));
									console.log(peakPrice);
									/*
									Output:
									2.03
									*/							
								</code>
							</pre>
				<p>
					We can also pass an initial value (the starting value) for the
					<span class="monoText">.reduce()</span> method to start with (i.e., maybe we want to start the method with a value not in the array); to do so, we use the following syntax:
				</p>
				<pre class="language-javascript">
								<code>
									<span class="greyText italicsText">arrayName</span>.reduce((accumulator, currentValue) => {
										<span class="greyText italicsText">statements</span>;
									}, <span class="greyText italicsText">initialValue</span>)
								</code>
							</pre>
				<p>For example:</p>
				<pre class="language-javascript">
								<code>
									let prices = [1.24, 1.98, 1.46, 1.78, 2.01, 1.92, 2.03];
									// I want to check if there's a price in the array below 1.19:
									const peakPrice = prices.reduce((minPrice, currentValue) => {
										return Math.min(minPrice, currentValue);
									}, 1.19);
									console.log(peakPrice);
									/*
									Output:
									1.19
									*/
									// This means there isn't any price in the array below 1.19
								</code>
							</pre>
			</section>

			<section id="function_calls_spread" class="grid-item">
				<h3>Spread</h3>
				<p>The <span class="term">spread syntax</span> <span class="monoText">(...)</span> allows us to expand an iterable (e.g., an array or string) in places where zero or more arguments or elements are expected, or to expand an object expression in places where zero or more properties are expected. Put simply, <span class="italicsText">spread</span> allows us to expand an iterable or object expression into other places.</p>
				<p>When <span class="italicsText">spread</span> is used for a function call, it expands an iterable into a list of arguments. To be more explicit, consider the code below:</p>
				<pre class="language-javascript"><code>
						// Say we have an array of numbers:

						const arrNums = [13, 5, 9, 11, 3, 2, 18, 17, 1, 6, 0];

						// How do we find the maximum value in this array? One way is to use the Math.max method:

						let arrNumsMax = Math.max(arrNums);
						console.log(arrNumsMax);

						// Problem? It outputs 'NaN'
						// This is because we passed an array's reference into Math.max as an argument, and the Math.max method only takes numbers.
						// Thus, to get around this problem, we need to pass each of the numbers into the method:

						let arrNumsMax2 = Math.max(13, 5, 9, 11, 3, 2, 18, 17, 1, 6, 0);
						console.log(arrNumsMax2); // Output: 18

						// But, this is far too tedious, and it does not work well when we have hundreds or thousands of arrays. 
						// This is a perfect use case for spread:
						let arrNumsSpread = Math.max(...arrNums);
						console.log(arrNumsSpread) // Output: 18								
					</code></pre>
				<p>We can also use <span class="italicsText">spread</span> to create a new array with existing arrays. When this is done, the <span class="italicsText">spread syntax</span> takes the elements from the existing array, and places them into a new array.</p>
				<pre class="language-javascript"><code>
								// We have contractors bidding for a government contract, and we have arrays of their bid prices, corresponding to different days:
								const day1_bids = [3.23, 4.32, 5.32, 5.99, 6.17, 7.88, 7.90, 7.98];
								const day2_bids = [8.15, 8.82, 9.01, 9.05, 9.15, 10.23, 10.25, 10.26];
								const day3_bids = [10.27, 10.29, 11.23, 11.32, 11.35, 11.52, 12.95];
								// We want to create one large array of all of these bid prices. We can do so with the spread syntax:
								const bids = [...day1_bids, ...day2_bids, ...day3_bids];
								console.log(bids);
								/*
								Output:
								[
								3.23,  4.32,  5.32,  5.99,
								6.17,  7.88,   7.9,  7.98,
								8.15,  8.82,  9.01,  9.05,
								9.15, 10.23, 10.25, 10.26,
								10.27, 10.29, 11.23, 11.32,
								11.35, 11.52, 12.95
								]
								*/								
							</code></pre>
				<p>Note: The <span class="italicsText">spread syntax</span>, used in this way, is not doing anything we have already been able to do. The above can be similarly accomplished with the <span class="monoText">.concat</span> method. <span class="italicsText">Spread</span> is more useful when we want to make a copy of an array:</p>
				<pre class="language-javascript"><code>
						// an array of ages:
						const age = [23, 34, 29, 19, 36, 15, 42];
						// a copy of the array:
						const ageCopy = [...age];
						console.log(ageCopy);
						/*
						Output:
						[ 23, 34, 29, 19, 36, 15, 42 ]
						*/								
					</code></pre>
				<p>
					Note that the above does not work for arrays containing arrays or objects. They will not be cloned. While not a common operation,
					<span class="italicsText">spread</span> can also be used to separate the characters in a string as individual elements in an array:
				</p>
				<pre class="language-javascript"><code>
						let greeting = "hello";
						let helloCharacters = [...greeting];
						console.log(helloCharacters);								
					</code></pre>
			</section>

			<section id="spread_object_literals" class="grid-item">
				<h4>Using <span class="italicsText">Spread</span> with Object Literals</h4>
				<p>
					We can also use the
					<span class="italicsText">spread syntax</span> to copy properties from one <span class="italicsText">object literal</span> into another <span class="italicsText">object literal</span>.
				</p>
				<pre class="language-javascript"><code>
							// Here are objects with some properties:
							const gas = { volume: 'indefinite', compressibility: 'easy', flow: 'easy' };
							const liquid = { volume: 'indefinite', compressibility: 'difficult', flow: 'easy' };
							const solid = { volume: 'definite', compressibility: 'difficult', flow: 'difficult' };
							// We're given an element, and we want to add the properties above to the element. 
							const hydrogen = { ...liquid };
							const sulfur = { ...solid };
							const xenon = { ...gas };
							console.log(hydrogen);
							console.log(sulfur);
							console.log(xenon);
							/*
							Output:
							{ volume: 'indefinite', compressibility: 'difficult', flow: 'easy' }
							{ volume: 'definite', compressibility: 'difficult', flow: 'difficult' }
							{ volume: 'indefinite', compressibility: 'easy', flow: 'easy' }
							*/								
						</code></pre>
				<p>We can also add properties on top of copying a property:</p>
				<pre class="language-javascript"><code>
							const gas = { volume: 'indefinite', compressibility: 'easy', flow: 'easy' };
							const liquid = { volume: 'indefinite', compressibility: 'difficult', flow: 'easy' };
							const solid = { volume: 'definite', compressibility: 'difficult', flow: 'difficult' };

							const cerium = {
								...solid,
								atomic_number: 58,
								melting_point: 1068
							};
							console.log(cerium);
							/*
							Output:
							{
							volume: 'definite',
							compressibility: 'difficult',
							flow: 'difficult',
							atomic_number: 58,
							melting_point: 1068
							}
							*/								
						</code></pre>
				<p>Remember, order matters for when we copy properties (or elements) from an object (or array). So, for example:</p>
				<pre class="language-javascript"><code>
								const gas = { volume: 'indefinite', compressibility: 'easy', flow: 'easy' };
								const liquid = { volume: 'indefinite', compressibility: 'difficult', flow: 'easy' };
								const solid = { volume: 'definite', compressibility: 'difficult', flow: 'difficult' };

								// For the object "astatine", I want to copy all of the elements for solid, but set volume to 'indefinite'
								const astatine = {
									...solid,
									volume: 'indefinite'
								};
								console.log(astatine);
								/*
								Output:
								{
								volume: 'indefinite',
								compressibility: 'difficult',
								flow: 'difficult'
								}
								*/								
							</code></pre>
				<p>
					The above example shows that we can both copy properties and change the copied properties, at the same time. When an object is copied with <span class="italicsText">spread</span> into another, new object, the result is two different objects. This means that the objects, while possibly identical in that they contain the same data, have difference <span class="italicsText">references</span>, and as such, are treated as unique and different entities by JavaScript. Just like nested arrays, the <span class="italicsText">spread syntax</span> will not work as a way to copy an object if the object itself contains objects. Furthermore, you cannot <span class="italicsText">spread</span> an object directly into an array (but you can spread an object into an object in an array). The <span class="italicsText">spread syntax</span> only applies to spreading objects into objects. This also means that you cannot <span class="italicsText">spread</span> an object into a function or method
					that can only operate on an iterable (since objects themselves are not iterables).
				</p>
			</section>

			<section id="rest_method" class="grid-item">
				<h4>The <span class="italicsText">Rest</span> Syntax</h4>
				<p>The <span class="italicsText">Rest syntax</span> looks like the <span class="italicsText">Spread syntax</span>, but rather than spreading data, it <span class="italicsText">collects</span> data into <span class="underlineText">a single array</span>. To see how this syntax works, consider a problem we have with the functions we've written so far:</p>
				<pre class="language-javascript"><code>
							// Suppose we want to write a function that computes the sum of numbers passed through it.
							// The problem: the function only works for the parameters we give it:
							function sum(a, b) {
								return a + b;
							}
							console.log(sum(2, 3)); // Works fine. Output: 5
							console.log(sum(1, 3, 5, 8)); // Does not work. Output: 5 4
							// So, if we wanted to sum more numbers, we'd have to add more parameters:
							function sum2(a, b, c, d,) {
								return a + b + c + d;
							}
							// But even then, we can only sum a quantity of numbers equal to the quantity of parameters provided.	
						</code></pre>
				<p>
					One way to get around the problem above is to use the
					<span class="italicsText">arguments object</span>, which is an object available inside every function we write.
				</p>
				<pre class="language-javascript"><code>
								// Using the arguments object:
								function sum() {
									let total = 0;
									for (let i = 0; i < arguments.length; i++) {
										total += arguments[i];
										return total;
									}
								};
								console.log(sum(1, 2, 4, 2, 9)); // Output: 18
								console.log(sum(1, 3)); // Output: 4								
								</code></pre>
				<p>
					The <span class="italicsText">arguments object</span> is <span class="underlineText">not</span> an array, but it is an <span class="italicsText">array-like</span> object. It has a <span class="monoText">.length</span> property, but methods like <span class="monoText">.push()</span> and <span class="monoText">.pop()</span> will not work on it. In essence, the
					<span class="italicsText">arguments object</span>
					contains all of the arguments passed into the function. You see the arguments object by displaying in the console the name
					<span class="monoText">arguments</span>:
				</p>
				<pre class="language-javascript"><code>
										function displayArguments() {
											console.log(arguments);
										}
										
										displayArguments(3, 4, 0, 2, 1);
										/*
										Output:
										[Arguments] { '0': 3, '1': 4, '2': 0, '3': 2, '4': 1 }
										*/								
										</code></pre>
				<p>
					Be very cognizant of this point: the
					<span class="monoText">arguments</span> object <span class="underlineText">is not an array</span>. Consider the following:
				</p>
				<pre class="language-javascript"><code>
												// Suppose we write our sum function using an arguments object and the reduce method:
												function sum() {
													return arguments.reduce((total, currentValue) => {
														return total + currentValue;
													})
												}
					
												console.log(sum(2, 3, 6));
												/*
												Output:
												TypeError: arguments.reduce is not a function
												*/
												// We're getting this error because the .reduce method only works on arrays, and the argument object is NOT an array.		
												</code></pre>
				<p>
					To get around the problem above, one way is to turn the
					<span class="monoText">arguments</span> object into an array:
				</p>
				<pre class="language-javascript"><code>
										function sum() {
											const argsArray = [...arguments]; // Use the spread method to turn the arguments object into an array
											return argsArray.reduce((total, currentValue) => {
												return total + currentValue;
											})
										};
										console.log(sum(2, 3, 6)); // Output: 11								
									</code></pre>
				<p>
					There is no
					<span class="italicsText">arguments object</span>
					inside arrow functions. Instead of using the
					<span class="monoText">arguments</span> objects, we can use the <span class="italicsText">rest syntax</span>:
				</p>
				<pre class="language-javascript"><code>
											function <span class="greyText italicsText">functionName</span>(...<span class="greyText italicsText">parameters</span>) {
												return <span class="greyText italicsText">statements</span>
											};
										</code></pre>
				<p>The <span class="italicsText">rest syntax</span> collects all of the arguments into a single array that can then be used in the function's body.</p>
				<pre class="language-javascript"><code>
												// We can see the rest syntax's resulting array with the console:
												function showRest(...elements) {
													return console.log(elements)
												};
												showRest(2, 4, 9, 11);
												/*
												Output:
												[ 2, 4, 9, 11 ]
												*/								
											</code></pre>
				<p>With the <span class="italicsText">rest syntax</span>, we can write our sum function more concisely without using the <span class="monoText">arguments</span> object:</p>
				<pre class="language-javascript"><code>
													function sum(...nums) {
														return nums.reduce((total, currentValue) => {
															return total + currentValue
														})
													};
													console.log(sum(4, 3, 5, 11, 17, 92)); // Output: 132
											</code></pre>
				<p>A more complex example:</p>
				<pre class="language-javascript"><code>	
												// Here is a function that returns a factorial in an array for any number we pass through to it:
												function factorialResults(...nums) {
													return nums.map(function (num) {
														let result = num;
														if (num === 0 || num === 1) {
															return 1; // the factorials of 0 or 1 are special cases
														}
														while (num > 1) { // for everything else, do this
															num--;
															result *= num;
														}
														return result;
													});
												}
												console.log(factorialResults(3, 2, 5, 9)); // Output: [ 6, 2, 120, 362880 ]
												console.log(factorialResults(3)); // Output: [ 6 ]												
											</code></pre>
				<p>We can also use the <span class="italicsText">rest syntax</span> to collect all of the remaining arguments passed through to a function that have not been matched to a parameter:</p>
				<pre class="language-javascript"><code>
													// So for example, say we have a function that takes two arguments:
													function nameGenerator(firstName, lastName, ...remains) {
														return console.log(
															`In Japanese, your name would be ordered: ${lastName}, ${firstName} san. "${remains}" ignored.`
														)
													};
													// When we run the function:
													nameGenerator('Sherlock', 'Holmes', 'III', 'Jr.');
													/*
													Output: 
													In Japanese, your name would be ordered: Holmes, Sherlock san. "III,Jr." ignored.
													*/								
												</code></pre>
			</section>

			<section id="objectMethods_introduction" class="grid-item">
				<h2>Object Methods and Properties</h2>
				<p class="subheading-1">Preface</p>
				<p>
					This section covers shorthand properties and methods for objects. In previous sections, we restricted the discussion to
					<span class="italicsText"><a href="#javascript_data_structures_objects">object literals</a></span
					>. Object literals, however, are just one kind of object. There are many other aspects to objects that must be considered.
				</p>
			</section>

			<section id="object_shorthand_properties" class="grid-item">
				<h3>Shorthand Properties of Objects</h3>

				<p>
					Suppose we have variables declared and initialized with values. In many situations, we might want to create an object where the key name is the name of the variable, and the key's assigned property is the value assigned to the variable.<span class="italicsText">Shorthand properties</span>
					provide a concise way of creating such an object. For example, if we wanted to collect all of the results from a function in an object, the usual way would be:
				</p>
				<pre class="language-javascript"><code>
						// Suppose we have an array of voltage values from running an experiment:
						const experiment1 = [0.53, 0.58, 0.59, 0.53, 0.61, 0.51, 0.53];
						// Now suppose that we create a function that computes a variety of statistics from these values:
						const experimentStats = (arr) => {
							const voltageQuantity = arr.length;
							const maxVoltage = Math.max(...arr);
							const minVoltage = Math.min(...arr);
							const sumVoltages = arr.reduce((sumVoltages, r) => sumVoltages + r);
							const averageVoltage = sumVoltages / voltageQuantity;
							const sortVoltageAscending = arr.sort((a, b) => a - b);

							return {
								maximum_voltage: maxVoltage,
								minimum_voltage: minVoltage,
								average_voltage: averageVoltage,
								voltages_ascending: sortVoltageAscending,
							};
						};
						console.log(experimentStats(experiment1));
						/*
						Output:
						{
							maximum_voltage: 0.61,
							minimum_voltage: 0.51,
							average_voltage: 0.5542857142857143,
							voltages_ascending: [ 0.51, 0.53, 0.53, 0.53, 0.58, 0.59, 0.61 ]
						}
						*/	
						</code></pre>
				<p>
					But, with
					<span class="italicsText">shorthand properties</span>, we can shorten the return statement in the example above:
				</p>
				<pre class="language-javascript"><code>
							// Suppose we have an array of voltage values from running an experiment:
							const experiment1 = [0.53, 0.58, 0.59, 0.53, 0.61, 0.51, 0.53];
							// Now suppose that we create a function that computes a variety of statistics from these values:
							const experimentStats = (arr) => {
								const voltageQuantity = arr.length;
								const maxVoltage = Math.max(...arr);
								const minVoltage = Math.min(...arr);
								const sumVoltages = arr.reduce((sumVoltages, r) => sumVoltages + r);
								const averageVoltage = sumVoltages / voltageQuantity;
								const sortVoltageAscending = arr.sort((a, b) => a - b);

								return {
									voltageQuantity,
									maxVoltage,
									minVoltage,
									sumVoltages,
									averageVoltage,
									sortVoltageAscending
								};
							};
							
							console.log(experimentStats(experiment1));
							/*
							Output:
							{
								voltageQuantity: 7,
								maxVoltage: 0.61,
								minVoltage: 0.51,
								sumVoltages: 3.88,
								averageVoltage: 0.5542857142857143,
								sortVoltageAscending: [ 0.51, 0.53, 0.53, 0.53, 0.58, 0.59, 0.61 ]
							}
							*/							
						</code></pre>
				<p>The catch, of course, is that we cannot use unique variable names (of course, we can get around that by assigning those names as keys in the first place).</p>
			</section>

			<section id="computed_properties" class="grid-item">
				<h3>Computed Properties</h3>
				<p><span class="italicsText">Computed properties</span> allow us to write properties of an object literal with a <span class="italicsText">dynamic key</span>. Recall that when use a variable name as a property name in an object, JavaScript does not check whether the name is actually a variable&mdash;it simply treats it as a string:</p>
				<pre class="language-javascript"><code>
							const negativeCharge = -1;
							const negParticle = 'electron';
							// If we tried to use the variable name as a property:
							const particleDetails = {
								negParticle: negativeCharge
							};
							console.log(particleDetails); // Output: { negParticle: -1 }
							// JavaScript is not checking if 'negParticle' is a variable; it's a string.			
						</code></pre>
				<p>
					To use a variable name as a property name while making sure that JavaScript evaluates it, we need to use the
					<span class="monoText">object[key]</span> syntax <span class="italicsText">after</span> we initialize the object:
				</p>
				<pre class="language-javascript"><code>
							const negativeCharge = -1;
							const negParticle = 'electron';
							const particleDetails = {};
							particleDetails[negParticle] = negativeCharge;

							// Test: 
							console.log(particleDetails);
							// Output: { electron: -1 }
						</code></pre>
				<p>
					But, the
					<span class="italicsText">computed properties syntax</span>
					provides a more a concise way of accomplishing the same task:
				</p>
				<pre class="language-javascript"><code>
							const negativeCharge = -1;
							const negParticle = 'electron';
							const particleDetails = { [negParticle]: negativeCharge };
							// Test:
							console.log(particleDetails); // Output: { electron: -1 }
						</code></pre>
				<p>
					Notice the syntax we used,
					<span class="monoText">[]</span>:
				</p>
				<pre class="language-javascript"><code>
							const variableA = 'value1';
							const variableB = 'value2';
							const objectC = { [variableA]: variableB }
							// We used the value of variableA as the key name for the value of variableB
						</code></pre>
				<p>
					We can use the
					<span class="italicsText">computed properties syntax</span> to more concisely write a function that adds a property. Without using the <span class="italicsText">computed properties syntax</span>, the function looks like:
				</p>
				<pre class="language-javascript"><code>
							// This function accepts an object, and returns a copy of that object with a new property inserted:
							function propAdder(obj, ky, val) {
								const objCopy = { ...obj };
								objCopy[ky] = val;
								return objCopy
							};
							// Let's test it on an object:
							const objSample = { str: 'val', num: 2 };
							let objSampleNew = propAdder(objSample, 'bool', true);

							console.log(objSampleNew); // Output: { str: 'val', num: 2, bool: true }
						</code></pre>
				<p>Above, we used the <span class="monoText">object[key]</span> syntax to add the new property. We can write the same statements with less characters with the <span class="italicsText">computed properties syntax</span>:</p>
				<pre class="language-javascript"><code>
							const propAdder = (obj, ky, val) => { return { ...obj, [ky]: val }; };
							// test:
							const objSample = { str: "val", num: 2 };
							let objSampleNew = propAdder(objSample, "bool", true);

							console.log(objSampleNew); // Output: { str: 'val', num: 2, bool: true }
						</code></pre>
				<p>Or, even shorter with an implicit return:</p>
				<pre class="language-javascript"><code>
						const propAdder = (obj, ky, val) => ({ ...obj, [ky]: val });
						// test:
						const objSample = { str: "val", num: 2 };
						let objSampleNew = propAdder(objSample, "bool", true);

						console.log(objSampleNew); // Output: { str: 'val', num: 2, bool: true }	
						</code></pre>
			</section>

			<section id="methods_and_objects" class="grid-item">
				<h3>Adding Methods to Objects</h3>
				<p>
					We can add functions as properties on objects. Once we add a function to an object, it becomes a
					<span class="term">method</span>. The simplest reason for why we would want to put functions into objects is that doing so is conducive to better organized programs, which in turn leads to more efficient and elegant code. Recall that a function, at it is core, is just data, so it can be assigned to variables. Likewise, it can be assigned to a key:
				</p>
				<pre class="language-javascript"><code>
							// Here's a function that computes the circumference of a circle:
							const circumference = (r) => 2 * r * Math.PI;
							// We can place this in an object:
							const mathFuncs = {
								circumference: circumference
							};
							// Once placed inside an object, we can call it with the method syntax:
							console.log(mathFuncs.circumference(3)); // Output: 18.84955592153876
						</code></pre>
				<p>In the example above, the function is written outside the object, then later placed in the object. This is not how methods are typically written. Instead, we usually write the functions directly inside the object:</p>
				<pre class="language-javascript"><code>
							// We can place this in an object:
							const mathFuncs = {
								circumference: circumference = (r) => (2 * r * Math.PI),
								circleArea: circleArea = (r) => (Math.PI * r * r)
							};
							// Once placed inside an object, we can call it with the method syntax:
							console.log(mathFuncs.circumference(4)); // Output: 25.132741228718345
							console.log(mathFuncs.circleArea(4)); // Output: 50.26548245743669
						</code></pre>
				<p>
					Note that in the examples, we used the
					<span class="italicsText">arrow function</span> syntax. This is not a common way of writing functions inside objects.
				</p>
			</section>

			<section id="shorthand_methods" class="grid-item">
				<h3>Shorthand Methods Syntax</h3>
				<p>
					Instead of using the key value pairs syntax, we can use the
					<span class="italicsText">shorthand method syntax</span>:
				</p>
				<pre class="language-javascript"><code>
							// We can place this in an object:
							const mathFuncs = {
								circumference(r) {
									return 2 * r * Math.PI;
								},
								circleArea(r) {
									return Math.PI * r * r;
								}
							};
							// Once placed inside an object, we can call it with the method syntax:
							console.log(mathFuncs.circumference(4)); // Output: 25.132741228718345
							console.log(mathFuncs.circleArea(4)); // Output: 50.26548245743669
						</code></pre>
			</section>

			<section id="keyword_this" class="grid-item">
				<h3>The Keyword <span class="monoText">this</span></h3>
				<p>A variable declared with <span class="monoText">var</span> in the global scope will be included in the <span class="monoText">window</span> object as a property. But, variables declared with <span class="monoText">let</span> and <span class="monoText">const</span> will not be included. The <span class="monoText">this</span> keyword is a keyword that references the current execution's <span class="italicsText">scope</span>, and gives an <span class="italicsText">object</span> back as its output. Thus, the returned object changes depending on the current execution's scope. The execution might have a global scope, or it might have some other scope&mdash;expression scope, block scope, function scope, etc. For example, consider the code below:</p>
				<pre class="language-javascript"><code>
						function helloWorld() {
							console.log("Hi")
							console.log(this);
						};
						helloWorld();	
						/*
						Output:
						Window {window: Window, self: Window, document: document, name: "", location: Location, …}
						*/
						</code></pre>
				<p>
					In the code above, our function contains the statement,
					<span class="monoText">console.log(this);</span>. This statement says, "JavaScript, display in the console this function's scope." In doing so, we get back an object called the <span class="monoText">Window</span>. The window is the global scope in the browser. When we wrote the function <span class="monoText">helloworld</span>, we wrote directly into the program, not under any other block. When we write functions like this, the functions are written in the <span class="italicsText">global scope</span>. When a function is written in the <span class="italicsText">global scope</span>, it becomes a property in the <span class="italicsText">global scope object</span> (in this case, the browser's global scope), and as such, we can call it with the usual object syntax: <span class="monoText">window.functionName()</span>. The same goes for variables declared with <span class="monoText">var</span> directly into the program (not inside any other block scope).
				</p>
				<pre class="language-javascript"><code>
							var vector = 3;
						</code></pre>
				<p>By declaring the variable <span class="monoText">vector</span> with the keyword <span class="monoText">var</span> above, the name <span class="monoText">vector</span> now becomes a property of the <span class="monoText">Window</span> object, which we can call with <span class="monoText">window.vector</span>. <span class="term">BUT</span> this rule does not apply to variables declared with the keywords <span class="monoText">let</span> and <span class="monoText">const</span>.</p>
			</section>

			<section id="using_this_" class="grid-item">
				<h3>Why <span class="monoText">this</span> Is So Useful</h3>

				<p>
					Consider the code below, where we write a function using the
					<span class="monoText">this</span> keyword inside an object:
				</p>
				<pre class="language-javascript"><code>
							// An object containing the properties of tree ferns
							const treeFern = {
								scientificName: 'Dicksonia antarctica',
								genus: 'Dicksonia',
								family: 'Dicksoniaceae',
								Order: 'Cyatheales',
								Class: 'Polypodiopsida',
								Division: 'Polypodiophyta',
								Kingdom: 'Plantae',
								allDetails() {
									console.log(this);
								}
							};
							treeFern.allDetails();
							/*
							Output:
							{
								scientificName: 'Dicksonia antarctica',
								genus: 'Dicksonia',
								family: 'Dicksoniaceae',
								Order: 'Cyatheales',
								Class: 'Polypodiopsida',
								Division: 'Polypodiophyta',
								Kingdom: 'Plantae',
								allDetails: [Function: allDetails]
							}
							*/
						</code></pre>
				<p>
					In the example above, we wrote the function
					<span class="monoText">allDetails()</span> inside the object <span class="monoText">treeFern</span>. That function contains the statement <span class="monoText">console.log(this);</span>, which tells JavaScript, "Display in the console this function's scope." When we call the function with object syntax, <span class="monoText">treeFern.allDetails()</span>, we get back that the entire scope of that function, the object <span class="monoText">treefern</span>.
				</p>
				<p>
					An astute observer might notice the immediate utility of the
					<span class="monoText">this</span> keyword: It allows us to use the properties inside an object while writing statements inside said object.
				</p>
				<pre class="language-javascript"><code>
							// Here is an object of some mathematical functions:
							const mathematician = {
								firstName: 'Renee',
								lastName: 'Descartes',
								firstNameDisplay() {
									console.log(this.firstName);
								}
							};
							mathematician.firstNameDisplay(); // Output: Renee
						</code></pre>
				<p>A more elaborate example:</p>
				<pre class="language-javascript"><code>
							const RD = {
								firstName: 'Renee',
								lastName: 'Descartes',
								notable: 'Cartesian plane',
								details() {
									console.log(`${this.firstName} ${this.lastName}, notable for the ${this.notable}.`);
								}
							};
							RD.details(); // Output: Renee Descartes, notable for the Cartesian plane.
						</code></pre>
			</section>

			<section id="destructuring_and_this" class="grid-item">
				<h4>
					Using Destructuring Syntax with
					<span class="monoText">this</span>
				</h4>
				<p>
					In the example above, we constantly had to write the
					<span class="monoText">this</span> keyword. We can cut all of that out with the <span class="italicsText">destructuring syntax</span>:
				</p>
				<pre class="language-javascript"><code>
						const rD = {
							firstName: 'Renee',
							lastName: 'Descartes',
							notable: 'Cartesian plane',
							details() {
								const {
									firstName,
									lastName,
									notable
								} = this;
								console.log(`${firstName} ${lastName}, notable for the ${notable}.`);
							}
						};
						rD.details(); // Output: Renee Descartes, notable for the Cartesian plane.	
						</code></pre>
				<p>The <span class="monoText">this</span> keyword allows us to write methods that can "see" the other properties inside the object.</p>
			</section>

			<section id="using_this_to_reference_methods" class="grid-item">
				<h4>Using the <span class="monoText">this</span> Keyword to Reference Methods</h4>
				<p>We can use <span class="monoText">this</span> to reference other methods inside an object:</p>
				<pre class="language-javascript"><code>
							const sR = {
								first: "Srinivasa",
								last: "Ramanujan",
								country: "India",
								fullName() {
									return `${this.first} ${this.last}`
								},
								summary() {
									const fullName = this.fullName();
									return `${fullName} is a mathematician from ${this.country}.`
								}
							};
							console.log(sR.summary()); // Output: Srinivasa Ramanujan is a mathematician from India.								
						</code></pre>
			</section>

			<section id="value_of_this" class="grid-item">
				<h4>The Value of <span class="monoText">this</span></h4>
				<p>The value of the <span class="monoText">this</span> keyword depends on how we invoke the function that uses it. Put simply, the value of the <span class="monoText">this</span> keyword depends on <span class="italicsText">where we write it</span> and <span class="italicsText">how we write it</span>. To see this crucial point, consider the code below:</p>
				<pre class="language-javascript"><code>
							// Same object from the preceding example.
							const sR = {
								first: "Srinivasa",
								last: "Ramanujan",
								country: "India",
								fullName() {
									return `${this.first} ${this.last}`
								},
								summary() {
									const fullName = this.fullName();
									return `${fullName} is mathematician from ${this.country}.`
								}
							};
							// Suppose we assign the method SR.summary() to a variable: 
							const summary = sR.summary;
							// Now suppose we call that function:
							console.log(summary());
							/*
							Output: 
							TypeError: this.fullName is not a function
							*/								
						</code></pre>
				<p>Compare the error above with the following code:</p>
				<pre class="language-javascript"><code>
							// Same object from the preceding example.
							const sR = {
								first: "Srinivasa",
								last: "Ramanujan",
								country: "India",
								fullName() {
									return `${this.first} ${this.last}`
								},
								summary() {
									console.log(this); // Let's see what the object is
									const fullName = this.fullName();
									return `${fullName} is mathematician from ${this.country}.`
								}
							};
							const summary = sR.summary;
							console.log(summary());
							/*
							Output: 
							Window {window: Window, self: Window, document: document, name: "", location: Location, …}
							Uncaught TypeError: this.fullName is not a function at summary
							*/								
						</code></pre>
				<p>
					In the second example, we see that
					<span class="monoText">this</span> is referencing the object <span class="monoText">window</span>, the browser's global scope. If we instead just used the typical object key syntax rather than the variable:
				</p>
				<pre class="language-javascript"><code>
							// Same object from the preceding example.
							const sR = {
								first: "Srinivasa",
								last: "Ramanujan",
								country: "India",
								fullName() {
									return `${this.first} ${this.last}`
								},
								summary() {
									console.log(this); // Let's see what the object is
									const fullName = this.fullName();
									return `${fullName} is mathematician from ${this.country}.`
								}
							};
							console.log(sR.summary());
							/*
							Output: 
							{first: "Srinivasa", last: "Ramanujan", country: "India", fullName: ƒ, summary: ƒ}
							Srinivasa Ramanujan is mathematician from India.
							*/								
						</code></pre>
				<p>Now we see that the value of <span class="monoText">this</span> is the object it's contained in, <span class="monoText">sR</span>, rather than the <span class="monoText">window</span> object, the global scope.This shows that the value of <span class="monoText">this</span> is determined by the way we invoke the function that uses the <span class="monoText">this</span> keyword. One way to think about this: When we explicitly call the function with the object syntax, <span class="monoText">object.function</span>, the value of <span class="monoText">this</span> is the object itself. But, when we simply just call the function without explicitly stating the object, the value of <span class="monoText">this</span> is the global scope object (which, in the browser, is the <span class="monoText">window</span> object).</p>
			</section>

			<section id="arrow_functions_and_this" class="grid-item">
				<h4>Arrow Functions and <span class="monoText">this</span></h4>
				<p>
					One of the key differences between regular function expressions and arrow functions is how they behave with the keyword
					<span class="monoText">this</span>. When a method is written as an arrow function, if its body uses the keyword <span class="monoText">this</span>, the value of
					<span class="monoText">this</span>
					<span class="underlineText">does not change</span>.
				</p>
				<pre class="language-javascript"><code>
							// The full name function as an arrow function:
							const sR = {
								first: "Srinivasa",
								last: "Ramanujan",
								country: "India",
								fullName: () => {
									console.log(this);
									console.log(`${this.first} ${this.last}`);
								}
							};
							sR.fullName();
							/*
							Output:
							Window {window: Window, self: Window, document: document, name: "", location: Location, …}
							undefined undefined
							*/								
						</code></pre>
				<p>
					Notice that when we display the value of
					<span class="monoText">this</span> for the function <span class="monoText">fullName()</span>, we get the back the <span class="monoText">window</span> object. The value of <span class="monoText">this</span> in an arrow function is always the value of <span class="monoText">this</span> of its parent object (in this case, the global scope). This is why methods are generally not written as arrow functions inside an object written inside a global scope (since we usually write methods to access other properties in such an object). But, they are extremely useful when a method itself contains a function. To see this utility, consider the code below:
				</p>
				<pre class="language-javascript"><code>
							/*
							Here is method that repeatedly and randomly prints out prime numbers forever.
							We want to start the method with the function start().
							To do this, we need to use the built in method, set.interval(), which takes two parameters, a function, and time value (3000, which equals three seconds)
							*/
							const randPrime = {
								primes: [1, 3, 5, 7, 11, 13, 17],

								pickPrime() {
									const { primes } = this; // Set the value of this to be the primes property
									const idx = Math.floor(Math.random() * primes.length); // Generate a random index
									return primes[idx]; // Output the random index
								},

								// Now we want to call pickPrime with the set interval method:
								start() {
									console.log(this.pickPrime());
									setInterval(function() { console.log(this.pickPrime()) }, 2000)
								}
							};
							// Let's test briefly:
							randPrime.start();
							/*
							Output:
							13
							Uncaught TypeError: this.pickPrime is not a function
							*/
						</code></pre>
				<p>
					Why did we get the error above? Let's see what the vlaue of
					<span class="monoText">this</span> is in the function function <span class="monoText">start()</span>:
				</p>
				<pre class="language-javascript"><code>
							const randPrime = {
								primes: [1, 3, 5, 7, 11, 13, 17],

								pickPrime() {
									const { primes } = this;
									const idx = Math.floor(Math.random() * primes.length);
									return primes[idx];
								},

								start() {
									console.log(this.pickPrime());
									setInterval(function () {
										console.log(this);
										console.log(this.pickPrime())
									}, 2000)
								}
							};
							randPrime.start();
							/*
							Output:
							13
							Window {0: global, window: Window, self: Window, document: document, name: "", location: Location, …}
							*/								
						</code></pre>
				<p>Why is the value of <span class="monoText">this</span> set to the <span class="monoText">window</span> object? Because in the <span class="monoText">start()</span> method's body, we are using the <span class="monoText">setInterval()</span> method, which has a global scope. Thus, the value of <span class="monoText">this</span>, inside the <span class="monoText">setInterval()</span> method, is the global scope's object, <span class="monoText">window</span>. One way to get around this problem is by storing the value of <span class="monoText">this</span> in a variable before we get to using the built-in method:</p>
				<pre class="language-javascript"><code>
							const randPrime = {
								primes: [1, 3, 5, 7, 11, 13, 17],

								pickPrime() {
									const { primes } = this;
									const idx = Math.floor(Math.random() * primes.length);
									return primes[idx];
								},

								start() {
									console.log(this.pickPrime());

									const that = this;

									setInterval(function () {
										console.log(that);
										console.log(that.pickPrime())
									}, 2000)
								}
							};
							randPrime.start();
							/*
							Output:
							7
							{primes: Array(7), pickPrime: ƒ, start: ƒ}
							13
							9
							1
							5
							*/								
						</code></pre>
				<p>By storing <span class="monoText">this</span> in the variable <span class="monoText">that</span>, we can now use the previous value of <span class="monoText">this</span> in the built-in method <span class="monoText">setInterval()</span>. This was the old way of getting around the problem of using <span class="monoText">this</span> with built-in methods, and when viewing old JavaScript code, we will often see the variable name <span class="monoText">that</span>. Arrow functions, however, have taken the mantle and provide a much cleaner way of solving the problem:</p>
				<pre class="language-javascript"><code>
							const randPrime = {
								primes: [1, 3, 5, 7, 11, 13, 17],

								pickPrime() {
									const { primes } = this;
									const idx = Math.floor(Math.random() * primes.length);
									return primes[idx];
								},

								start() {
									setInterval(() => {
										console.log(this.pickPrime())
									}, 2000)
								}
							};
							randPrime.start();
							/*
							Output:
							7
							11
							1
							9
							*/								
						</code></pre>
				<p>
					The above works because with arrow functions, the value of
					<span class="monoText">this</span> is always the value <span class="monoText">this</span> for the function's parent object.
				</p>
			</section>

			<section id="why_use_methods" class="grid-item">
				<h3>Why Should We Use Methods?</h3>
				<p>The best way to see why methods are extremely useful is by example:</p>
				<pre class="language-javascript"><code>
							/*
							I want a function that draws a card out of the deck (and makes sure that the deck is 1 card fewer for each draw)
							*/
							// first, let's make the deck
							function makeDeck() {
								const deck = []; // Make an empty deck
								const suits = ['hearts', 'diamonds', 'spades', 'clubs']; // The array of suits
								const values = '2,3,4,5,6,7,8,9,10,J,Q,K,A'; // A string of values
								// Turn the string of values into an array
								for (let value of values.split(',')) {
									// For each array element, do this:
									for (let suit of suits) {
										// For each suit, do this: 
										deck.push({value, suit})
									}
								}
								return deck;
							};

							// Suppose I want to draw a card from the deck
							// We need to write a function that draws the card:
							function drawCard(deck) {
								return deck.pop() // Take a card out of the deck
							};
							// Set the deck to a variable:
							const deck = makeDeck();
							console.log(drawCard(deck)); // Output: { value: 'A', suit: 'clubs' }

							// To draw another card, we need to pass the argument again:
							console.log(drawCard(deck)); // Output: { value: 'A', suit: 'spades }
							// The problem with writing the program this way is that we have to keep passing an argument over and over again.
							// And what if we need to shuffle the deck? (The pop method is just taking a card from the deck in order)							
						</code></pre>
				<p>The above example shows a common phenomenon in programming: repetitious code. Where there is repetitious code, there are methods laying in ambush. The above code written inside an object:</p>
				<pre class="language-javascript"><code>
							const deck = {
								deck: [],
								suits: ["hearts", "diamonds", "spades", "clubs"],
								values: "2,3,4,5,6,7,8,9,10,J,Q,K,A",

								makeDeck() {
									const { suits, values, deck} = this;
									for (let value of values.split(",")) {
										for (let suit of suits) {
											deck.push({ value, suit });
										}
									}
								},
								
								drawCard() {
									return this.deck.pop()
								}
							};
							deck.makeDeck(); // Make the deck
							// Then draw a card:
							console.log(deck.drawCard()); // Output: { value: 'A', suit: 'clubs' }							
						</code></pre>
				<p>By storing the functions in an object, we've created methods, which can be called upon over and over without having to pass repeatedly pass arguments. By using methods, we can do even more things:</p>
				<pre class="language-javascript"><code>
							const theDeck = { // create the object
								deck: [], // Variable stores deck
								drawnCards: [], // Variable stores drawn cards
								suits: ["hearts", "diamonds", "spades", "clubs"], // the suits
								values: "2,3,4,5,6,7,8,9,10,J,Q,K,A", // the ranks
								// Method: make deck
								makeDeck() {
									const { suits, values, deck} = this; // stop writing 'this' repeatedly
									// loop through 'values' string turned into array
									for (let value of values.split(",")) {
										// for each element in 'values', loop through 'suits'
										for (let suit of suits) {
											// for each suit, push this object into 'deck'
											deck.push({ value, suit });
										}
									}
								},
								// Method: draw card
								drawCard() {
									const card = this.deck.pop(); // Store drawn card in variable
									this.drawnCards.push(card); // Store drawn card in the drawnCards array
									return card; // Output card
								},
								// Method: draw multiple cards
								drawCards(numCards) {
									const cards = []; // Store drawn cards in variable
									// run drawCard this many times
									for (let i = 0; i < numCards; i++) {
										cards.push(this.drawCard()); // Put drawn cards in cards variable
									}
									return cards; // Output cards
								},
								// Method: shuffle cards
								shuffle() {
									const { deck } = this;
									// Loop through the array backwards
									for (let i = deck.length - 1; i > 0; i--) {
										// Pick a random index before the current element
										let j = Math.floor(Math.random() * [i + 1]);
										// Swap elements with destructuring
										[deck[i], deck[j] = deck[j], deck[i]];
									}
								}
							};

							// Let's test.
							theDeck.makeDeck(); // Make the deck. 
							console.log(theDeck.drawCard()); // Draw card:
							// Output: { value: 'A', suit: 'clubs' } 
							console.log(theDeck.drawnCards); // Check drawn cards array:
							// Output: [ { value: 'A', suit: 'clubs' } ]
							console.log(theDeck.drawCards(3)); // Draw multiple cards
							/*
							Output: 
							[
							{ value: 'A', suit: 'spades' },
							{ value: 'A', suit: 'diamonds' },
							{ value: 'A', suit: 'hearts' }
							]
							*/
							theDeck.shuffle(); // Shuffle the deck
							console.log(theDeck.drawCard()); // Draw card
							// Output: { value: 'K', suit: 'clubs' }							
						</code></pre>
			</section>

			<section id="scope_introduction" class="grid-item">
				<h2>Scope</h2>
				<p>In computer science, <span class="term">scope</span> is the set of all <span class="term">name bindings</span> <span class="italicsText">visible</span> to the programming language in a given <span class="term">context</span> or <span class="term">environment</span>. The term <span class="term">scope</span> refers to the area of a programming where JavaScript can "see" a particular entity (e.g., a variable). If JavaScript cannot see that entity, then it cannot use it when it executes code.</p>
				<p>Like many other programming languages, JavaScript's "sight" is limited by the way we write code. This is to prevent JavaScript from getting confused&mdash;if JavaScript could see every variable we declared, it would not know what to do (computers are not nearly as smart as we think): "I see you declared this variable here, but I can see the same variable over there, so I'm confused. Here's an error."</p>
			</section>

			<section id="function_scope" class="grid-item">
				<h3>Function Scope</h3>
				<p>When a variable is declared in a function's body (i.e., the function's code block), JavaScript can only see that variable if JavaScript itself is inside that code block. Outside of that code block, JavaScript cannot see that variable.</p>
				<p>This allows us to have multiple functions with the same variable names:</p>

				<pre class="language-javascript">
							<code>
								function() {
									let x = null;
									// JavaScript cannot see the variable x outside this code block
								}
								function() {
									let x = 1;
								}
							</code>
						</pre>

				<h3>Block Scope</h3>
				<p>Like <span class="italicsText">function scope</span>, if we declare a variable inside a <span class="italicsText">conditional statement</span>'s code block, JavaScript can only see the variable within that code block–it cannot access the variable outside the statement's code block.</p>

				<pre class="language-javascript">
							<code>
								if (<span class="greyText italicsText">condition</span>) {
									let x = null;
								}
								// JavaScript cannot see the variable x outside the curly braces, so it can be declared again outside of the curly braces.
							</code>
						</pre>

				<section id="warning_var_scope">
					<p class="warning-heading">&#9888; Warning: <span class="monoText">var</span> Is the Exception</p>

					<p>
						The above rules
						<span class="underlineText">do not apply</span> to variables declared with <span class="monoText">var</span>.
					</p>

					<pre class="language-javascript">
								<code>
									if (<span class="greyText italicsText">condition</span>) {
										var x = null;
									}
									// JavaScript <span class="underlineText">can</span> see the variable x outside the curly braces.
								</code>
							</pre>
				</section>

				<h3>Lexical Scope</h3>
				<p>
					When we have
					<span class="italicsText">nested functions</span> (a function inside a function), a variable declared in the
					<span class="italicsText">outer function</span>
					<span class="underlineText">can</span> be accessed in the inner function.
				</p>

				<pre class="language-javascript">
							<code>
								function outer() {
									let x = null;
									function inner() {
										<span class="greyText italicsText">statements</span>;
										// JavaScript can see x here
										let y = null;
									}
									// JavaScript can see x here
									// JavaScript <span class="underlineText">cannot</span> see y here (function scope)
								}
								// JavaScript cannot see x here, unless we invoke the function outer()
							</code>
						</pre>
			</section>

			<section id="methods_for_selecting_other_attributes" class="grid-item">
				<h3>Methods for Selecting Other Attributes</h3>
				<p>
					While the above properties can be used to target the attributes
					<span class="monoText">value</span>, <span class="monoText">checked</span>, and <span class="monoText">href</span>, there are other attributes that require using <span class="italicsText">methods</span>. These two methods are <span class="monoText">getAttribute()</span> and <span class="monoText">setAttribute()</span>.
				</p>
			</section>

			<section id="getAttribute_method" class="grid-item">
				<h4>The <span class="monoText">.getAttribute()</span> Method</h4>
				<p>The <span class="monoText">.getAttribute()</span> method allows us to target other attributes like <span class="monoText">min</span> and <span class="monoText">max.</span> Consider the following HTML code:</p>

				<pre class="language-html"><code>
							&#x3C;body&#x3E;
								&#x3C;h1&#x3E;Hello, world&#x3C;/h1&#x3E;
								&#x3C;form action=&#x22;&#x22;&#x3E;
									&#x3C;input type=&#x22;text&#x22; placeholder=&#x22;username&#x22;&#x3E;
									&#x3C;input type=&#x22;password&#x22; placeholder=&#x22;password&#x22;&#x3E;
									&#x3C;input type=&#x22;checkbox&#x22;&#x3E;
									&#x3C;input type=&#x22;range&#x22; min=&#x22;0&#x22; max=&#x22;100&#x22; step=&#x22;10&#x22;&#x3E;
									&#x3C;input type=&#x22;submit&#x22;&#x3E;
								&#x3C;/form&#x3E;
							&#x3C;/body&#x3E;
						</code></pre>

				<p>
					Notice that the range element has the attributes
					<span class="monoText">min</span> and <span class="monoText">max</span> (which are set to 0 and 100 respectively). These attributes set the minimum numeric value for the sliding scale, and the maximum numeric value. To target these values in JavaScript, we need to use the <span class="monoText">.getAttribute()</span> method:
				</p>

				<pre class="language-javascript"><code>
							const rangeElement = document.querySelector('input[type="range"]');
							const rangeMax = range.getAttribute('max');
							const rangeMin = range.getAttribute('min');

							console.log(rangeMax);
							// Output:
							100

							console.log(rangeMin);
							// Output:
							0
						</code></pre>
			</section>

			<section id="setAttribute_method" class="grid-item">
				<h4>The <span class="monoText">.setAttribute()</span> Method</h4>
				<p>
					To set the values for those attributes, we must use the
					<span class="monoText">.setAttribute()</span> method. The <span class="monoText">.setAttribute()</span> method takes to arguments:
				</p>
				<figure>
					<code class="language-javascript">.setAttribute('<span class="code-annotation">attribute-name</span>', '<span class="code-annotation">number-value</span>')</code>
				</figure>
				<p>
					So, suppose we wanted to change the
					<span class="monoText">max</span> attribute's value.
				</p>

				<pre class="language-javascript"><code>
							rangeElement.setAttribute('max', '200');
						</code></pre>

				<h5>Completely Changing an Input Element's Type</h5>
				<p>
					We can also change an input element's type (e.g., a checkbox to a radio button) with the
					<span class="monoText">.setAttribute()</span> method. So, let's say we want to change the checkbox to a radio button:
				</p>

				<pre class="language-javascript"><code>
							const radioEmnt = document.querySelector('input[type="checkbox"]');
							radioEmnt.setAttribute('type', 'radio');
						</code></pre>

				<p>The checkbox should now be displayed as a radio button.</p>
			</section>

			<section id="accessing_nested_elements" class="grid-item">
				<h3>Accessing Nested Elements</h3>
				<p>
					When manipulating HTML elements with JavaScript, we often need a way to access the parent, sibling, or neighbor elements of a certain HTML element. JavaScript allows us to easily do this with the properties
					<span class="monoText">.parentElement</span>, <span class="monoText">.children</span>, <span class="monoText">.nextElementSibling</span>, and <span class="monoText">.previousElementSibling</span>. We cover these methods with the following HTML code:
				</p>

				<pre class="language-html"><code>
							&#x3C;section&#x3E;
								&#x3C;ul&#x3E;
									&#x3C;li&#x3E;Point 1&#x3C;/li&#x3E;
									&#x3C;li&#x3E;Point 2&#x3C;/li&#x3E;
									&#x3C;li&#x3E;Point 3&#x3C;/li&#x3E;
									&#x3C;ul&#x3E;
										&#x3C;li&#x3E;Subpoint a&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Subpoint B&#x3C;/li&#x3E;
										&#x3C;li&#x3E;subpoint C&#x3C;/li&#x3E;
									&#x3C;/ul&#x3E;
								&#x3C;/ul&#x3E;
							&#x3C;/section&#x3E;
						</code></pre>

				<p>
					By selecting the first li element in the code above, and passing the resulting HTML collection into the
					<span class="monoText">console.dir()</span> method, we can see several properties:
				</p>

				<pre class="language-javascript"><code>
							const first_li_emt = document.querySelector('li');
							console.dir(first_li_emt);
						</code></pre>

				<pre class="language-bash"><code>
							firstChild: text
							firstElementChild: null
							lastElementChild: null
							lastChild: text
							parentElement: ul
							children: HTMLCollection(0)
							nextSibling: text
							previousSibling: text	
						</code></pre>
			</section>

			<section id="parentElement_property" class="grid-item">
				<h4>The <span class="monoText">.parentElement</span> Property</h4>
				<p>The <span class="monoText">.parentElement</span> property contains the parent element of the selected HTML element. If want to access the parent element of the first li element&mdash;a ul element&mdash;we can write the following in JavaScript:</p>

				<pre class="language-javascript"><code>
							const first_ul_emt = first_li_emt.parentElement;
							// passing first_ul_emt to the console.dir() method, we see all of the relevant properties in the parent ul element's HTML collection

							// We can also access the parent ul element's parent element by simply appending .parentElement again in the assignment:
							const parent_first_ul_emt = first_ul_emt.parentElement;
							console.dir(parent_first_ul_emt);
							// We get the section element as an output, which is, in fact, the parent ul element's parent, the section element.
						</code></pre>

				<p>
					In effect, the
					<span class="monoText">.parentElement</span> property allows us to <span class="underlineText">move up</span> the DOM tree.
				</p>
			</section>

			<section id="childrenElement_property" class="grid-item">
				<h4>
					The
					<span class="monoText">.childrenElement</span> Property
				</h4>
				<p>
					In contrast to
					<span class="monoText">.parentElement</span>, the <span class="monoText">.childrenElement</span> property allows us to <span class="underlineText">move down</span> the tree. Suppose we selected the first ul element right from the start. We can select the second li element inside that ul element with the following:
				</p>

				<pre class="language-javascript"><code>
							const ul_emt = document.querySelector('ul');
							const ul_emt_children = ul_emt.children;
							// ul_emt_children stores an HTML collection of all of the ul element's children
							
							// Select the second li element:
							const ul_emt_2nd_li = ul_emt_children[1];
						</code></pre>
			</section>

			<section id="sibling_properties" class="grid-item">
				<h4>
					The <span class="monoText">.nextElementSibling</span> and
					<span class="monoText">.previousElementSibling</span>
					Properties
				</h4>
				<p>
					The <span class="monoText">.parentElement</span> and <span class="monoText">.childrenElement</span> properties, together, allow us to traverse the DOM tree <span class="italicsText">vertically</span>. The <span class="monoText">.nextElementSibling</span> and
					<span class="monoText">.previousElementSibling</span>
					properties allow us to traverse the DOM tree horizontally. So, suppose we selected the second li element in the nested ul element, and we wanted to select the first li element in that nested ul element. We can do so with the following:
				</p>

				<pre class="language-javascript"><code>
							// select the second li element:
							const nested_ul_2nd_li = document.querySelector('ul>ul li:nth-child(2)');

							// select the first li element:
							const nested_ul_1st_li = nested_ul_2nd_li.previousElementSibling;

							// select the third li element:
							const nested_ul_3rd_li = nested_ul_2nd_li.nextElementSibling;
						</code></pre>
			</section>

			<section id="making_wide_changes" class="grid-item">
				<h3>Making Multiple Changes to HTML</h3>
				<p>At first glance, it may seem that the DOM is restrictive on how we can select and make changes. Do we really need to select every element when we want to use and change them with JavaScript? Not necessarily. Remember, HTML collections and NodeLists are iterable. This means that we can loop through these structures. For example, suppose we had a simple table, listing prices per pound for some products:</p>
				<figure>
					<img src="images/simple_table.png" alt="a simple html table" loading="lazy"/>
				</figure>
				<p>The HTML code for the above table looks as such:</p>

				<pre class="language-html"><code>
							&#x3C;table id=&#x22;meat_prices&#x22;&#x3E;
								&#x3C;thead&#x3E;
									&#x3C;th&#x3E;Product&#x3C;/th&#x3E;
									&#x3C;th&#x3E;Price ($ / lb)&#x3C;/th&#x3E;
								&#x3C;/thead&#x3E;
								&#x3C;tbody&#x3E;
									&#x3C;tr&#x3E;
										&#x3C;td&#x3E;Beef&#x3C;/td&#x3E;
										&#x3C;td&#x3E;3.65&#x3C;/td&#x3E;
									&#x3C;/tr&#x3E;
									&#x3C;tr&#x3E;
										&#x3C;td&#x3E;Chicken&#x3C;/td&#x3E;
										&#x3C;td&#x3E;1.45&#x3C;/td&#x3E;
									&#x3C;/tr&#x3E;
									&#x3C;tr&#x3E;
										&#x3C;td&#x3E;Salmon&#x3C;/td&#x3E;
										&#x3C;td&#x3E;4.22&#x3C;/td&#x3E;
									&#x3C;/tr&#x3E;
								&#x3C;/tbody&#x3E;
							&#x3C;/table&#x3E;
						</code></pre>

				<p>
					Suppose there's been sudden demand for the products above, so we add \$0.65 to the prices. Do we have to select each of the td elements and add \$0.65? We could, but that would be tedious. Since we're applying the same change to each of the first td elements, we can simply loop through them. Since these are floating point numbers, a useful method here (covered in more depth in later) is the
					<span class="monoText">parseFloat()</span> method.
				</p>

				<pre class="language-javascript"><code>
							const prices = document.querySelectorAll('tr td:nth-child(2)');
							for (let i = 0; i < prices.length; i++) {
								prices[i].innerText = parseFloat(prices[i].innerText) + 0.65;
							}
						</code></pre>

				<p>Executing the code above, the table should now look like:</p>
				<figure>
					<img src="images/changed_simple_table.png" alt="simple html table changed" loading="lazy"/>
				</figure>
				<p>This shows us the following key point:</p>
				<ul>
					<li>To select and make wide spread changes:</li>
					<ol>
						<li>Select the relevant element.</li>
						<li>Loop through the returned HTML collection or NodeList.</li>
					</ol>
				</ul>
			</section>

			<section id="altering_styles" class="grid-item">
				<h3>Changing Styles</h3>
				<p>
					Once we select an element, we can use JavaScript to change that element's
					<span class="italicsText">styles</span>&mdash;color, font-size, font-family, width, height, margins, padding, display value, etc. The most straightforward way to make such changes is with the <span class="monoText">style</span> property. Every element selected with JavaScript has a <span class="monoText">style</span> property.
				</p>
				<p>Suppose we have the following HTML code:</p>

				<pre class="language-html"><code>
							&#x9;&#x3C;body&#x3E;
							&#x9;&#x9;&#x3C;h1&#x3E;Hello, world&#x3C;/h1&#x3E;
							&#x9;&#x9;&#x3C;section&#x3E;
							&#x9;&#x9;&#x9;&#x3C;h2&#x3E;Weekly Bulletin&#x3C;/h2&#x3E;
							&#x9;&#x9;&#x9;&#x3C;div&#x3E;
							&#x9;&#x9;&#x9;&#x9;&#x3C;h3&#x3E;A Message from the Church of Emacs:&#x3C;/h3&#x3E;
							&#x9;&#x9;&#x9;&#x9;&#x3C;p&#x3E;Come to Emacs; we promise to never let you go!&#x3C;/p&#x3E;
							&#x9;&#x9;&#x9;&#x3C;/div&#x3E;
							&#x9;&#x9;&#x3C;/section&#x3E;
							&#x9;&#x3C;script src=&#x22;/lab.js&#x22;&#x3E;&#x3C;/script&#x3E;
							&#x9;&#x3C;/body&#x3E;						
						</code></pre>

				<p>Styling that HTML code, in a separate CSS file, is the following code:</p>

				<pre class="language-css"><code>
							body { font-family: monospace; }
							h1 { color: dodgerblue; }
							h2 { font-style: italic; }
							h3 { color: firebrick; }
						</code></pre>

				<p>The above HTML code renders as the following:</p>
				<figure>
					<img src="images/emacsMessage.png" alt="" loading="lazy"/>
				</figure>
				<p>
					If we target, say, the
					<span class="monoText">h1</span> element, we see the following:
				</p>

				<pre class="language-javascript"><code>
							const h1 = document.querySelector('h1');
							console.dir(h1.style);

							// Output:
							<div class="output">
							CSSStyleDeclaration
							</div>
						</code></pre>

				<p>
					What we get back is a huge object named
					<span class="monoText">CSSStyleDeclaration</span>. There are a numerous properties contained in the object, most of which are empty. Moreover, when we run <span class="monoText">console.log(h1.style.color)</span>, we do not see anything. It's still an empty string. What's going on?
				</p>
				<p>
					This is happening because the
					<span class="monoText">style</span> property only contains the styles we write <span class="italicsText">inline</span>. The styles we written for the HTML above are written in a separate CSS file, so they do not appear in the <span class="monoText">style</span> property. However, we can change the element's style by assigning the relevant string to the property:
				</p>

				<pre class="language-javascript"><code>
							const h1 = document.querySelector('h1');
							h1.style.color = salmon;
						</code></pre>

				<p>
					When we run the above code, the
					<span class="monoText">h1</span> element's text color is now changed to salmon:
				</p>
				<figure>
					<img src="images/emacsMessageChanged.png" alt="Changing the h1 color" loading="lazy"/>
				</figure>
				<p>Thus, we can <span class="italicsText">change</span> an element's style with the <span class="monoText">style</span> property, but we cannot <span class="italicsText">read</span> it with the property.</p>

				<p class="warning-heading">&#9888; Warning: Style Names with Multiple Wards</p>
				<p>
					When using the
					<span class="monoText">style</span> property, it is crucial to remember that identifiers in JavaScript cannot contain the character <span class="monoText">-</span> (a dash). This means that certain CSS properties, like <span class="monoText">background-color</span> and <span class="monoText">font-family</span>, are not listed as properties in the same way. Instead, JavaScript uses <span class="italicsText">camel cases</span>: <span class="monoText">background-color</span> becomes <span class="monoText">backgroundColor</span>, and <span class="monoText">font-family</span> becomes <span class="monoText">fontFamily</span>. Thus, if we wanted to change the <span class="monoText">h2</span> element's <span class="monoText">font-style</span>, we have to write:
				</p>

				<pre class="language-javascript"><code>
							const h2 = document.querySelector('h2');
							h2.style.fontStyle = 'normal';
						</code></pre>

				<h4>Changing the <span class="monoText">style</span> Property for Multiple Elements</h4>
				<p>If we wanted to change the style property for multiple elements, we can simply loop through the elements. We have the following HTML code:</p>

				<pre class="language-html"><code>
							&#x9;&#x9;&#x3C;h1&#x3E;Hello, world&#x3C;/h1&#x3E;
							&#x9;&#x3C;section&#x3E;
									&#x3C;h2&#x3E;Things computers are good at:&#x3C;/h2&#x3E;
									&#x3C;ul&#x3E;
										&#x3C;li&#x3E;Basic math.&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Yes or no decisions.&#x3C;/li&#x3E;
										&#x3C;li&#x3E;&#x22;Memorizing&#x22; lots of things.&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Repeating things very very fast.&#x3C;/li&#x3E;
									&#x3C;/ul&#x3E;
							&#x9;&#x3C;/section&#x3E;
						</code></pre>

				<p>The above code renders as:</p>
				<figure>
					<img src="images/helloWorldLists.png" alt="list of things computers are good at" loading="lazy"/>
				</figure>
				<p>
					Say we wanted to change all of the
					<span class="monoText">li</span> elements' font to small capitals. We can do so by looping:
				</p>

				<pre class="language-javascript"><code>
							const all_li = document.querySelectorAll('li');
							for (let li of all_li) {
								li.style.fontVariant = 'small-caps';
							}
						</code></pre>

				<p>The list should now look horrendous:</p>
				<figure>
					<img src="images/helloWorldListsChanged.png" alt="changing the li style to small-caps" loading="lazy"/>
				</figure>
				<p class="warning-heading">&#9888; Warning: Inline Styles are Extremely Specific</p>
				<p>
					In CSS, inline styles are second to the most specific styles (overridden only by
					<span class="monoText">!important</span>). This means that even if you set an element's styles with a <span class="monoText">class</span> or <span class="monoText">id</span> attribute, assignments to the <span class="monoText">style</span> property in JavaScript will override the <span class="monoText">class</span> and <span class="monoText">id</span> styles.
				</p>
			</section>

			<section class="grid-item">
				<h3>
					Reading a Style Value:
					<span class="monoText">getComputedStyle()</span>
				</h3>
				<p>With the <span class="monoText">style</span> property, we cannot read, or retrieve, an element's current style. To retrieve this data, we must use the <span class="monoText">getComputedStyle()</span> method. The <span class="monoText">getComputedStyle()</span> method takes the following form:</p>
				<figure>
					<code class="language-javascript">getComputedStyle(<span class="code-annotation">selected element</span>)</code>
				</figure>
				<p>To illustrate, we have the following HTML code:</p>

				<pre class="language-html"><code>
							&#x9;&#x3C;body&#x3E;
							&#x9;&#x3C;h1&#x3E;Hello, world&#x3C;/h1&#x3E;
							&#x9;&#x3C;section class=&#x22;content_font&#x22;&#x3E;
									&#x3C;h2&#x3E;Some old programming languages:&#x3C;/h2&#x3E;
									&#x3C;ul&#x3E;
										&#x3C;li&#x3E;Fortran&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Lisp&#x3C;/li&#x3E;
										&#x3C;li&#x3E;COBOL&#x3C;/li&#x3E;
										&#x3C;li&#x3E;BASIC&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Pascal&#x3C;/li&#x3E;
										&#x3C;li&#x3E;C&#x3C;/li&#x3E;
									&#x3C;/ul&#x3E;
							&#x9;&#x3C;/section&#x3E;
							&#x9;&#x3C;script src=&#x22;/lab.js&#x22;&#x3E;&#x3C;/script&#x3E;
							&#x9;&#x3C;/body&#x3E;
						</code></pre>

				<p>Styling the above HTML code, we have the following CSS, in a separate file:</p>

				<pre class="language-css"><code>
							body { 
								font-family: monospace; 
								padding: 3vw;
							}
							h1 { color: cadetblue; }
							h2 { font-style: italic; }
							h3 { color: firebrick; }
							.content_font { 
								font-size: 0.75rem; 
								font-family: Verdana;
								color: beige;
								background-color: slategrey;
								border-radius: 0.8rem;
								padding: 3%;
							}
						</code></pre>

				<p>The HTML above renders as:</p>
				<figure>
					<img src="images/languagesPage.png" alt="HTML page of programming languages" class="htmlPage" loading="lazy"/>
				</figure>
				<p>
					Suppose we want to see the styles for the first
					<span class="monoText">li</span> element. We can use the <span class="monoText">getComputedStyle()</span> method:
				</p>

				<pre class="language-javascript"><code>
							const first_li = document.querySelector('li');
							first_li_styles = getComputedStyle(first_li);
							console.dir(first_li_styles);

							// Output:
							<div class="output">
							CSSStyleDeclaration	
							</div>
						</code></pre>

				<p>
					What we get back is the
					<span class="monoText">CSSStyleDeclaration</span> object, with numerous properties. We see many keys with values assigned by default, as well as keys containing the values (styles) we assigned. Because the <span class="monoText">CSSStyleDeclaration</span> is an object, we can specify what styles we want to see with the usual <span class="monoText">object.key</span> syntax. For example, if we wanted to see the color for the <span class="monoText">h1</span> element:
				</p>

				<pre class="language-javascript"><code>
							const h1 = document.querySelector('h1');
							const h1_styles = getComputedStyle(h1);
							console.log(h1_styles.color);
							
							// Output:
							<div class="output">
							rgb(95, 158, 160)	
							</div>
						</code></pre>

				<p>
					The
					<span class="monoText">getComputedStyle()</span> method is a very useful way to see what's going on with a page's styles, and consequently, for debugging.
				</p>
			</section>

			<section id="better_way_to_add_styles" class="grid-item">
				<h3>A Better Way to Add Multiple Styles: Manipulating Classes</h3>
				<p>
					In the preceding section, we used a
					<span class="monoText">for of</span> loop to make changes to multiple elements. While the method works, there is a more straightforward way&mdash;manipulating classes. Reusing the HTML from the previous example:
				</p>

				<pre class="language-html"><code>
							&#x9;&#x3C;body&#x3E;
							&#x9;&#x3C;h1&#x3E;Hello, world&#x3C;/h1&#x3E;
							&#x9;&#x3C;section class=&#x22;content_font&#x22;&#x3E;
									&#x3C;h2&#x3E;Some old programming languages:&#x3C;/h2&#x3E;
									&#x3C;ul&#x3E;
										&#x3C;li&#x3E;Fortran&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Lisp&#x3C;/li&#x3E;
										&#x3C;li&#x3E;COBOL&#x3C;/li&#x3E;
										&#x3C;li&#x3E;BASIC&#x3C;/li&#x3E;
										&#x3C;li&#x3E;Pascal&#x3C;/li&#x3E;
										&#x3C;li&#x3E;C&#x3C;/li&#x3E;
									&#x3C;/ul&#x3E;
							&#x9;&#x3C;/section&#x3E;
							&#x9;&#x3C;script src=&#x22;/lab.js&#x22;&#x3E;&#x3C;/script&#x3E;
							&#x9;&#x3C;/body&#x3E;
						</code></pre>

				<p>The HTML code above renders as such:</p>
				<figure>
					<img src="images/languagesPage.png" alt="list of programming languages" class="htmlPage" loading="lazy"/>
				</figure>
				<p>
					We want to change the
					<span class="monoText">li</span> elements' styles. We could use the syntax <span class="monoText">.style.<span class="italicsText">property</span></span
					>, but that would be meticulous and take many lines. A better way would be to define a <span class="monoText">class</span> inside the CSS file, and assign that <span class="monoText">class</span> to the <span class="monoText">ul</span> element. So, suppose wanted all of the <span class="monoText">li</span> elements to have the <span class="monoText">font-family</span> monospace. To do so, we first write in the HTML's linked CSS file:
				</p>

				<pre class="language-css"><code>
							.monospaceFont { font-family: Monospace; }
						</code></pre>

				<p>
					The next step relies on a critical point: HTML classes are
					<span class="italicsText">attributes</span>. And because they are attributes, they have keys that can be paired with a value. Thus, in JavaScript, we write:
				</p>

				<pre class="language-javascript"><code>
							const ul = document.querySelector('ul');
							ul.setAttribute('class', 'monospaceFont');
						</code></pre>

				<p>
					Above, we selected the
					<span class="monoText">ul</span> element, and used the method <span class="monoText">.setAttribute()</span> to give the element the class <span class="monoText">.monospaceFont</span>. By assigning the class to the <span class="monoText">ul</span> element, all of the elements inside the <span class="monoText">ul</span> element now have their styles set to the style provided by the class <span class="monoText">.monospaceFont</span>. The page now looks like:
				</p>
				<figure>
					<img src="images/classLanguagesPage.png" alt="revised page" class="htmlPage" loading="lazy"/>
				</figure>
				<p>The above method also works for applying two classes. We simply need to include a space in the second argument, separating the classes:</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">element</span>.setAttribute('class', '<span class="code-annotation">class1</span> <span class="code-annotation">class2</span>');
						</code></pre>

				<h4><span class="monoText">.classList</span>: What if the Selected Element Has Multiple Classes?</h4>
				<p>
					The problem with the
					<span class="monoText">.setAttribute()</span> method is that it is not a very efficient approach when we an element with multiple classes, and we just want to add one more class. Using the <span class="monoText">.setAttribute()</span> method alone, we would have to hard-code each of the pre-existing classes, then include the new class we want to assign. For example, suppose we had the following HTML code:
				</p>

				<pre class="language-html"><code>
							&#x9;&#x3C;body&#x3E;
							&#x9;&#x3C;h1&#x3E;Hello, world&#x3C;/h1&#x3E;
							&#x9;&#x3C;section class=&#x22;content_font&#x22;&#x3E;
									&#x3C;h2&#x3E;Dr. Jekyll&#x27;s Serum&#x3C;/h2&#x3E;
									&#x3C;ul class=&#x22;redText recipe&#x22;&#x3E;
										&#x3C;li&#x3E;crystalline salt&#x3C;/li&#x3E;
										&#x3C;li&#x3E;blood-red liquor&#x3C;/li&#x3E;
										&#x3C;li&#x3E;toxic waste&#x3C;/li&#x3E;
									&#x3C;/ul&#x3E;
							&#x9;&#x3C;/section&#x3E;
							&#x9;&#x3C;script src=&#x22;/lab.js&#x22;&#x3E;&#x3C;/script&#x3E;
							&#x9;&#x3C;/body&#x3E;
						</code></pre>

				<p>
					In the above HTML code, the
					<span class="monoText">ul</span> element has multiple classes, <span class="monoText">redText</span> and <span class="monoText">recipe</span>. If we wanted to add another class, <span class="monoText">victorianText</span>, we would need to write each of the classes all over again.
				</p>
				<p>
					The solution is to use the
					<span class="monoText">.classList</span> property. We can see this property with the following JavaScript code:
				</p>

				<pre class="language-javascript"><code>
							const ul = document.querySelector('ul');
							console.dir(ul.classList);
							
							// Output:
							<div class="output">
							DOMTokenList(2)
							0: "redText"
							1: "recipe"
							length: 2
							value: "redText recipe"
							__proto__: DOMTokenList
							</div>
						</code></pre>

				<p>
					The property
					<span class="monoText">.classList</span> contains a structure called a <span class="monoText">DOMTokenList</span>. It looks like an array, but it is not. It does, however, contain the classes assigned to the <span class="monoText">ul</span> element. The <span class="monoText">DOMTokenList</span> is interesting because it contains methods. Some of these methods are:
				</p>
				<figure>
					<table>
						<tr>
							<td><span class="monoText">add</span></td>
							<td><span class="monoText">contains</span></td>
							<td><span class="monoText">entries</span></td>
							<td><span class="monoText">forEach</span></td>
						</tr>
						<tr>
							<td><span class="monoText">item</span></td>
							<td><span class="monoText">keys</span></td>
							<td><span class="monoText">length</span></td>
							<td><span class="monoText">remove</span></td>
						</tr>
						<tr>
							<td><span class="monoText">supports</span></td>
							<td><span class="monoText">toString</span></td>
							<td><span class="monoText">toggle</span></td>
							<td><span class="monoText">value</span></td>
						</tr>
						<tr>
							<td><span class="monoText">values</span></td>
							<td><span class="monoText">get length</span></td>
							<td><span class="monoText">get value</span></td>
							<td><span class="monoText">set value</span></td>
						</tr>
					</table>
				</figure>
				<p>
					So, suppose we wanted to remove from the HTML code the class
					<span class="monoText">redText</span>. We write the following:
				</p>

				<pre class="language-javascript"><code>
							const ul = document.querySelector('ul');
							ul.classList.remove('redText');
						</code></pre>

				<p>To add it back, we simply write:</p>

				<pre class="language-javascript"><code>
							ul.classList.add('redText');
						</code></pre>

				<p>Similarly, if we have the following CSS class:</p>

				<pre class="language-css"><code>
							victorianText { font-family: Fraktur }
						</code></pre>

				<p>we can add it as a class by writing:</p>

				<pre class="language-javascript"><code>
							ul.classList.add('victorianText');
						</code></pre>

				<h5>The <span class="monoText">toggle()</span> Method</h5>
				<p>
					An extremely useful method in the
					<span class="monoText">DOMTokenList</span> is the <span class="monoText">toggle()</span> method. The <span class="monoText">toggle()</span> method takes a class name as a string argument, and does one of two things:
				</p>
				<ol>
					<li>If the class does not contain the name, the method adds the class name.</li>
					<li>Else, if the class does contain the name, the method removes the class name.</li>
				</ol>
				<p>
					In sum, the
					<span class="monoText">.classList</span> property is the primary way of changing styles to HTML elements.
				</p>
			</section>

			<section id="createElements" class="grid-item">
				<h3>Creating and Inserting Elements from Scratch</h3>
				<p>
					The methods and properties in this section pertain to creating and inserting entirely new elements into an HTML document. The first step is to
					<span class="italicsText">create</span> an element.
				</p>

				<h4>The <span class="monoText">.createElement()</span> Method</h4>
				<p>The <span class="monoText">.createElement()</span> method is very straightforward. We simply call the method, and pass as a string argument the type of the element we want to create:</p>

				<pre class="language-javascript"><code>
							document.createElement('<span class="code-annotation">element type</span>')
						</code></pre>

				<p>
					So, if we wanted to create a
					<span class="monoText">div</span> element, we would write:
				</p>

				<pre class="language-javascript"><code>
							document.createElement('div');
							// Output:
							<div class="output">
							&#x3C;div&#x3E;&#x3C;/div&#x3E;	
							</div>
						</code></pre>

				<p>
					What we get back from the
					<span class="monoText">.createElement()</span> method appears to be an empty <span class="monoText">div</span> element, that's just the HTML representation. What we actually created was an object.
				</p>

				<pre class="language-javascript"><code>
							const newDiv = document.createElement('div');
							console.dir(newDiv);
							// Output:
							<div class="output">
							div	
							__proto__: HTMLDivElement
							</div>
						</code></pre>

				<p>Once an HTML element is created with JavaScript, we can manipulate it by simply assigning values as we usually do:</p>

				<pre class="language-javascript"><code>
							newDiv.classList.add('box');
							newDiv.
						</code></pre>

				<p>The next question then is, how do we add this to the page?</p>
			</section>

			<section id="inserting_elements" class="grid-item">
				<h4>The <span class="monoText">appendChild()</span> Method</h4>
				<p>
					With the
					<span class="monoText">appendChild()</span> method, we pass the parent element's name into the method as a string argument, and the created element is added to the page as a child of the parent element.
				</p>
				<p>
					For example, suppose we wanted to add another
					<span class="monoText">li</span> element to the <span class="monoText">ul</span> element in the list below:
				</p>

				<pre class="language-html"><code>
							&lt;body&gt;
							&#x9;&lt;h1&gt;Hello, world&lt;/h1&gt;
							&#x9;&lt;section class=&quot;content_font&quot;&gt;
							&#x9;&#x9;&lt;h2&gt;Dr. Jekyll&apos;s Serum&lt;/h2&gt;
							&#x9;&#x9;&lt;ul class=&quot;redText recipe&quot;&gt;
							&#x9;&#x9;&#x9;&lt;li&gt;crystalline salt&lt;/li&gt;
							&#x9;&#x9;&#x9;&lt;li&gt;blood-red liquor&lt;/li&gt;
							&#x9;&#x9;&#x9;&lt;li&gt;toxic waste&lt;/li&gt;
							&#x9;&#x9;&lt;/ul&gt;
							&#x9;&lt;/section&gt;
							&lt;script src=&quot;/lab.js&quot;&gt;&lt;/script&gt;
							&lt;/body&gt;
						</code></pre>

				<p>
					We can add the new
					<span class="monoText">li</span> element with the following:
				</p>

				<pre class="language-javascript"><code>
							const parent_ul = document.querySelector('ul');
							const new_li = document.createElement('li');
							new_li.innerText = 'widow tears'
							parent_ul.appendChild(new_li);
						</code></pre>

				<p>The page now appears as:</p>
				<figure>
					<img src="images/appendChild.png" alt="using append child" class="htmlPage" loading="lazy"/>
				</figure>
				<p>
					Note that when we use the
					<span class="monoText">.appendChild()</span> method, the inserted HTML element becomes the last child (since it is the most recent child). What if we wanted to insert the element elsewhere? I.e., in the beginning or in the middle, or just before a particular child element? For that we use the <span class="monoText">.insertBefore()</span> method.
				</p>
			</section>

			<section id="insert_before" class="grid-item">
				<h4>The <span class="monoText">.insertBefore()</span> Method</h4>
				<p>The <span class="monoText">.insertBefore()</span> method allows us to insert a created element immediately before an existing element. To use the <span class="monoText">.insertBefore()</span> method, we must (1) select the parent element, and (2) select the child element that the created element will come before.</p>
				<p>
					So, suppose we wanted to add another
					<span class="monoText">li</span> element into the list, "newt's tongue" just before the <span class="monoText">li</span> element "blood-red liquor." We would write:
				</p>

				<pre class="language-javascript"><code>
						// select the parent element
						const parent_ul = document.querySelector('ul');	
						// select the child element
						const second_li = document.querySelector('ul li:nth-child(2)');
						// create the element
						const new_li = document.createElement('li');
						// insert text
						new_li.innerText = "newt's tongue";
						// insert element
						parent_ul.insertBefore(new_li, second_li);
						</code></pre>

				<p>The HTML code renders as:</p>
				<figure>
					<img src="images/insertBefore.png" alt="using insert before" class="htmlPage" loading="lazy"/>
				</figure>
				<p>
					Thus, the general syntax of the
					<span class="monoText">.insertBefore()</span> method:
				</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">parentElement</span>.insertBefore(<span class="code-annotation">newElement</span>, <span class="code-annotation">element newElement comes before</span>)
						</code></pre>

				<p>
					Alternatively, we can use the
					<span class="monoText">.insertAdjacentElement()</span>
					method.
				</p>
			</section>

			<section id="insertAdjacentElement" class="grid-item">
				<h4>
					The
					<span class="monoText">.insertAdjacentElement()</span>
					Method
				</h4>
				<p>
					The
					<span class="monoText">.insertAdjacentElement()</span>
					method allows us to insert a created element next to a particular element. To use the
					<span class="monoText">.insertAdjacentElement()</span>
					method, we use the following syntax:
				</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">targetElement</span>.insertAdjacentElement(<span class="code-annotation">position</span>, <span class="code-annotation">createdElement</span>)
						</code></pre>

				<p>
					In the syntax,
					<span class="italicsText">targetElement</span> means the element we want the created element to be adjacent to. The <span class="italicsText">position</span> parameter is the position we want the created element to be in, relative to the <span class="italicsText">targetElement</span>. The <span class="italicsText">position</span> parameter takes one of four possible strings:
				</p>
				<figure>
					<table>
						<thead>
							<th>Position</th>
							<th>Description</th>
						</thead>
						<tbody>
							<tr>
								<td><span class="monoText">'beforebegin'</span></td>
								<td>
									Before
									<span class="italicsText">targetElement</span>
									entirely.
								</td>
							</tr>
							<tr>
								<td><span class="monoText">'afterbegin'</span></td>
								<td>
									Immediately inside
									<span class="italicsText">targetElement</span>, before its first child (could be text).
								</td>
							</tr>
							<tr>
								<td><span class="monoText">'beforeend'</span></td>
								<td>
									Immediately inside
									<span class="italicsText">targetElement</span>, after its first child (could be text).
								</td>
							</tr>
							<tr>
								<td><span class="monoText">'afterend'</span></td>
								<td>
									After
									<span class="italicsText">targetElement</span>
									entirely.
								</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>Or, more explicitly:</p>
				<figure>
					<img src="images/insertAdjacentElement.svg" alt="insert adjacent element properties" loading="lazy"/>
				</figure>
			</section>

			<section id="append_method" class="grid-item">
				<h4>The <span class="monoText">.append()</span> Method</h4>
				<p>The <span class="monoText">.append()</span> method allows us to store append multiple elements at once. The general syntax:</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">selectedElement</span>.append(<span class="code-annotation">createdElement1</span>, <span class="code-annotation">createdElement2</span>)
						</code></pre>

				<p>
					With this method, the created elements are added as the last elements.
					<span class="italicsText">createdElement1</span> first, and <span class="italicsText">createdElement2</span> second. So, for example, say we have the following HTML code:
				</p>

				<pre class="language-html"><code>
									&lt;body&gt;
										&lt;h1&gt;Hello, world&lt;/h1&gt;
										&lt;section&gt;
												&lt;h2&gt;Determine whether you have COD income&lt;/h2&gt;
												&lt;ol&gt;
													&lt;li&gt;Do you have a debt?&lt;/li&gt;
													&lt;li&gt;Was that debt paid by another?&lt;/li&gt;
												&lt;/ol&gt;
										&lt;/section&gt;
										&lt;script src=&quot;/lab.js&quot;&gt;&lt;/script&gt;
									&lt;/body&gt;
						</code></pre>

				<p>Suppose we wanted to add two more steps to the list above. We can do so by writing the following:</p>

				<pre class="language-javascript"><code>
							const cod_analysis = document.querySelector('ul');
							const cod_analysis_step3 = document.createElement('li');
							const cod_analysis_step4 = document.createElement('li');
							cod_analysis_step3.innerText = 'Is the debt recourse?';
							cod_analysis_step4.innerText = 'Is the debt nonrecourse?';
							cod_analysis.append(cod_analysis_step3, cod_analysis_step4);
						</code></pre>

				<p>The parent <span class="monoText">ul</span> element now includes two more <span class="monoText">li</span> element. Note the difference between the <span class="monoText">.append()</span> method and the <span class="monoText">.appendChild()</span> method. With the <span class="monoText">.append()</span> method, we can insert multiple elements, but the with <span class="monoText">.appendChild()</span> method, we can only insert one element at a time.</p>
			</section>

			<section id="prepend_method" class="grid-item">
				<h3>The <span class="monoText">.prepend()</span> Method</h3>
				<p>The <span class="monoText">.prepend()</span> method works the same way as <span class="monoText">.append()</span>, but instead of the elements added at the very end, the elements are added at the very beginning. The general syntax:</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">selectedElement</span>.prepend(<span class="code-annotation">createdElement1</span>, <span class="code-annotation">createdElement2</span>);
						</code></pre>
			</section>

			<section id="removing_elments" class="grid-item">
				<h3>Removing Elements</h3>
				<p>
					The methods in this section are aimed at removing elements. The two key methods for removing elements are
					<span class="monoText">.remove()</span> and <span class="monoText">.removeChild</span>. Both of these elements syntactically follow the same pattern as <span class="monoText">.appendChild()</span> and <span class="monoText">.append()</span>.
				</p>
			</section>

			<section id="remove_child_method" class="grid-item">
				<h4>The <span class="monoText">.removeChild()</span> Method</h4>
				<p>The <span class="monoText">.removeChild()</span> method removes only one element. Suppose the following HTML code:</p>

				<pre class="language-html"><code>
									&lt;body&gt;
										&lt;h1&gt;Hello, world&lt;/h1&gt;
										&lt;section&gt;
												&lt;h2&gt;Shopping list&lt;/h2&gt;
												&lt;ul&gt;
													&lt;li&gt;milk&lt;/li&gt;
													&lt;li&gt;eggs&lt;/li&gt;
													&lt;li&gt;bacon&lt;/li&gt;
												&lt;/ul&gt;
										&lt;/section&gt;
										&lt;script src=&quot;/lab.js&quot;&gt;&lt;/script&gt;
									&lt;/body&gt;
						</code></pre>

				<p>
					Suppose we wanted to remove the second
					<span class="monoText">li</span>, containing the word "eggs." To do so, we would write:
				</p>

				<pre class="language-javascript"><code>
							const shopping_list = document.querySelector('ul');
							const eggs = shopping_list.children[1];
							// remove eggs:
							shopping_list.removeChild(eggs);
						</code></pre>

				<p>
					Executing the code above, the second
					<span class="monoText">li</span> element, containing "eggs" is now gone. To summarize, the syntactical pattern is:
				</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">parentElement</span>.removeChild(<span class="code-annotation">childElement</span>)
						</code></pre>

				<p>Note that this means means that the method only works if the element we want to remove is, in fact, a child of the selected element.</p>
			</section>

			<section id="remove_method" class="grid-item">
				<h4>The <span class="monoText">.remove()</span> Method</h4>
				<p>The <span class="monoText">.remove()</span> method is analogous to the <span class="monoText">.append()</span> method, with the difference of course being a removal of elements rather than their insertion. Syntactically:</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">selectedElement</span>.remove(<span class="monoText">element1</span>, <span class="monoText">element2</span>).
						</code></pre>
			</section>

			<section class="grid-item">
				<h2>DOM Events</h2>
				<p>
					Most modern websites have elements that change depending on how we interact with things on the page. How are these implemented?
					<span class="term">DOM events</span> are what allow us to execute JavaScript code when a particular event occurs&mdash;usually, when the user does something on the page. DOM events are used by numerous modern websites. Things like animating a picture, changing element appearance when a user hovers over it, or displaying different text based on a click&mdash;these are all done through DOM events. The basic idea: when a user does something, JavaScript executes code. The pattern is generally the following:
				</p>

				<pre class="language-html"><code>
						{ HTML element we're focusing on } --> [ event ] --> { code block }
					</code></pre>

				<p>So, for example, maybe we want a text's color to change when a user clicks a button:</p>

				<pre class="language-html"><code>
						{ button } --> [ click ] --> { code to change color }
					</code></pre>
			</section>

			<section id="writing_a_dom_event" class="grid-item">
				<h3>DOM Event Syntax</h3>
				<p>There are many ways to write code using DOM events. We cover some of the methods below.</p>
				<h4>Assigning a Function</h4>
				<p>
					One way to use a DOM event is to give an HTML element an
					<span class="monoText">id</span>, select that element, then write the code we want to apply to that selected element through a DOM event. For example, suppose we had the following HTML code:
				</p>

				<pre class="language-html"><code>
									&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;button id=&quot;clicker&quot;&gt;Clicker&lt;/button&gt;
						</code></pre>

				<p>Selecting the button above:</p>

				<pre class="language-javascript"><code>
									const clicker_button = document.querySelector('#clicker');
								</code></pre>

				<p>
					If we execute
					<span class="monoText">console.dir(clicker_button)</span>, we get an object, displaying numerous properties prefixed with the word <span class="monoText">on</span>. These are all properties we can set values (like functions&mdash;code to execute). So, say we want the button to display an alert when we click it. Suppose we wrote:
				</p>

				<pre class="language-javascript"><code>
							clicker_button.onclick = alert('hello');
						</code></pre>

				<p>If we executed the code above, rather than the alert displaying only if the button is clicked, it displays immediately. Why is this? Because all we really did was initialize a variable, and then set the value of <span class="monoText">clicker_button.onclick</span> to <span class="monoText">alert('hello')</span>, a function. Essentially, the value assigned to <span class="monoText">clicker_button.onclick</span> is whatever value is returned from <span class="monoText">alert('hello')</span> (which is undefined). Nowhere in that code did we tell JavaScript, "When the user clicks the button, display the alert." So, to get the button to display the alert when the button is clicked, we need to write a function that <span class="italicsText">returns</span> the alert when clicked. Thus:</p>

				<pre class="language-javascript"><code>
							clicker_button.onclick = function() {
								alert('Hello');
							};
						</code></pre>

				<p>Now the alert is displayed only when the button is clicked. This, however, is not a good way to write code using DOM events. Why? Because we are assigning a function to a property. This means that later down the code, if we assign another function to the property, the previous function we assigned will not execute on the event. As a result, this prevents us from assigning two functions to the same property, which is something that is done very often when using DOM events. For example, let's say that we wanted one function to execute when the user clicks a button the first time, and a different function to execute when the user clicks the same button the second time. By using the function assignment method, we completely lose the first function's execution.</p>
				<p>
					A better way to use DOM events is with
					<span class="monoText">addEventListener</span>. This is the standard method of using DOM events.
				</p>
			</section>

			<section id="add_event_listener" class="grid-item">
				<h4><span class="monoText">.addEventListener()</span></h4>
				<p>With the <span class="monoText">.addEventListener()</span> method, we can add as many events as we want. The general syntax:</p>

				<pre class="language-javascript"><code>
							<span class="code-annotation">selectedElement</span>.addEventListener('<span class="code-annotation">event</span>', <span class="code-annotation">function</span>);
						</code></pre>

				<p>To implement the same code in the previous section with the method, we would write:</p>

				<pre class="language-javascript"><code>
									const clicker_button = document.querySelector("#clicker");
									clicker_button.addEventListener('click', function () {
										alert("Hello");
									})
						</code></pre>

				<p>Here is another example that changes the button's text when we hover our cursor over the button, and changes it back to the original text:</p>

				<pre class="language-javascript"><code>
									clicker_button.addEventListener("mouseover", function () {
										clicker_button.innerText = "I am waiting";
									});
									clicker_button.addEventListener("mouseout", function () {
											clicker_button.innerText = "Click me";
									});
						</code></pre>
			</section>

			<section id="multiple_elements_event_listeners" class="grid-item">
				<h3>Attaching Event Listeners to Multiple Elements</h3>
				<p>In many situations, the events we want to use apply to more than one element. For example, say a web page has multiple button elements, and there is code we want to execute whenever an event occurs on any of the button elements. Looking at the material thus far, it seems that we would have to attach the events manually, one at a time. But, that is not at all what we do (nor ever should do). Whenever we have a situation of multiple elements that share a property (e.g., a button type element), we should always consider the possibility of using a loop. And in fact, that is what we use.</p>
				<p>To illustrate, let's use JavaScript to create some colored boxes in HTML. In our HTML file, we have the following code:</p>

				<pre class="language-html"><code>
							&#x9;&lt;body&gt;
							&#x9;&#x9;&lt;section id=&quot;boxes&quot;&gt;
							&#x9;&#x9;&lt;/section&gt;
							&#x9;&#x9;&lt;script src=&quot;lab.js&quot;&gt;&lt;/script&gt;
							&#x9;&lt;/body&gt;
						</code></pre>

				<p>And in a separate CSS file, we have the following:</p>

				<pre class="language-css"><code>
							#boxes {
								display: flex;
								justify-content: space-between;
								align-items: center;
							}
							.box {
								width: 10vw;
								height: 10vw;
							}
						</code></pre>

				<p>Finally, to generate the boxes, we write the following JavaScript code:</p>

				<pre class="language-javascript"><code>
							// Create an array of colors
							const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'indigo', 'violet'];
							// Target the parent container
							const container = document.querySelector('#boxes')
							// For each of the colors, create a div element
							// Then, for each of the divs, set backgroundColor to the color: 

							for (let color of colors) {
								const box = document.createElement('div'); // create div element
								box.style.backgroundColor = color; // give element backgroundColor
								box.classList.add('box'); // add the class box
								container.appendChild(box); // insert element to page
							}
						</code></pre>

				<p>From the above code, we have the following boxes:</p>
				<figure>
					<img src="images/coloredBoxes.png" alt="colored boxes" class="htmlPage" loading="lazy"/>
				</figure>
				<p>
					Now let's say we want to add an event. When a box is clicked on, the console displays the name of the box's color. To do so, we use a
					<span class="monoText">for</span> loop.
				</p>

				<pre class="language-javascript"><code>
							const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'indigo', 'violet'];
							const container = document.querySelector('#boxes')
							/*
							We could add a separate loop, but a faster way would be to just use the loop we already have:
							*/
							for (let color of colors) {
								const box = document.createElement('div');
								box.style.backgroundColor = color; 
								box.classList.add('box'); 
								container.appendChild(box);
								
								// add the event for each of the boxes:
								box.addEventListener('click', function() {
									console.log(box.style.backgroundColor);
								})
							}
						</code></pre>

				<p>The console should now display the name of box's color when the box is clicked. While this method works, it is poorly designed. Why? For starters, we're passing a function as an argument into the method, and we're defining that function directly inside the method. This might not seem like a bad choice when the function is merely a simple line, but it can quickly become problematic when the function begins spanning ten, or even hundreds of lines of code. Worse yet, what if we want to reuse that function? A better design is to declare and define the function outside the loop, and then pass that function's name into the loop:</p>

				<pre class="language-javascript"><code>
							const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'indigo', 'violet'];
							
							// Define the function with the keyword this
							const printColor = function() {
								console.log(this.style.backgroundColor)
							} 

							const container = document.querySelector('#boxes');
							for (let color of colors) {
								const box = document.createElement('div');
								box.style.backgroundColor = color; 
								box.classList.add('box'); 
								container.appendChild(box);

								box.addEventListener('click', printColor) // pass function name as arg
							}
						</code></pre>

				<p>
					In the above code, we used the keyword
					<span class="monoText">this</span> in the <span class="monoText">printColor</span> function's definition. Here, <span class="monoText">this</span> refers to the object <span class="monoText">box</span>. Because it refers to <span class="monoText">box</span>, the function <span class="monoText">printColor</span> has access to the variable <span class="monoText">box</span> (assigned the <span class="monoText">div</span> element object we created), and all the properties that come with <span class="monoText">box</span>.
				</p>
			</section>

			<section id="the_event_object" class="grid-item">
				<h3>The Event Object</h3>
				<p>Suppose we executed the following:</p>

				<pre class="language-javascript"><code>
							const changeButtonColor = function () {
								this.style.backgroundColor = 'firebrick';
							};
							const button = document.createElement('button');
							document.body.appendChild(button);
							button.innerText = 'I am a button';
							button.addEventListener('click', changeButtonColor);
						</code></pre>

				<p>
					In the code above, clicking the
					<span class="monoText">button</span> element changes the button's color, per the <span class="monoText">changeButtonColor</span> function. When the button is clicked, we do not actually execute the code&mdash;i.e., we didn't write anything else in the program saying, execute this when this when this happens. So how is the <span class="monoText">changeButtonColor</span> function actually executing? This is all the work of a structure called the <span class="term">event object</span>.
				</p>
				<p>
					When the button is clicked, the JavaScript passes an argument into our function. That argument is the
					<span class="monoText">event object</span>. The event object is an extremely useful tool when designing complex websites that take specific users inputs. What exactly does this object look like? Well, let's execute some code:
				</p>

				<pre class="language-javascript"><code>
							const changeButtonColor = function (event) {
								console.log(event);
								this.style.backgroundColor = 'firebrick';
							};
							const button = document.createElement('button');
							document.body.appendChild(button);
							button.innerText = 'I am a button';
							button.addEventListener('click', changeButtonColor);
						</code></pre>

				<p>
					What we get back out is a huge object with numerous properties. We see a line that says
					<span class="monoText">__proto__: MouseEvent</span>, indicating to us that this is a mouse event. Let's try another event, a keyboard event.
				</p>
			</section>

			<section id="keyboard_events" class="grid-item">
				<h4>Keyboard Events</h4>
				<p>Let's write the following code:</p>

				<pre class="language-javascript"><code>
									document.body.addEventListener('keypress', function (event) { console.log(event); });
						</code></pre>

				<p>
					In the code above, we added an
					<span class="monoText">eventListener</span> to the <span class="monoText">body</span> element. When a key is pressed while on the page, a function executes&mdash;display in the console the event object passed as an argument. Looking at that object, we also see numerous properties. We see <span class="monoText">key: "Enter"</span>, which is the key that was pressed. There are other properties: <span class="monoText">shift:</span>, indicating whether the shift key was held, and <span class="monoText">ctrlKey:</span>, indicating whether the control key was held.
				</p>

				<h5>The <span class="monoText">keydown</span> Property</h5>
				<p>Suppose we have this <span class="monoText">input</span> element:</p>

				<pre class="language-html"><code>
							&#x9;&lt;body&gt;
							&#x9;&#x9;&lt;input id=&quot;username&quot; placeholder=&quot;username&quot; type=&quot;text&quot;/&gt;
							&#x9;&#x9;&lt;script src=&quot;lab.js&quot;&gt;&lt;/script&gt;
							&#x9;&lt;/body&gt;
						</code></pre>

				<p>
					The code above will render as a text input field. With the
					<span class="italicsText">events object</span>, we can listen for certain events involving key presses. Let's write the following:
				</p>

				<pre class="language-javascript"><code>
							const input = document.querySelector('#username'); // select the text input field
							input.addEventListener('keydown', function (event) {
								console.log('Key pressed');
							})
						</code></pre>

				<p>The code above executes a function whenever a key is pressed inside the <span class="monoText">text input</span> element. More specifically, the <span class="monoText">keydown</span> property will execute the function whenever <span class="underlineText">any</span> key is pressed, whether it's a <span class="monoText">cmd</span>, <span class="monoText">shift</span>, or <span class="monoText">char</span> key.</p>

				<h5>The <span class="monoText">keyup</span> Property</h5>
				<p>Say we rewrote the code above instead as:</p>

				<pre class="language-javascript"><code>
							const input = document.querySelector('#username'); // select the text input field
							input.addEventListener('keyup', function (event) {
								console.log('Key released');
							})
						</code></pre>

				<p>The <span class="monoText">keyup</span> property is the inverse of the <span class="monoText">keydown</span> property. The function executes when <span class="underlineText">any</span> key is <span class="italicsText">released</span>.</p>

				<h5>The <span class="monoText">keypress</span> Property</h5>
				<p>
					What if we want only certain keys to execute the function? One way to accomplish this is to use the
					<span class="monoText">keydown</span> property. With the <span class="monoText">keydown</span> property, the <span class="monoText">EventListener</span>'s function is executed only if there is a visual change in the <span class="monoText">input</span> element. For example, there must be an actual character appearing in the input field for the function to execute. So, for example, if we wrote in our JavaScript file:
				</p>

				<pre class="language-javascript"><code>
							const input = document.querySelector('#username'); // select the text input field
							input.addEventListener('keypress', function (event) {
								console.log('Key pressed down');
							})
						</code></pre>

				<p>Now the function executes <span class="italicsText">only if</span> a key is pressed and the key's output appears in the <span class="monoText">text input</span> element (e.g., a character or a space). There is, however, an exception to this rule: the <span class="monoText">enter</span> key is considered a keypress. But, the <span class="monoText">delete</span> key is not considered a keypress.</p>

				<h6>Application: A Shopping List</h6>
				<p>
					Let's say we have an HTML page with a
					<span class="monoText">ul</span> element:
				</p>

				<pre class="language-html"><code>
							&lt;body&gt;
							&#x9;&lt;input type=&quot;text&quot; name=&quot;shoppingItem&quot; id=&quot;shoppingItem&quot;&gt;
							&#x9;&lt;ul&gt;&lt;/ul&gt;
							&lt;/body&gt;
						</code></pre>

				<p>We can write JavaScript so that when the user types an item into the text field, then presses enter, the text entered gets added as a list item:</p>

				<pre class="language-javascript"><code>
							const ul = document.querySelector('ul'); // select the ul
							const inputField = document.querySelector('input'); // select the input
							inputField.addEventListener('keypress', function (e) { // the event
								if (e.key === 'Enter') {
									const item = this.value; // store value entered
									const newListItem = document.createElement('li'); // create an li
									newListItem.innerText = item; // make li text the value entered
									ul.appendChild(newListItem); // add item to ul element
									this.value = ''; // clear input field
								}
							})
						</code></pre>
			</section>

			<section id="form_events_intro" class="grid-item">
				<h2>Form Events</h2>
				<p>Forms are everywhere. We have forms for creating accounts, surveys, shopping, messaging; there's no end in sight. While they all serve different purposes, they have at least one thing in common&mdash;JavaScript.</p>
				<h3>A Simple HTML Form</h3>
				<p>Let's say we have the following HTML form:</p>

				<pre class="language-html"><code>
							&lt;body&gt;
							&#x9;&lt;form action=&quot;&quot;&gt;
							&#x9;&#x9;&lt;input type=&quot;text&quot; placeholder=&quot;First Name, Last Name&quot;&gt;
							&#x9;&#x9;&lt;label&gt;
							&#x9;&#x9;&#x9;Student
							&#x9;&#x9;&#x9;&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;
							&#x9;&#x9;&lt;/label&gt;
							&#x9;&#x9;&lt;select name=&quot;&quot; id=&quot;&quot;&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;physics&quot;&gt;Physics&lt;/option&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;mathematics&quot;&gt;Mathematics&lt;/option&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;computerScience&quot;&gt;Computer Science&lt;/option&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;chemistry&quot;&gt;Chemistry&lt;/option&gt;
							&#x9;&#x9;&lt;/select&gt;
							&#x9;&#x9;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
							&#x9;&lt;/form&gt;
							&#x9;&lt;script src=&quot;lab.js&quot;&gt;&lt;/script&gt;
							&lt;/body&gt;
						</code></pre>

				<p>
					This code generates a form. When we click submit, the page refreshes. This is because a
					<span class="monoText">form</span> element takes data inputted by a user, and sends it elsewhere. Traditionally, this data is sent to a URL in the <span class="monoText">form</span> element's <span class="monoText">action</span> attribute:
				</p>

				<pre class="language-html"><code>
									&lt;form action=&quot;/register&quot;&gt;&lt;/form&gt;
						</code></pre>

				<p>
					Modern frameworks, however, allow us to work with forms differently. Instead of sending the data to a specific URL, the data is sent to a linked JavaScript file, to be used in by the code inside that file. Essentially, rather than sending a request, we
					<span class="italicsText">intercept</span> the data and use it. With this behavior enabled, the page does not actually refresh. This allows us to write single-page applications. How do we enable this feature? First, we give our <span class="monoText">form</span> element an <span class="monoText">id</span> attribute:
				</p>

				<pre class="language-html"><code>
									&lt;form id=&quot;register&quot;&gt;&lt;/form&gt;
						</code></pre>

				<p>
					Second, we go into our linked JavaScript file, select the
					<span class="monoText">form</span> element, and add to it an <span class="monoText">event listener</span>:
				</p>

				<pre class="language-javascript"><code>
							const form = document.querySelector('#register');
							form.addEventListener('submit', function(event) {
								alert('Form submitted!');
							});
						</code></pre>

				<p>
					With the above code, the page displays an alert when the form is is submitted. Notice, however, that the page reloads. Why is this occurring? Because this is the default behavior for when a
					<span class="monoText">form</span> element is submitted&mdash;it refreshes the page. The prevent this default behavior, we must use a method in the <span class="monoText">event object</span>: <span class="monoText">preventDefault()</span>. Thus, in our JavaScript code, we need to write:
				</p>

				<pre class="language-javascript"><code>
							const form = document.querySelector('#register');
							form.addEventListener('submit', function(event) {
								alert('Form submitted!');
								event.preventDefault();
							});
						</code></pre>

				<p>With the <span class="monoText">.preventDefault()</span> method included, the page no longer refreshes.</p>

				<h3>Why the <span class="monoText">submit</span> Element is So useful</h3>
				<p>
					Forms allow us to execute code when certain conditions are met. With the above code, let's say that the user doesn't check the
					<span class="monoText">checkbox input</span> and clicks any one of the three <span class="monoText">select</span> elements from the dropdown. The form might execute different code depending on what those inputs are. One way to get JavaScript to decide which code to execute is to add <span class="monoText">event listener</span> to each of the <span class="monoText">input</span> elements. I.e., "If the user doesn't check <span class="monoText">student</span> and selects <span class="monoText">physics</span>, execute this code; else if <span class="monoText">student</span> is checked and selects <span class="monoText">physics</span>, execute this code; else if ..." This can quickly become tedious.
				</p>
				<p>With the <span class="monoText">submit</span> element however, we need just one <span class="monoText">event listener</span>&mdash;listen to the <span class="monoText">submit</span> event.</p>
			</section>

			<section id="form_data_extraction" class="grid-item">
				<h3>Extracting the Data from the Form</h3>
				<p>To extract the data from the submitted form, we need to select the form elements. So, looking at the HTML code again:</p>

				<pre class="language-html"><code>
							&lt;body&gt;
							&#x9;&lt;form action=&quot;&quot;&gt;
							&#x9;&#x9;&lt;input type=&quot;text&quot; placeholder=&quot;First Name, Last Name&quot;&gt;
							&#x9;&#x9;&lt;label&gt;
							&#x9;&#x9;&#x9;Student
							&#x9;&#x9;&#x9;&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;
							&#x9;&#x9;&lt;/label&gt;
							&#x9;&#x9;&lt;select name=&quot;&quot; id=&quot;&quot;&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;physics&quot;&gt;Physics&lt;/option&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;mathematics&quot;&gt;Mathematics&lt;/option&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;computerScience&quot;&gt;Computer Science&lt;/option&gt;
							&#x9;&#x9;&#x9;&lt;option value=&quot;chemistry&quot;&gt;Chemistry&lt;/option&gt;
							&#x9;&#x9;&lt;/select&gt;
							&#x9;&#x9;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
							&#x9;&lt;/form&gt;
							&#x9;&lt;script src=&quot;lab.js&quot;&gt;&lt;/script&gt;
							&lt;/body&gt;
						</code></pre>

				<p>We have the following elements in the form:</p>
				<ul>
					<li>a <span class="monoText">input[type=text]</span></li>
					<li>a <span class="monoText">input[type=checkbox]</span></li>
					<li>a <span class="monoText">select</span></li>
					<li>a <span class="monoText">option[value=physics]</span></li>
					<li>a <span class="monoText">option[value=mathematics]</span></li>
					<li>a <span class="monoText">option[value=computerScience]</span></li>
					<li>a <span class="monoText">option[value=chemistry]</span></li>
				</ul>
				<p>
					For, now let's select the
					<span class="monoText">text input</span> element, the <span class="monoText">checkbox input</span>, and the <span class="monoText">select</span> element:
				</p>

				<pre class="language-javascript"><code>
									const name = document.querySelector('input[type=text]');
									const studentCheckbox = document.querySelector('input[type=checkbox]');
							const field = document.querySelector('select');
						</code></pre>

				<p>
					Then, to use their values, we reference the
					<span class="monoText">.value</span> property. For now, let's do something simple: display the value in the console. We'll populate the form with the following: "Evariste Galois" in the <span class="monoText">text input</span> element, check the <span class="monoText">checkbox element</span>, and select <span class="monoText">mathematics</span> from the dropdown.
				</p>

				<pre class="language-javascript"><code>
							const form = document.querySelector('#register');

							const name = document.querySelector('input[type=text]');
							const studentCheckbox = document.querySelector('input[type=checkbox]');
							const field = document.querySelector('option[value="physics');
							// addEventListener for the submit event
							form.addEventListener('submit', function (event) { // use event object
								console.log(name.value);
								console.log(studentCheckbox.value);
								console.log(field.value);
								event.preventDefault();
							});
						</code></pre>

				<p>We get back out the following in the console:</p>

				<pre class="language-javascript"><code>
							'Evariste Galois'
							'on'
							'mathematics'
						</code></pre>

				<p>
					We are getting the values we expected for the
					<span class="monoText">text input</span> element and the <span class="monoText">select</span> element, but we're not getting what we expected for the <span class="monoText">checkbox</span> element. This is because the value for the <span class="monoText">checkbox</span> element, by default, is <span class="monoText">on</span>. A better "value" for the <span class="monoText">checkbox</span> element would be true (the checkbox element is checked) or false (the checkbox element is false). Those values are contained in the property <span class="monoText">.checked</span>. So, rewriting our code:
				</p>

				<pre class="language-javascript"><code>
						const form = document.querySelector('#register');

						const name = document.querySelector('input[type=text]');
						const studentCheckbox = document.querySelector('input[type=checkbox]');
						const field = document.querySelector('option[value="physics');
						// addEventListener for the submit event
						form.addEventListener('submit', function (event) { // use event object
							console.log(name.value);
							console.log(studentCheckbox.checked);
							console.log(field.value);
							event.preventDefault();
						});
						</code></pre>

				<p>Populating the same fields, we now have the following:</p>

				<pre class="language-javascript"><code>
							'Evariste Galois'
							true
							'mathematics'
						</code></pre>
			</section>

			<section id="input_to_change_events" class="grid-item">
				<h3>Input and Change Events</h3>
				<p>The two properties <span class="monoText">.onInput</span> and <span class="monoText">.onChange</span> allow JavaScript to listen to changes across multiple inputs. This allows us to store data as a user enters it, rather than waiting for the user to enter <span class="monoText">submit</span>.</p>
				<p>Let's say we had the following form:</p>

				<pre class="language-html"><code>
							&lt;body&gt;
							&lt;form id=&quot;register&quot;&gt;
							&#x9;&lt;input
							&#x9;&#x9;type=&quot;text&quot;
							&#x9;&#x9;name=&quot;firstName&quot;
							&#x9;&#x9;id=&quot;firstName&quot;
							&#x9;&#x9;placeholder=&quot;First Name&quot;
							&#x9;/&gt;
							&#x9;&lt;input
							&#x9;&#x9;type=&quot;text&quot;
							&#x9;&#x9;name=&quot;lastName&quot;
							&#x9;&#x9;id=&quot;lastName&quot;
							&#x9;&#x9;placeholder=&quot;Last Name&quot;
							&#x9;/&gt;
							&#x9;&lt;p&gt;I am a:&lt;/p&gt;
							&#x9;&lt;div&gt;
							&#x9;&#x9;&lt;input type=&quot;checkbox&quot; name=&quot;student&quot; id=&quot;student&quot; /&gt;
							&#x9;&#x9;&lt;label for=&quot;student&quot;&gt;Student&lt;/label&gt;
							&#x9;&lt;/div&gt;
							&#x9;&lt;div&gt;
							&#x9;&#x9;&lt;input type=&quot;checkbox&quot; name=&quot;professional&quot; id=&quot;professional&quot; /&gt;
							&#x9;&#x9;&lt;label for=&quot;professional&quot;&gt;Professional&lt;/label&gt;
							&#x9;&lt;/div&gt;
							&#x9;&lt;div&gt;
							&#x9;&#x9;&lt;input type=&quot;checkbox&quot; name=&quot;academic&quot; id=&quot;academic&quot; /&gt;
							&#x9;&#x9;&lt;label for=&quot;academic&quot;&gt;Academic&lt;/label&gt;
							&#x9;&lt;/div&gt;
							&#x9;&lt;p&gt;My research interests are:&lt;/p&gt;
							&#x9;&lt;select name=&quot;researchField&quot; id=&quot;researchField&quot;&gt;
							&#x9;&#x9;&lt;option value=&quot;AI&quot;&gt;Artificial Intelligence&lt;/option&gt;
							&#x9;&#x9;&lt;option value=&quot;complexityTheory&quot;&gt;Complexity Theory&lt;/option&gt;
							&#x9;&#x9;&lt;option value=&quot;programmingLanguages&quot;&gt;Programming Languages&lt;/option&gt;
							&#x9;&lt;/select&gt;
							&#x9;&lt;div&gt;
							&#x9;&#x9;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;
							&#x9;&lt;/div&gt;
							&lt;/form&gt;
							&lt;script src=&quot;lab.js&quot;&gt;&lt;/script&gt;
							&lt;/body&gt;
						</code></pre>

				<p>The above code displays the following form:</p>
				<figure>
					<img src="images/researchForm.png" alt="A simple form" class="htmlPage" loading="lazy"/>
				</figure>
				<p>If we pass <span class="monoText">input</span> as an argument to the <span class="monoText">addEventListener</span>, we can see the data change as we type. Let's first see what happens when <span class="monoText">firstName</span> is populated:</p>

				<pre class="language-javascript"><code>
							const form = document.querySelector('#register');
							const firstName = form[0];
							firstName.addEventListener('input', (event) => {
								console.log(event)
							})
						</code></pre>

				<p>Because this data changes as the user enters it, we can capture it and place it in an object:</p>

				<pre class="language-javascript"><code>
							const form = document.querySelector('#register');
							const firstName = form[0];
							const formData = {}; // formData object
							firstName.addEventListener('input', (event) => { // target is firstName
								formData['firstName'] = event.target.value; // get target's value, place in formData object
								console.log(formData); // display in console formData object
								event.preventDefault(); // don't refresh
							});
						</code></pre>

				<p>
					The console displays the
					<span class="monoText">formData</span> object up to date. But what about the other inputs? Do we have to add three separate <span class="monoText">addEventListener</span>s to each? No. Whenever we have multiple elements inside a parent element, there's always the possibility of a loop:
				</p>

				<pre class="language-javascript"><code>
							const form = document.querySelector('#register');
							const firstName = form[0];
							const lastName = form[1];
							const student = form[2];
							const professional = form[3];
							const academic = form[4];
							const researchFieldSelect = form[5]
							const formData = {};
							for (let input of [firstName, lastName, student, professional, academic, form, researchFieldSelect]) {
								input.addEventListener('input', ({target}) => { // look at all the inputs
									const { name, type, value, checked } = target; // set name, type, value, and checked as target
									formData[name] = type === 'checkbox' ? checked : value; // if checkbox, used checked, else use value
									console.log(formData); // display formData object
								})
							}
						</code></pre>

				<p>
					The trick in the above code is using the
					<span class="monoText">name</span> attribute.
				</p>
			</section>

			<section id="promises" class="grid-item">
				<h3>Call Stack</h3>
				<p>The <span class="term">call stack</span> is the program that JavaScript uses to keep track of where it is in our code. For example, suppose we have a function that calls a function that calls another function. Those functions could be written anywhere in our source code. How does JavaScript "know" where it is? Through the <span class="italicsText">call stack</span>.</p>

				<p>The name <span class="italicsText">call stack</span> is indicative of what it does. It's specifically concerned with <span class="italicsText">calling functions</span>, hence the word "call." But what about the word "stack?" A <span class="term">stack</span> is a simple data structure, similar to a stack of dishes in a sink: you place dish 1, then dish 2 on top of dish 1, then dish 3 on top of dish 2, dish 4 on top of dish 3, etc. Once the stack ends and you're ready to wash the dishes, the first dish you wash in the stack is the dish you last placed (the dish at the very top). This is exactly how the call stack works.</p>

				<p>When we call a function, the interpreter adds that function to the call stack and starts executing the function. If, while executing the function, the interpreter encounters a function inside that function, that function is added to the call stack further up, and run where their calls are reached.</p>

				<p>Once the current function is finished, the interpreter takes it out off the stack and resumes execution where it left off in the last code list.</p>
			</section>

			<section id="node_js" class="grid-item">
				<h3><span class="monoText">node.js</span></h3>
				<p>As we know, browsers can understand <span class="monoText">html</span>, <span class="monoText">css</span>, and <span class="monoText">javascript</span>. But can <span class="monoText">javascript</span> run locally? The answer is yes, provided we have <span class="monoText">node.js</span> installed on our machine. JavaScript code is run by the <span class="monoText">V8</span> engine in <span class="monoText">node.js</span>. <span class="monoText">node.js</span> is simply an environment that can run <span class="monoText">javascript</span> code locally (&#8220;locally&#8221; usually meaning on a web server).</p>
			</section>

			<section id="python_web" class="grid-item">
				<h4>Python in Web Development</h4>
				<p>An alternative language for backend development is with <span class="monoText">Python</span>. This section assumes familiarity with basic <span class="monoText">Python</span> constructs (see the <a href="./python.html">Python notes</a>).</p>
				<p>Most of the webpages we've seen thus far are <span class="italicsText">static pages</span>. In other words, they display the exact same material despite time and place. Numerous web pages, however, are not static. The <span class="italicsText">New York Times</span> website, for example, updates routinely with news stories. On <span class="italicsText">Facebook</span>, when a user comments on a post, that comment is immediately visible to others. There are two ways to perform these updates. One way is to have someone manually update the <span class="monoText">HTML</span> content each time a user comments or each time a reporter writes a new story. The other way, however, is to write a program that automates the entire process. Pages that use the latter approach are called <span class="italicsText">dynamic pages</span>.</p>
				<p>The programs that automate these processes are called <span class="term">web applications</span>. These web applications live on <span class="term">web servers</span>. They execute when a client makes a <span class="term">request</span> to the web server. From that input request, the web application outputs the relevant <span class="monoText">HTML</span> and <span class="monoText">CSS</span>, or some other response. Creating these web applications is done through <span class="term">web frameworks</span>, of which there are a variety. Here, we focus on a <span class="monoText">Python</span>-based framework, <span class="monoText">Django</span>.</p>

				<p><span class="monoText">HTTP.</span> Requests made to a web server abide by a protocol called <span class="monoText"><span class="boldText">HTTP</span></span> (&#8220;Hypertext Transfer Protocol&#8221;). This protocol defines the rules for how messages are transferred over the internet (in this case, between client and web server). An <span class="monoText">HTTP</span> request might appear as:</p>
				<figure class="math-display">
					<ul class="syntax">
						<li>GET ${\text{page}}$ HTTP/1.1</li>
						<li>HOST: ${\text{website url}}$</li>
					</ul>
				</figure>
				<p>The expression <span class="monoText">GET</span> is a request method. In the example above, the argument passed to <span class="monoText">GET</span> is the path to the page. The expression <span class="monoText">HTTP/1.1</span> is the version of <span class="monoText">HTTP</span>. The expression <span class="monoText">HOST</span> is indicates the <span class="monoText">URL</span> for the page requested.</p>
				<p>Assuming the request complies with <span class="monoText">HTTP</span> rules, the web server returns a response that might appear as such:</p>
				<figure class="math-display">
					<ul class="syntax">
						<li>HTTP/1.1 200 OK</li>
						<li>Content-Type: text/html</li>
					</ul>
				</figure>
				<p>The number <span class="monoText">200</span> is a status code. There are number of other status codes: <span class="monoText">301</span> indicates the page moved permanently, <span class="monoText">403</span> the page is forbidden, <span class="monoText">404</span> the page is not found, <span class="monoText">500</span> there is an internal server error. <span class="monoText">200</span> indicates the request returned without problems. The expression <span class="monoText">Content-Type: text/html</span> indicates that the data returned in response to the request is <span class="monoText">HTML</span> data.</p>
				<p>Assuming <span class="monoText">django</span> is installed on our machine, running the command below creates a new <span class="monoText">django</span> project:</p>
				<pre class="language-bash"><code>
					django-admin startproject PROJECT_NAME
				</code></pre>
				<p>Let's run <span class="monoText">django-admin startproject foo</span>. This creates a new directory called <span class="monoText">foo</span>, and a file called <span class="monoText">manage.py</span>. We will examine <span class="monoText">manage.py</span> in another section, but for now, it is a file that allows us to execute certain commands in a <span class="monoText">django</span> project. Inside the <span class="monoText">foo</span> directory, we have several files:</p>
				<figure class="math-display">
					<ul class="syntax">
						<li>__init__.py</li>
						<li>asgi.py</li>
						<li>settings.py</li>
						<li>urls.py</li>
						<li>wsgi.py</li>
					</ul>
				</figure>
				<p>The <span class="monoText">settings.py</span> file contains configuration settings for the <span class="monoText">django</span> application. We can change those settings later down the line. The <span class="monoText">urls.py</span> file contains all of the different <span class="monoText">URLs</span> in the web application that we can visit. The remaining files will be explored in another section.</p>
				<p>To run the web application, we enter in the terminal:</p>
				<pre class="language-bash"><code>
					python manage.py runserver
				</code></pre>
				<p>When we run the code above, we get back debugging outputs:</p>
				<pre class="language-bash"><code>
					Watching for file changes with StatReloader
					Performing system checks...

					System check identified no issues (0 silenced).

					You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
					Run 'python manage.py migrate' to apply them.
					August 31, 2020 - 17:44:52
					Django version 3.2.6, using settings 'foo.settings'
					Starting development server at http://127.0.0.1:8000/
					Quit the server with CONTROL-C.
				</code></pre>
				<p>Focus on the second to last line. The <span class="monoText">http://127.0.0.1:8000/</span> tells us where the web application is currently running. The <span class="monoText">127.0.0.1</span> is an <span class="term">IP address</span>, an internet address. In this case, the address is for our local computer, so only we can access the web application at the moment. The <span class="monoText">8000</span> is a <span class="term">port number</span>. Internet services run on different ports, and in this case, our web application is running on the port <span class="monoText">8000</span>. If we input the address <span class="monoText">http://127.0.0.1:8000/</span> in a browser window, all we see is <span class="monoText">django</span>'s default page, telling us our <span class="monoText">django</span> installation works.</p>
				<p>The <span class="monoText">django</span> project is not the web application. Instead, it is a container that holds a web application; the project can contain multiple applications. This division is made because large websites tend to have multiple different applications. Google, for example, has a search, images, maps, videos, and numerous other applications.</p>
				<p>All this in mind, let's actually create a <span class="monoText">django</span> application. To do so, we first run the following command:</p>
				<pre class="language-bash"><code>
					python manage.py startapp &lt;name_of_app&gt;
				</code></pre>
				<p>The command above creates a new directory called <span class="monoText">bang</span>, which contains several other files. The file to focus on is <span class="monoText">views.py</span>. This is where we define what it is a user sees when they perform a certain action.</p>
				<p>After we've created the application, we need to <span class="term">install</span> the application to the project. To do so, we go into the <span class="monoText">settings.py</span> file. Inside the file are lines of code generated by <span class="monoText">django</span>. Scrolling, we should see a particular line called <span class="monoText">INSTALLED_APPS</span>. This is where <span class="monoText">django</span> configures which applications are installed on the project. To install our <span class="monoText">bang</span> application, we include <span class="monoText">bang</span> in the list:</p>
				<pre class="language-python"><code>
					INSTALLED_APPS = [
							'bang',
							'django.contrib.admin',
							'django.contrib.auth',
							'django.contrib.contenttypes',
							'django.contrib.sessions',
							'django.contrib.messages',
							'django.contrib.staticfiles',
					]
				</code></pre>
				<p>Now let's say we want <span class="monoText">bang</span> to do something when the user performs a certain action. Here, we go to the <span class="monoText">views.py</span> file. There, we see the following:</p>
				<pre class="language-python"><code>
					from django.shortcuts import render

					# Create your views here.
				</code></pre>
				<p>We can think of each <span class="monoText">view</span> as something that the user might want to see. To create a <span class="monoText">view</span> in <span class="monoText">django</span>, we define a function:</p>
				<pre class="language-python"><code>
					from django.http import HttpResponse
					from django.shortcuts import render

					# Create your views here.
					def index(request):
						return HttpResponse("Hello, world!")
				</code></pre>
				<p>The function above takes a <span class="monoText">request</span> as an argument, more specifically, an <span class="monoText">HTTP request</span>. Inside the function body, we call a method called <span class="monoText">HttpResponse()</span>. That method exists in the <span class="monoText">django.http</span> module, so we must import it.</p>
				<p>But, as we know, this is just a function definition. There is now the question of <span class="italicsText">when</span> should that function be executed. To do so, we need to configure a <span class="monoText">URL</span>. That configuration will state when the function <span class="monoText">index()</span> should be executed. To create that configuration, we need to create a <span class="monoText">urls.py</span> file for our <span class="monoText">bang</span> application. The <span class="monoText">urls.py</span> file that already exists is for the entire project. We want to have a separate <span class="monoText">urls.py</span> file unique to our application.</p>
				<p>So, while we are inside the <span class="monoText">bang</span> directory, we create a file called <span class="monoText">urls.py</span>. Inside that file, we write:</p>
				<pre class="language-python"><code>
					from django.urls import path
					from . import views

					urlpatterns = [
						path("", views.index, name="index")
					]
				</code></pre>
				<p>Above, we created a list containing methods. The method we included is the <span class="monoText">path()</span> method, found in the <span class="monoText">django.urls</span> module. Then, we pass three arguments: (1) an empty string, (2) the method we defined in <span class="monoText">views.py</span>, and (3) a <span class="monoText">name</span>. We will address the first argument shortly. The third argument binds a name to the <span class="monoText">URL</span>, and it allows us to easily reference it in other parts of the <span class="monoText">bang</span> application.</p>
				<p>Now we need to go to the <span class="monoText">urls.py</span> file in the <span class="monoText">foo</span> directory (the project directory), and update the <span class="monoText">urlpatterns</span> list there.</p>
				<pre class="language-python"><code>
					urlpatterns = [
							path('admin/', admin.site.urls),
							path('bang/', include("bang.urls"))
					]
				</code></pre>
				<p>The code above states: Create a path that leads to the <span class="monoText">bang</span> application, and include all the <span class="monoText">URLs</span> in the <span class="monoText">bang.urls</span> file.</p>
				<p>All that said, we can actually see the output with the following. First, run:</p>
				<pre class="language-bash"><code>
					python manage.py runserver
				</code></pre>
				<p>Then, in the browser, visit the link <span class="monoText">127.0.01:/bang/</span>. The text we assigned to <span class="monoText">view</span> should be displayed accordingly. We can then update the website by simply changing the return value of <span class="monoText">index</span>.</p>
				<p>Now we can create multiple views by defining more functions.</p>
				<pre class="language-python"><code>
					def index(request):
						return HttpResponse("Hello!")
					def zing(request):
						return HttpResponse("Zing!")
				</code></pre>
				<p>Following that definition, we update the <span class="monoText">urls.py</span> file for the application:</p>
				<pre class="language-python"><code>
					from django.urls import path
					from . import views
					urlpatterns = [
						path("", views.index, name="index"),
						path("zing", views.zing, name="zing")
				</code></pre>
				<p>Now if we visit <span class="monoText">127.0.0.1:8000/bang/zing</span> we see the text <span class="monoText">Zing!</span>. Now suppose that we want to return a value where the page displays <span class="monoText">"Hello &lt;name&gt;"</span> where <span class="monoText">name</span> is some variable. Rather than write multiple functions, we <span class="italicsText">parameterize</span>:</p>
				<pre class="language-python"><code>
					def greet(request, name):
						return HttpResponse(f"Hello, {name.capitaliz()}.");
				</code></pre>
				<p>Now we update the paths:</p>
				<pre class="language-python"><code>
					from django.urls import path
					from . import views
					urlpatterns = [
						path("&lt;str:name&gt;", views.greet, name="greet"),
						path("", views.index, name="index"),
						path("zing", views.zing, name="zing")
					]
				</code></pre>
				<p>The <span class="monoText">&lt;str:name&gt;</span> argument will be passed as an argument to the function <span class="monoText">greet</span> as a value for <span class="monoText">name</span>. Accordingly, when we visit <span class="monoText">127.0.0.1:8000/bang/Daniel</span>, we see <span class="monoText">Hello, Daniel.</span></p>
				<p>So far, we've been using simple strings. But <span class="monoText">HTML</span> pages aren't simply strings. They consist of tables, forms, images, etc. Surely we don't intend to copy and paste thousands of lines of <span class="monoText">HTML</span> as return strings. Indeed, we do not. We separate the actual <span class="monoText">HTML</span> content from the <span class="monoText">python</span> code.</p>
				<p>To do so, we <span class="monoText">render</span> the relevant <span class="monoText">HTML</span> file as a return from the function:</p>
				<pre class="language-python"><code>
					def index(request):
						return render(request, "bang/index.html")
				</code></pre>
				<p>So, inside our <span class="monoText">bang</span> application directory, we create a directory (we'll call it <span class="monoText">templates</span>), and then inside that directory, we create a directory called, say, <span class="monoText">bang</span>. Inside that directory, we create the relevant <span class="monoText">index.html</span> file. We perform such nesting to ensure that the <span class="monoText">html</span> files are namespaced in Python. This ensures there aren't any conflicting bindings.</p>
				<p>Now if we visit <span class="monoText">127.0.0.1:8000/bang/</span>, we see the <span class="monoText">index.html</span> page displayed.</p>
				<p>Suppose we want the <span class="monoText">HTML</span> page content to change, depending on what route the user takes. To do so, we can define a function, with an additional <span class="italicsText">dictionary</span> argument:</p>
				<pre class="language-python"><code>
					def greet(request, name):
						return render(request, "bang/greet.html", {
							"name": name.capitalize()
						})
				</code></pre>
				<p>When we render the template <span class="monoText">bang/greet.html</span>, we provide additional information to the render. In this case, we are giving the template access to an additional variable called <span class="monoText">name</span>, which is bound to the value <span class="monoText">name.capitalize()</span>.</p>
				<p>As before, we create the <span class="monoText">greet.html</span> file in the <span class="monoText">bang</span> folder inside the <span class="monoText">templates</span> folder. Then, inside the <span class="monoText">greet.html</span> file, we include the variable name surrounded by double curly braces &mdash; <span class="monoText">{{ name }}</span>.</p>
				<p>Now if we run <span class="monoText">127.0.0.1:8000/bang/daniel</span>, we see a large <span class="monoText">h1</span> element containing <span class="monoText">Hello, Daniel!</span>.</p>
			</section>

			<section id="sql_models_and_migrations">
				<h3>SQL, Models, and Migrations</h3>
				<p>Our biggest limitation thus far is we do not have the ability to <span class="italicsText">store</span> data. To do so, we need a <span class="term">database</span>. SQL is a database language that we can use to interact with databases. Django serves as an abstraction layer on top of SQL &mdash; it does not directly write SQL queries, but by interacting with Python classes and objects called <span class="term">models</span>. We can then use the technique of <span class="term">migrations</span> to update the SQL database in response to changes made in the Django models.</p>

				<p><span class="topic">SQL.</span> SQL is a language for <span class="term">relational databases</span>. Roughly speaking, relational databases organize data in the form of a table. Each column in the table keeps track of a particular piece of data. For example:</p>
				<figure class="table">
					<table class="truth_table">
						<thead>
							<th>student</th>
							<th>major</th>
						</thead>
						<tbody>
							<tr>
								<td>Greg Johnson</td>
								<td>mathematics</td>
							</tr>
							<tr>
								<td>Kento Fukiyama</td>
								<td>physics</td>
							</tr>
							<tr>
								<td>Elaine Wentworth</td>
								<td>linguistics</td>
							</tr>
						</tbody>
					</table>
				</figure>
				<p>The database management system we will use is SQLite. As a programming language, SQLite has several primitive types: <span class="monoText">TEXT</span>, <span class="monoText">NUMERIC</span>, <span class="monoText">INTEGER</span>, <span class="monoText">REAL</span>, and <span class="monoText">BLOB</span>. The <span class="monoText">NUMERIC</span> data type is a broad data type that covers anything that can be represented as a number (e.g., Boolean values). The <span class="monoText">BLOB</span> data type stands for &#8220;binary large object.&#8221; A <span class="monoText">BLOB</span> is a representation of a large piece of binary data (e.g., files, images, etc.).</p>
				<p>Here is a simple SQL table:</p>
				<pre class="language-bash"><code>
					CREATE TABLE flights (
						id INTEGER PRIMARY KEY AUTOINCREMENT,
						origin TEXT NOT NULL,
						destination TEXT NOT NULL,
						duration INTEGER NOT NULL
					)
				</code></pre>
				<p>The <span class="monoText">CREATE TABLE</span> symbol creates a new table, followed by its name, <span class="monoText">flights</span>. Inside the parentheses, we have a comma-separated list of all the table's columns. The <span class="monoText">id</span> column represents the piece of data's unique identifier for reference. Following the column's name are the data types.</p>
				<p>To insert a new row, we would write the following:</p>
				<pre class="language-bash"><code>
					INSERT INTO flights
						(origin, destination, duration)
						VALUES ("New York", "London", 415);
				</code></pre>
				<p>To target data in the table, we run a <span class="term">query</span>. For example, running:</p>
				<pre class="language-bash"><code>
					SELECT * FROM flights
				</code></pre>
				<p>will target all the data in the table. If we instead ran:</p>
				<pre class="language-bash"><code>
					SELECT origin, destination FROM flights;
				</code></pre>
				<p>we select all the cells in the columns <span class="monoText">origin</span> and <span class="monoText">destination</span>. What if we want to just target certain rows? If we wanted to target just the third row:</p>
				<pre class="language-bash"><code>
					SELECT * FROM flights WHERE id = 3;
				</code></pre>
				<p>What might this evaluate to:</p>
				<pre class="language-bash"><code>
					SELECT * FROM flights WHERE origin = "New York";
				</code></pre>
				<p>This will select all the flights where the origin is New York.</p>
			</section>
		</article>
	</main>
	<!-- Scripts -->
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js " integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
		<script>
			document.addEventListener("DOMContentLoaded", function () {
				renderMathInElement(document.body, {
					// customised options
					// • auto-render specific keys, e.g.:
					delimiters: [
						{ left: "$$", right: "$$", display: true },
						{ left: "$", right: "$", display: false },
						{ left: "\\(", right: "\\)", display: false },
						{ left: "\\[", right: "\\]", display: true },
					],
					// • rendering keys, e.g.:
					throwOnError: false,
				});
			});
		</script>
		<!-- <script src="https://unpkg.com/function-plot@1.22.2/dist/function-plot.js"></script> -->
		<script src="js/csfoundations.js"></script>
		<script src="js/prism.js"></script>
</body>
</html>
