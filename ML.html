<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>csf_ML</title>
	<!-- <base href="http://127.0.0.1:5500/csfoundations/" /> -->
	<link rel="stylesheet" href="css/csfoundations.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous" />
</head>

<body>
<header>
	<h1>Computer Science Fundamentals</h1>
</header>

<main>

<nav class="section-nav">
	<ul>
		<li><a href="#ML_intro">Introduction</a></li>
		<li><a href="#comments">Comments</a></li>
		<li><a href="#simple_data">Simple Data</a></li>
		<li><a href="#expressions_and_variable_bindings">Expressions &amp; Variable Bindings</a></li>
		<li><a href="#variable_immutability">Variable Immutability</a></li>
		<li><a href="#logical_operators">Logical Operators</a></li>
		<li><a href="#function">Functions</a></li>
		<li><a href="#pairs">Pairs</a></li>
		<li><a href="#tuples">Tuples &amp; Lists</a></li>
		<li><a href="#errors">Errors</a></li>
		<li><a href="#custom_data_types">Custom Data Types</a></li>
		<li><a href="#product_types">Sum Types</a></li>
		<li><a href="#sum_types">Product Types</a></li>
		<li><a href="#recursive_types">Recursive Types</a></li>
	</ul>
</nav>

	<article id="ML_programming" class="grid" data-colcade="columns: .grid-col, items: grid-item">

<section id="ML_intro" class="grid-item">
	<h2>Programming Languages</h2>
	<p>The following materials explore programming languages through <span class="monoText">ML</span> (&#8220;Meta Language&#8221;), <span class="monoText">Racket</span> (broadly referred to as <span class="monoText">Lisp</span>), and <span class="monoText">Ruby</span>. These languages all provide different programming paradigms, which these materials aim to present.</p>
</section>

<section id="comments">
	<p><span class="topic">Comments.</span> Because comments will be used extensively in the code examples, we cover their syntax first. Comments in <span class="monoText">ML</span> are written as such:</p>

	<pre class="language-sml"><code>
		(* This is a comment. *)
	</code></pre>
</section>

<section id="simple_data" class="grid-item">
	<h3>Simple Data</h3>
	<p><span class="topic">Basic Data Types.</span> <span class="monoText">ML</span> has the following data types:</p>

	<figure class="table">
		<table class="truth_table heading_center">
			<thead>
				<th>Type</th>
				<th>Values</th>
				<th>Comment</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="blueText">unit</span></td>
					<td>()</td>
					<td>a trivial data type with a single value.</td>
				</tr>
				<tr>
					<td><span class="blueText">bool</span></td>
					<td>true, false</td>
					<td></td>
				</tr>
				<tr>
					<td><span class="blueText">int</span></td>
					<td>0, 1, 179, ~5</td>
					<td>integer values</td>
				</tr>
				<tr>
					<td><span class="blueText">real</span></td>
					<td>0.0, 3.14, ~2.24</td>
					<td>equivalent of floats in other languages; rational numbers</td>
				</tr>
				<tr>
					<td><span class="blueText">char</span></td>
					<td>#"a", #newline</td>
					<td>characters</td>
				</tr>
				<tr>
					<td><span class="blueText">string</span></td>
					<td>"foo", "", " ", "hello world"</td>
					<td>this is NOT the same as a list of characters</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="expressions_and_variable_bindings">
	<p><span class="topic">Expressions &amp; Variable Bindings.</span> Before we study <span class="monoText">ML</span>, we must first understand its foundational terminology and concepts. In <span class="monoText">ML</span>, a program is a sequence of <span class="term">bindings</span>. Each <span class="term">binding</span> has a <span class="term">type</span>, which is checked. If it the binding passes its type-check, then it is <span class="term">evaluated</span>.</p>

	<p>A binding's type depends on its <span class="term">static environment</span> &mdash; roughly, the <span class="italicsText">types</span> of the preceding bindings. How a binding is evaluated depends on its <span class="term">dynamic environment</span> &mdash; roughly, the <span class="italicsText">values</span> of the preceding bindings. The term <span class="term">environment</span> usually refers to the dynamic environment, and the term <span class="term">context</span> usually refers to the static environment. The following are some common expressions in <span class="monoText">ML</span>:</p>

	<figure class="table">
		<table class="truth_table heading_center">
			<thead>
				<th>Expression</th>
				<th>Type</th>
				<th>Result Type</th>
				<th>Comments</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">if ${c}$ then ${e_1}$ else ${e_2}$</span></td>
					<td>${b}$ must be an expression of type <span class="boldText">bool</span>. ${e_1}$ and ${e_2}$ must have the same types.</td>
					<td>same as ${e_1}$ and ${e_2}$</td>
					<td></td>
				</tr>
				<tr>
					<td>${e_1}$ andalso ${e_2}$</td>
					<td>${e_1}$ and ${e_2}$ must both be of type <span class="boldText">bool</span></td>
					<td><span class="boldText">bool</span></td>
					<td>logical AND</td>
				</tr>
				<tr>
					<td>${e_1}$ orelse ${e_2}$</td>
					<td>${e_1}$ and ${e_2}$ must both be of type <span class="boldText">bool</span></td>
					<td><span class="boldText">bool</span></td>
					<td>logical OR</td>
				</tr>
				<tr>
					<td>NOT ${e}$</td>
					<td>${e}$ must be of type <span class="boldText">bool</span></td>
					<td><span class="boldText">bool</span></td>
					<td>logical NOT</td>
				</tr>
				<tr>
					<td>${e_1}$ + ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td>Same as ${e_1}$ and ${e_2}$</td>
					<td>${e_1 + e_2}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ - ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td>Same as ${e_1}$ and ${e_2}$</td>
					<td>${e_1 - e_2}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$/${e_2}$</td>
					<td>Both ${e_1}$ and ${e_2}$ must both be <span class="boldText">real</span></td>
					<td><span class="boldText">real</span></td>
					<td>real division</td>
				</tr>
				<tr>
					<td>${e_1}$ div ${e_2}$</td>
					<td>Both ${e_1}$ and ${e_2}$ must both be <span class="boldText">int</span></td>
					<td><span class="boldText">int</span></td>
					<td>integer division</td>
				</tr>
				<tr>
					<td>${e_1}$ * ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td>Same as ${e_1}$ and ${e_2}$</td>
					<td>${e_1 \cdot e_2}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ < ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 < e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ > ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 > e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ <= ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 \leq e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ >= ${e_2}$</td>
					<td>Either: (1) Both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">int</span>; or (2) both ${e_1}$ and ${e_2}$ are both of type <span class="boldText">real</span></td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 \geq e_2?}$; overload operator</td>
				</tr>
				<tr>
					<td>${e_1}$ = ${e_2}$</td>
					<td>${e_1}$ and ${e_2}$ must both be either <span class="boldText">unit</span>, <span class="boldText">int</span>, <span class="boldText">char</span>, or <span class="boldText">string</span>. <span class="underlineText">Cannot</span> be <span class="boldText">real</span>.</td>
					<td><span class="boldText">bool</span></td>
					<td>${e_1 = e_2?}$</td>
				</tr>
				<tr>
					<td>${e_1}$^${e_2}$</td>
					<td>${e_1}$ and ${e_2}$ must both be <span class="boldText">string</span></td>
					<td><span class="boldText">string</span></td>
					<td>concatenation</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>There are many kinds of bindings in <span class="monoText">ML</span>, but the simplest binding is the <span class="term">variable binding</span>. It takes the general form:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>val ${v}$ = ${e}$</li>
		</ul>
	</figure>

	<p>In the syntax above, <span class="monoText">val</span> is a <span class="italicsText">keyword</span>, ${v}$ is the <span class="italicsText">variable</span>, and ${e}$ is any <span class="italicsText">expression</span>. The semicolon is optional, but it is necessary in a <span class="term">REPL</span> (<span class="italicsText">read-eval-print</span> loop) to inform the <span class="italicsText">interpreter</span> that the binding is complete.</p>

	<p>Every binding in <span class="monoText">ML</span> has a <span class="term">scope</span>, which we can think of as &#8220;where it can be used.&#8221;</p>

	<p>The example above tells us the <span class="italicsText">syntax</span> for a variable binding (how to write it), but it does not tell us the <span class="italicsText">semantics</span> (how the binding is type-checked and evaluated; its <span class="italicsText">meaning</span>). The semantics of a variable binding are largely determined by the <span class="monoText">⟨expression⟩</span>.</p>

	<p>To type check the variable binding, the interpreter uses the <span class="italicsText">current static environment</span> (the types of preceding bindings) to type check the <span class="monoText">⟨expression⟩</span>. Once the <span class="monoText">⟨expression⟩</span> is type-checked, the interpreter produces a <span class="italicsText">new static environment</span> where the <span class="monoText">⟨variable⟩</span> has the type of the the <span class="monoText">⟨expression⟩</span>.</p>

	<p>To evaluate the variable binding, the interpreter uses the <span class="italicsText">current dynamic environment</span> (the <span class="italicsText">values</span> of the preceding bindings) to evaluate the <span class="monoText">⟨expression⟩</span>. Once the <span class="monoText">⟨expression⟩</span> is evaluated, the interpreter produces a <span class="italicsText">new dynamic environment</span> where the current dynamic environment now includes <span class="monoText">⟨variable⟩</span> with the value of the <span class="monoText">⟨expression⟩</span>'s evaluation.</p>

	<p>What is a <span class="term">value</span>? A <span class="italicsText">value</span> is an expression that cannot be further simplified &mdash; i.e., there is no more work to be done. For example, <span class="monoText">10</span> is a value, but <span class="monoText">5 + 5</span> is not. Both <span class="monoText">10</span> and <span class="monoText">5 + 5</span>, however, are <span class="italicsText">expressions</span>. In <span class="monoText">ML</span>, all values are expressions, but not all expressions are values. From the facts above, we have different <span class="italicsText">kinds of expressions</span>. These kinds are defined as such.</p>

	<figure class="table">
		<table class="truth_table heading_center">
			<thead>
				<th>Kind of Expression</th>
				<th>Syntax</th>
				<th>Type-checking</th>
				<th>Evaluation</th>
			</thead>
			<tbody>
				<tr>
					<td>integer constant</td>
					<td>a sequence of digits</td>
					<td>type <span class="redText">int</span> in any static environment</td>
					<td>to itself in any dynamic environment (it is a value)</td>
				</tr>
				<tr>
					<td>addition</td>
					<td><span class="redText">${a}$ + ${b}$</span> where ${a}$ and ${b}$ are expressions</td>
					<td>type <span class="redText">int</span> if and only if ${a}$ and ${b}$ have type <span class="redText">int</span> in the same static environment; else does not type-check</td>
					<td>evaluate ${a}$ to ${v}$ and ${b}$ to ${w}$ in the same static environment, where ${v}$ and ${w}$ are values; then produce the sum of ${v}$ and ${w}$</td>
				</tr>
				<tr>
					<td>variables</td>
					<td>a sequence of letters, underscores, etc.</td>
					<td>look up the variable in the current static environment and use that type</td>
					<td>look up the variable in the current dynamic environment and use that type</td>
				</tr>
				<tr>
					<td>conditionals</td>
					<td><span class="redText">if ${a}$ then ${b}$ else ${c}$</span> where ${a,}$ ${b,}$ and ${c}$ are expressions.</td>
					<td>type-checks only if (1) ${a}$ has type <span class="monoText">bool</span>, and (2) ${b}$ and ${c}$ have the same type. The type of the whole expression is the type of ${b}$ and ${c.}$</td>
					<td>using the current dynamic environment, evaluate ${a.}$ If the result is <span class="redText">true</span>, the result of ${b}$ is the overall result. If the result is <span class="redText">false</span>, then the result of ${c}$ is the overall result.</td>
				</tr>
				<tr>
					<td>boolean constants</td>
					<td>either <span class="redText">true</span> or <span class="redText">false</span></td>
					<td>type <span class="redText">bool</span> in any static environment.</td>
					<td>to itself in any dynamic environment (it is a value)</td>
				</tr>
				<tr>
					<td>comparison</td>
					<td><span class="redText">${a}$ < ${b}$</span> where ${a}$ and ${b}$ are expressions</td>
					<td>type <span class="redText">bool</span> if and only if ${a}$ and ${b}$ have type <span class="redText">int</span> in the same static environment; else does not type-check</td>
					<td>in the same dynamic environment, evaluate ${a}$ to ${v}$ and ${b}$ to ${w}$ where ${v}$ and ${w}$ are values; produce <span class="redText">true</span> if ${v}$ is less than ${w,}$ otherwise <span class="redText">false</span>.</td>
				</tr>
			</tbody>
		</table>
		<p>Whenever we learn a new construct in a programming language, there are three things we must seek out and ingrain in memory:</p>
		<ol>
			<li>What is the construct's syntax?</li>
			<li>What is the rule for type-checking the construct?</li>
			<li>What is the rule for evaluating the construct?</li>
		</ol>
	</figure>
</section>

<section id="variable_immutability">
	<p><span class="topic">Variable Immutability.</span> In <span class="monoText">ML</span>, bindings are <span class="underlineText">immutable</span>. This is in stark contrast to languages like <span class="monoText">Java</span>, <span class="monoText">Python</span>, and <span class="monoText">JavaScript</span>. Once we write:</p>
	
	<pre class="language-sml"><code>
		val x = 8+9;
	</code></pre>

	<p>we create a dynamic environment where <span class="monoText">x</span> maps to <span class="monoText">17</span>. In this new dynamic environment, <span class="monoText">x</span> <span class="underlineText">will always</span> map to <span class="monoText">17</span>. Unlike languages like Java, there is no <span class="italicsText">assignment statement</span> to change what <span class="monoText">x</span> maps to.</p>

	<p>Now, we are free to later write:</p>

	<pre class="language-sml"><code>
		val x = 20;
	</code></pre>

	<p>but all this does is create a <span class="italicsText">different dynamic environment</span> where <span class="monoText">x = 20</span> <span class="term">shadows</span> <span class="monoText">x = 8+9</span>.</p>
</section>

<section id="logical_operators">
	<p><span class="topic">Logical Operators.</span> Like all useful programming languages, <span class="monoText">ML</span> provides constructs for Boolean expressions:</p>
	<figure class="table">
		<table class="truth_table heading_center">
			<thead>
				<th>operator</th>
				<th>semantics</th>
			</thead>
			<tbody>
				<tr>
					<td><span class="monoText">${e_1}$ <span class="blueText">andalso</span> ${e_2}$</span></td>
					<td>The logical AND. Evaluates ${e_2}$ only if ${e_1}$ evaluates to <span class="greenText">true</span>. If both ${e_1}$ and ${e_2}$ evaluate to <span class="greenText">true</span>, then the entire expression is <span class="redText">true</span>. Otherwise, <span class="redText">false</span>. Both ${e_1}$ and ${e_2}$ must be of type <span class="boldText">bool</span>.</td>
				</tr>
				<tr>
					<td><span class="monoText">${e_1}$ <span class="blueText">orelse</span> ${e_2}$</span></td>
					<td>The logical OR. Evaluates ${e_2}$ only if ${e_1}$ evaluates to <span class="redText">false</span>. If ${e_1}$ evaluates to <span class="greenText">true</span> or ${e_2}$ evaluates to <span class="greenText">true</span>, then the entire expression evaluates to <span class="greenText">true</span>. If both ${e_1}$ and ${e_2}$ evaluate to <span class="redText">false</span>, then the entire expression evaluates to <span class="redText">false</span>. Both ${e_1}$ and ${e_2}$ must be of type <span class="boldText">bool</span>.</td>
				</tr>
				<tr>
					<td><span class="monoText"><span class="blueText">not</span> ${e}$</span></td>
					<td>The logical NOT. ${e}$ must be of type <span class="boldText">bool</span>. If ${e}$ is <span class="greenText">true</span>, then <span class="blueText">not ${e}$</span> evaluates to <span class="redText">false</span>. If ${e}$ is <span class="redText">false</span>, then <span class="blueText">not ${e}$</span> evaluates to <span class="greenText">true</span>.</td>
				</tr>
				<tr>
					<td><span class="monoText">${e_1}$ = ${e_2}$</span></td>
					<td>The equality operator. Asks the question, "Is ${e_1}$ equal to ${e_2}$?"</td>
				</tr>
				<tr>
					<td><span class="monoText">${e_1}$ <> ${e_2}$</span></td>
					<td>Equivalent of ${e_1}$ != ${e_2}$ in other programming languages. Asks the question, "Are ${e_1}$ and ${e_2}$ different?" We can simply write <span class="blueText">NOT (${e_1}$ = ${e_2}$)</span>, but ML provides the <span class="boldText"><></span> operator for us to use (less than or greater than operator).</td>
				</tr>
				<tr>
					<td><span class="monoText"> >, <, >=, <= </span></td>
					<td>The usual comparison operators as found in other languages.</td>
				</tr>
				<tr>
					<td><span class="monoText">~${n}$</span></td>
					<td>Where ${n}$ is a numeric type value, the tilde ~ indicates the negative. E.g., ~7 is ${-7.}$</td>
				</tr>
			</tbody>
		</table>
	</figure>
</section>

<section id="function_bindings">
	<p><span class="topic">Functions.</span> To define and use functions in <span class="monoText">ML</span>, we create <span class="term">function bindings</span>. For those coming from a Python or Java background, functions in <span class="monoText">ML</span> work much the same way, with a few stark differences: (1) There is no notion of a <span class="italicsText">class</span>; (2) there is no notion of a <span class="monoText">return</span> statement. As an example, consider a function that computes ${x^y}$ iff ${y \geq 0:}$</p>

	<pre class="language-sml"><code>
		fun pow (x:int, y:int) = (* correct only for y >= 0 *)
			if y = 0
				then 1
			else x * pow(x,y-1)
	</code></pre>

	<p>The general syntax for a function in <span class="monoText">ML</span>:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>fun ${f}$ (${a_1}$ : ${t_1}$, ${\ldots}$, ${a_n}$ : ${t_n}$) =</li>
			<ul>
				<li>${e_1}$</li>
				<li>${\vdots}$</li>
				<li>${e_n}$</li>
			</ul>
		</ul>
	</figure>

	<p>In the syntax above the definition is prefaced by the keyword <span class="monoText">fun</span>. ${f}$ is the function's name. It takes arguments ${a_1 \ldots a_n}$ of types ${t_1 \ldots t_n}$. The function's body is defined by the expressions ${e_1 \ldots e_n}$.</p>

	<p><span class="topic">Function Type-checking.</span> To type check a function, the interpreter type-checks the function's body, <span class="monoText">⟨expressions⟩</span>, in a static environment, consisting of (1) all the earlier bindings and (2) <span class="monoText">arg-1</span> mapped to <span class="monoText">type-1</span> ... <span class="monoText">arg-n</span> mapped to <span class="monoText">type-n</span>. Because the static environment also includes <span class="monoText">⟨function-name⟩</span>, the function's body <span class="monoText">⟨expressions⟩</span> can include a call to <span class="monoText">⟨function-name⟩</span> (i.e., a <span class="italicsText">recursive function call</span>).</p>

	<p><span class="topic">Evaluating Functions.</span> A function is a value; we are merely adding <span class="monoText">⟨function-name⟩</span> to be called later. Thus, <span class="monoText">⟨function-name⟩</span> is included in the dynamic environment in the function body and for subsequent bindings. However, <span class="monoText">⟨function-name⟩</span> <span class="underlineText">is not</span> included in the preceding bindings, so the order in which functions are defined is critical (i.e., the interpreter cannot &#8220;jump forward&#8221; to a function definition later down the program to evaluate the current expression).</p>

	<p><span class="topic">Function Calls.</span> Function bindings are only useful if we can <span class="italicsText">call</span> them. To do so, we write a <span class="term">function call</span>. The syntax:</p>

	<figure class="math-display">
		$$
			f \space (a_1, \ldots, a_n)
		$$
	</figure>

	<p>The parentheses are optional if there is exactly one argument:</p>

	<figure class="math-display">
		$$
			f \space a
		$$
	</figure>

	<p>Here is an example of a function call:</p>

	<pre class="language-sml"><code>
		fun pow (x:int, y:int) = (* correct only for y >= 0 *)
			if y=0
				then 1
			else x * pow(x, y-1)

		fun cube (x:int) =
			pow(x, 3)

		val ans = cube(4)
	</code></pre>
</section>

<section id="pairs">
	<h4>Pairs</h4>
	<p>As we already know, a good programming language provides ways of building compound data from simpler data. The simplest way of forming compound data in <span class="monoText">ML</span> is through <span class="term">pairs</span>. To build a pair, we use the following syntax:</p>

	<figure class="math-display">
		$$
			(e_1, e_2)
		$$
	</figure>

	<p>When a pair is built, ${e_1}$ is evaluated to ${v_1}$ and ${e_2}$ is evaluated to ${v_2}$. In doing so, the pair, as a whole, is evaluated to ${(v_1, v_2)}$, a value. Because a pair is evaluated to a value, a pair can consist of pairs:</p>

	<figure class="math-display">
		$$
			(P_1, P_2) \\ [1em]
			\darr \\[0.3em]
			(v_1, v_2) \\ [1em]
			\darr \\[0.3em]
			((e_1, e_2) (e_1, e_2))
		$$
	</figure>

	<p>The type of a pair is <span class="monoText">${t_1}$ * ${t_2}$</span> where ${t_1}$ is the type of the first part, ${v_1,}$ and ${t_2}$ is type of the second part, ${v_2.}$</p>

	<p>To access the values ${v_1}$ and ${v_2}$ in a pair, we must write a function. The following is a function that accesses and sums the parts of a pair:</p>

	<pre class="language-sml"><code>
		fun sum_two_pairs (pr1 : int*int, pr2 : int*int) =
			(#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2)
	</code></pre>

	<p>Notice how we access the parts with <span class="monoText">#1</span> and <span class="monoText">#2</span>. Here is another function that takes a pair to return an answer with two parts, a quotient, and a remainder:</p>

	<pre class="language-sml"><code>
		fun div_mod (x : int, y : int) = 
			(x div y, x mod y)
	</code></pre>

	<p>Here is another function that sorts a pair:</p>

	<pre class="language-sml"><code>
		fun sort_pair(pr : int*int) =
			if (#1 pr) < (#2 pr) 
				then pr
			else ((#2 pr), (#1 pr))
	</code></pre>
</section>

<section id="tuples">
	<h4>Tuples &amp; Lists</h4>
	<p>A pair is really a 2-tuple. <span class="monoText">ML</span> allows us to have ${n-\text{tuples}.}$ For example, a 3-tuple (a triple):</p>

	<pre class="language-sml"><code>
		(*
			a 3-tuple
			type: int*int*int
		*)
		(2, 4, 6)
	</code></pre>

	<p><span class="topic">Nesting Tuples.</span> Tuples are of fixed but <span class="term">arbtirary arity</span> &mdash; we can nest tuples however much we would like:</p>

	<pre class="language-sml"><code>
		(*
			Below is a 3-tuple containing a 2-tuple
			Type: int*(int*int)*int
		*)

		(2, (4, 6), 8) 

		(*
		Below is a 2-tuple containing a 2-tuple
		Type: int*(bool*int)
		*)

		(2, (true, 4))
	</code></pre>

	<p><span class="topic">Lists.</span> We can nest pairs as much as we would like, but it can be difficult to determine how many parts are in a pair, since the type determines the amount of data contained in a pair. To get around this difficulty, <span class="monoText">ML</span> provides <span class="term">lists</span>. A list containing ${n}$ values is initialized with the following syntax:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>[${v_1, v_2, \ldots, v_n}$]</li>
		</ul>
	</figure>

	<p>Note that unlike tuples, lists are <span class="term">homogeneous</span> &mdash; a list's members must all be of the same type.</p>

	<p>The <span class="italicsText">empty list</span>, <span class="monoText">[]</span>, is the list with 0 elements. However, while it does not have any elements, it is a value nevertheless, and it evaluates to itself immediately. With the empty list <span class="monoText">[]</span>, <span class="monoText">null</span> evaluates to true. For non-empty lists, <span class="monoText">null</span> evaluates to <span class="monoText">false</span>. Here are some useful operators for lists:</p>

	<figure class="table">
		<table class="truth_table">
			<thead>
				<th>Operator</th>
				<th>Semantics</th>
			</thead>
			<tbody>
				<tr>
					<td>null</td>
					<td>evaluates to <span class="redText">true</span> if the list is the empty list []; otherwise <span class="redText">false</span> for non-empty lists</td>
				</tr>
				<tr>
					<td>hd</td>
					<td>return the first element of the list; i.e., the <span class="boldText">head</span> of the list; if the list is empty, an <span class="boldText">exception</span> is raised</td>
				</tr>
				<tr>
					<td>t1</td>
					<td>return the list without the first element; i.e., the <span class="boldText">tail</span> of the list; if the list is empty, an exception is raised</td>
				</tr>
			</tbody>
		</table>
	</figure>

	<p>Here are some functions operating on lists:</p>

	<pre class="language-sml"><code>
		fun sum_list (x_list : int list) =
			if null x_list
				then 0
			else hd(x_list) + sum_list(t1 x_list)

		fun countdown (x : int) =
			if x=0
				then []
			else x :: countdown(x-1)

		fun append (x_list : int list, y_list : int list) =
			if null x_list
				then y_list
			else (hd x_list) :: append(t1 x_list, y_list)
	</code></pre>

	<p>Functions using lists are almost always recursive because a list has an unknown length. When writing recursive functions for lists, there are two things to determine:</p>

	<ol>
		<li>The base case: What should the result be for an empty list?</li>
		<li>The recursive case: How can the answer be expressed in terms of the answer for the rest of the list?</li>
	</ol>

	<p>Thinking of terms of recursion rather than loops and assignment statements can both simplify a problem considerably, as well as yield a greater understanding of the problem parameters.</p>

	<p><span class="topic"><span class="monoText">let</span> Expressions.</span> In <span class="monoText">ML</span>, the <span class="monoText">let</span> expression is what gives us <span class="italicsText">local bindings</span>, and as an expression, we can place it anywhere an expression may be placed. The <span class="monoText">let</span> expression takes the form:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>let ${b_1 \space b_2 \ldots b_n}$ in ${e}$ end</li>
		</ul>
	</figure>

	<p>Above: Each ${b}$ is a binding, ${e}$ is an expression, and the symbols <span class="monoText">let</span>, <span class="monoText">in</span>, and <span class="monoText">end</span> are keywords.</p>

	<p>To evaluate a <span class="monoText">let</span> expression, we evaluate each ${b}$ using all earlier bindings in evaluating the <span class="monoText">let</span> expression and create a larger environment for the subsequent bindings.</p>

	<p>Recall that every binding in <span class="monoText">ML</span> has a scope. For the <span class="monoText">let</span> expression, the scope of a binding contained therein is the later bindings in that <span class="monoText">let</span> expression, and the <span class="italicsText">body</span> of the <span class="monoText">let</span> expression &mdash; the expression ${exp.}$ The value of the entire <span class="monoText">let</span> expresion is the value of ${e.}$ Accordingly, the type of the entire <span class="monoText">let</span> expression is the type of the value of ${e.}$ Here is a simple <span class="monoText">let</span> expression:</p>

	<pre class="language-sml"><code>
		let val x = 1
		in
			(let val x = 2 in x+1 end) + (let val y = x+2 in y+1 end)
		end
	</code></pre>

	<p><span class="monoText">let</span> expressions in <span class="monoText">ML</span> are extremely handy with functions. For example, we can use a <span class="monoText">let</span> expression to bind a function, since a function is itself a binding. This leads to common design pattern:</p>

	<figure class="math-display">
		<div class="rule">
			<p><span class="topic">Convention.</span> If a <span class="italicsText">helper function</span> is needed by only one other function and is unlikely to be useful elsewhere, we ought to bind it locally to the parent function:</p>
		</div>
	</figure>

	<p>For example, here is a function that produces the list <span class="monoText">[1, 2, ..., ${x}$]</span>:</p>

	<pre class="language-sml"><code>
		fun countUp_from_1 (x:int) =
			let fun count (from:int, to:int) =
				if from=to
					then to :: []
				else from :: count(from+1, to)
			in
				count(1,x)
			end
	</code></pre>

	<p>How does the code above work? First, we defined a function called <span class="monoText">countUp_from_1()</span>. This function consumes an <span class="monoText">int</span> type value, stored in the <span class="monoText">int</span> type variable <span class="monoText">x</span>. Inside the body of <span class="monoText">countUp_from_1</span>, we execute the function <span class="monoText">count()</span>. The function <span class="monoText">count</span> is <span class="italicsText">local</span> to the function <span class="monoText">countUp_from_1()</span>. How? Because we defined it through a <span class="monoText">let</span> expression inside the body of <span class="monoText">countUp_from_1</span>.</p>

	<p>Now, <span class="monoText">count()</span> takes two arguments: (1) an <span class="monoText">int</span> type value stored in the <span class="monoText">int</span> type variable <span class="monoText">from</span>, and (2) an <span class="monoText">int</span> type value stored in the <span class="monoText">int</span> type variable <span class="monoText">to</span>. However, given that the function <span class="monoText">countUp_from_1()</span> calls the function <span class="monoText">count()</span> with the arguments <span class="monoText">1</span> and <span class="monoText">x</span>, the variable <span class="monoText">from</span> is bound to the value <span class="monoText">1</span>, and the variable <span class="monoText">to</span> is bound to whatever <span class="monoText">int</span> type value we passed as an argument into <span class="monoText">countUp_from_1()</span>.</p>

	<p>Inside <span class="monoText">count()</span>, we ask several questions. First, <span class="monoText">from=to</span>, which is, Is <span class="monoText">from</span> equal to <span class="monoText">?</span> If it is, then return the singleton list <span class="monoText">[to]</span>. If it not, then ask the second question, <span class="monoText">else</span>. The answer to <span class="monoText">else</span> is always <span class="monoText">true</span>, so we return a list starting with <span class="monoText">from</span> and ending with <span class="monoText">count(from+1, to)</span>. So, for example, <span class="monoText">countUp_from_1(5)</span>, where <span class="monoText">countUp_from_1</span> is ${f}$ and <span class="monoText">count</span> is ${c}$</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${f(5)}$</li>
			<li>${c(1, 5)}$</li>
			<li>${[1, c(2, 5)]}$</li>
			<li>${[1, 2, c(3, 5)]}$</li>
			<li>${[1, 2, 3, c(4, 5)]}$</li>
			<li>${[1, 2, 3, 4, c(5, 5)]}$</li>
			<li>${[1, 2, 3, 4, 5]}$</li>
		</ul>
	</figure>

	<p>Although the algorithm works, there is room for optimization. First, notice that <span class="monoText">count()</span>'s first parameter, <span class="monoText">from:int</span>, always has the value <span class="monoText">1</span>. Second, notice that <span class="monoText">count()</span>'s second parameter, <span class="monoText">to:int</span>, is always the value stored in <span class="monoText">countUp_from_1()</span>'s second parameter, <span class="monoText">x</span>. Can we use <span class="monoText">x</span>? Of course! Never forget the core rule of dynamic environments in <span class="monoText">ML</span>: To evaluate a binding, we use all of the preceding bindings. Accordingly, <span class="monoText">count()</span> is absolutely free to use <span class="monoText">x</span>. Thus, we can write the function more concisely:</p>

	<pre class="language-sml"><code>
		fun countUp_from_1 (x:int) = 
			let fun count (from:int) =
				if from = x
					then x::[]
				else from :: count(from+1)
			in
				count 1
			end
	</code></pre>
			
	<p>The optimization above demonstrates a common technique in functional programming:</p>

	<figure class="math-display">
		<div class="rule">
			<p><span class="topic">Convention.</span> In defining functions, reuse variables within the function's scope.</p>
		</div>
	</figure>

	<p>Be aware: The technique above is unique to functional programming languages. Unfortunately, many languages absolutely prohibit such practices. In functional programming &mdash; and programming in general &mdash; local variables should be preferred over <span class="italicsText">global variables</span>. For starts, locals make code easier to read rather than globals. For example, consider the following function that returns the maximum value in a list:</p>

	<pre class="language-sml"><code>
		fun max (x_list : int list) =
			if null x_list
				then 0
			else if null (t1 x_list) 
				then hd x_list
			else if hd x_list > max(t1 x_list)
				then hd x_list
			else max(t1 x_list)
	</code></pre>

	<p>The code above asks 4 different questions:</p>

	<figure class="math-display">
		<div class="rule">
			<ol>
				<li>Is <span class="monoText">x_list</span> the empty list?</li>
				<ul>
					<li>Yes ${\implies}$ evaluate to <span class="monoText">0</span>.</li>
					<li>No ${\implies}$ ask the next question.</li>
				</ul>
				<li>Is the tail of <span class="monoText">x_list</span> the empty list? (i.e., Is the list a singleton list?)</li>
				<ul>
					<li>Yes ${\implies}$ evaluate to the head of <span class="monoText">x_list</span>.</li>
					<li>No ${\implies}$ ask the next question.</li>
				</ul>
				<li>Is the head of <span class="monoText">x_list</span> greater than the maximum of the tail of the list?</li>
				<ul>
					<li>Yes ${\implies}$ evaluate to the head of <span class="monoText">x_list</span></li>
					<li>No ${\implies}$ ask the next question.</li>
				</ul>
				<li><span class="monoText">else</span>.</li>
				<ul>
					<li>evaluate to the maximum of the tail of the list.</li>
				</ul>
			</ol>
		</div>
	</figure>

	<p>What is the problem with this algorithm? The problem is we are calling <span class="monoText">max()</span> twice recursively. This is an example of a common recursive error, the <span class="term">exponential blowup</span> &mdash; <span class="monoText">max()</span> asks for <span class="monoText">max()</span> twice, and in both those <span class="monoText">max()</span> calls, <span class="monoText">max()</span> is asked twice (now 4 <span class="monoText">max()</span> calls), and in each of those 4 <span class="monoText">max()</span> calls, <span class="monoText">max()</span> is asked twice (now 16 <span class="monoText">max()</span> calls), etc. If we passed into <span class="monoText">max()</span> the value of <span class="monoText">countUp_from_1(100)</span>, we would execute ${2^{100}}$ calls.</p>

	<p><span class="monoText">let</span> expressions solve this problem: Compute the <span class="monoText">max</span> of the tail once, store that result in <span class="monoText">tail_max</span>, and use <span class="monoText">tail_max</span> as the comparison:</p>

	<pre class="language-sml"><code>
		fun max (x_list : int list) =
			if null x_list
				then 0
			else if null (t1 x_list)
				then hd x_list
			else
				let val tail_max = max(t1 x_list)
				in
					if hd x_list > tail_max
						then hd x_list
					else tail_max 
				end
	</code></pre>

	<p>With the code above, we go through the same first two questions, and if they are both <span class="monoText">false</span>, then we go through the <span class="monoText">else</span> question: First, bind the value of the max of the list's tail to the variable <span class="monoText">tail_max</span>. If the head of <span class="monoText">x_list</span> is greater than <span class="monoText">tail_max</span>, evaluate to the head of <span class="monoText">x_list</span>. Otherwise, evaluate to <span class="monoText">tail_max</span>. So, for example, suppose we wrote <span class="monoText">max([1, 2, 3, 4, 5])</span>. Where <span class="monoText">max()</span> is ${M,}$ <span class="monoText">hd</span> is ${h}$, <span class="monoText">t1</span> is ${t,}$ ${\ell}$ is <span class="monoText">[1, 2, 3, 4, 5]</span>, and ${v}$ is <span class="monoText">tail_max</span>:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>${M(\ell)}$</li>
			<li>${M([1, 2, 3, 4, 5])}$</li>
			<li>${h(\ell) > v}$</li>
			<li>${h(\ell) > M(t(\ell))}$</li>
			<li>${1 > M([2, 3, 4, 5])}$</li>
			<li>${1 > (h(\ell) > v)}$</li>
			<li>${1 > (h(\ell) > M(t(\ell)))}$</li>
			<li>${1 > (2 > M([3, 4, 5]))}$</li>
			<li>${1 > (2 > (3 > v))}$</li>
			<li>${1 > (2 > (3 > M(t(\ell))))}$</li>
			<li>${1 > (2 > (3 > M[4, 5]))}$</li>
			<li>${1 > (2 > (3 > (4 > v)))}$</li>
			<li>${1 > (2 > (3 > (4 > M(t(\ell)))))}$</li>
			<li>${1 > (2 > (3 > (4 > M([5]))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > v))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > M(t(\ell))))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > M([])))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5 > 0))))}$</li>
			<li>${1 > (2 > (3 > (4 > (5))))}$</li>
			<li>${1 > (2 > (3 > (5)))}$</li>
			<li>${1 > (2 > (5))}$</li>
			<li>${1 > (5)}$</li>
			<li>${5}$</li>
		</ul>
	</figure>

	<p><span class="topic">Options.</span> There is a small problem with the algorithm above. The answer to the first question, <span class="monoText">null x_list</span> is <span class="monoText">0</span>. But this isn't logically correct. The maximum value of an empty list isn't zero, because there are no values in an empty list to compare with in the first place. We should avoid making such illogical statements. So what can we do? We could raise an exception. However, a better way would be to use an <span class="monoText">option</span>. In <span class="monoText">ML</span>, an <span class="monoText">option</span> is a data type with only one of two values: <span class="monoText">NONE</span> or <span class="monoText">SOME</span>. The <span class="monoText">option</span> value <span class="monoText">NONE</span> represents <span class="italicsText">nothingness</span>, or &#8220;carries nothing.&#8221; The <span class="monoText">option</span> value <span class="monoText">SOME ${e}$</span>, where ${e}$ is an expression, represents <span class="italicsText">existence</span>, or &#8220;carries something.&#8221; More specifically, the value <span class="monoText">SOME ${e}$</span> will evaluate ${e}$ to a value ${v,}$ at which point <span class="monoText">SOME ${e}$</span> becomes the option carrying the one and only value ${v.}$</p>
	
	<p>Like <span class="monoText">null</span>, we can ask whether a value is <span class="monoText">SOME ${e}$</span> or <span class="monoText">NONE</span>. The operator <span class="monoText">isSome</span> evaluates to <span class="monoText">false</span> if its argument is <span class="monoText">NONE</span>. And if we want to access the value carried by a <span class="monoText">SOME</span>, we use the operator <span class="monoText">valOf</span>. Using options, we can rewrite the code above as such:</p>

	<pre class="language-sml"><code>
		fun max (x_list : int list) =
			if null x_list
				then NONE
			else
				let val tail_max = max(t1 x_list)
				in
					if isSome tail_max andalso valOf tail_max > hd x_list
						then tail_max
					else
						SOME (hd x_list)
				end
	</code></pre>
</section>

<section id="errors">
	<h3>Errors</h3>
	<p>Errors in <span class="monoText">ML</span> fall into three groups: (1) <span class="italicsText">syntax errors</span>, (2) <span class="italicsText">type errors</span>, and (3) <span class="italicsText">runtime errors</span>.</p>
	<p><span class="term">Syntax errors</span> are errors caused by writing something incorrectly. Incorrect meaning we have written something in violation of <span class="monoText">ML</span>'s syntax.</p>
	<p><span class="term">Type errors</span> are errors caused by failing to pass a type check. These errors occur when we fail to follow the type checking rules; e.g., adding an <span class="monoText">int</span> type variable to a <span class="monoText">bool</span> type variable.</p>
	<p><span class="term">Runtime errors</span> are errors that occur during evaluation. This might be because we used an operator incorrectly, or because we wrote a recursive function that <span class="italicsText">bottoms out</span> &mdash; making too many recursive calls such that the program terminates.</p>
	<p><span class="topic">Logic errors.</span> Errors that are not caught by <span class="monoText">ML</span> can be broadly classified as <span class="term">logic errors</span>. Here, we complied with syntax and semantics, so we do not see any syntax, type, or runtime errors, but our program does something outside of our expections. Perhaps it hangs (enters an infinite loop), returns an unexpected value, or returns an expected value but not in the way we intended.</p>
	<p>The errors above all occur in sequence. In other words, in order of occurrence, we will see syntax errors, then type errors, then runtime errors last. This means that if we see a runtime error, then we did not have a syntax or type error, but if we see a syntax error, we do not know if there is a type or runtime error, at least not yet.</p>
</section>

<section id="custom_data_types">
	<h3>Composite Data Types</h3>

	<p>Data types in programming languages fall into two categories: (1) <span class="term">base types</span>, and (2) <span class="term">composite types</span>. We avoid using the term <span class="italicsText">primitive types</span> for base types because the word <span class="italicsText">primitive type</span> connotes a type that cannot be modified, which is not necessarily true of all languages (Swift, for example, allows its base types provided by the standard library to be extended). A language's base types are the types the language provides by default. In ML, these types include <span class="monoText">int</span>, <span class="monoText">bool</span>, <span class="monoText">real</span>, <span class="monoText">unit</span>, etc. In contrast, composite types are data types that contain other types in their definition. The data types <span class="monoText">tuple</span>, <span class="monoText">list</span>, and <span class="monoText">option</span> are all examples of a compound data type. More specifically, these are a kind of compound data type called an <span class="term">algebraic data type</span>.</p>

	<p>In ML and most other languages, there are three building blocks to constructing a composite type: (1) an <span class="term">each-of</span> type (more formally, <span class="term">product types</span>); (2) a <span class="term">one-of</span> type (formally a <span class="term">sum type</span>); and (3) a <span class="term">self-reference</span> type (a <span class="term">recursive type</span>). We go over each of these in turn.</p>
</section>

<section id="product_types">
	<h4>Product Types</h4>
	<p>A product type describes the values containing <span class="italicsText">each of</span> the values of type ${t_1, t_2, \ldots, \textit{ and } \space t_n.}$ Tuples are the most obvious example of product type data. A tuple such as <span class="monoText">(1, true)</span> is of type <span class="monoText">int*bool</span>. The tuple describes the values containing an <span class="monoText">int</span> <span class="underlineText">and</span> a <span class="monoText">bool</span>.</p>
	<p><span class="topic">Record Types.</span> One way to create a product type is through a <span class="term">record type</span>. In a record type, each component has a <span class="term">named field</span>. For example:</p>

	<figure class="math-display">
		<pre class="language-pseudo"><code>
			{ index : int, name : string, attended : bool}
		</code></pre>
	</figure>

	<p>Here, we have three fields: <span class="monoText">index</span>, <span class="monoText">name</span>, and <span class="monoText">attended</span>. We call the expression above a <span class="term">record expression</span>, and it evaluates to a <span class="term">record value</span>. The general syntax for a record expression:</p>

	<figure class="math-display">
		<ul class="syntax"><li>{ ${f_1}$ = ${e_1}$, ${\ldots}$, ${f_n}$ = ${e_n}$ }</li></ul>
		<ul class="def">
			<li class="where"> ${f_1 \ldots f_n}$ are <span class="italicsText">unique</span> field names, and</li>
			<li>${e_1 \ldots e_n}$ are expressions</li>
		</ul>
	</figure>

	<p>Astute observation reveals how closely a record resembles a tuple. In fact, tuples <span class="italicsText">are</span> records. Specifically, they are records with numeric field names to indicate <span class="italicsText">position</span>. For example, to access a record with a field name <span class="monoText">age</span>, we would reference the field name <span class="monoText">age</span> to access the value stored in that field name. In contrast, we access a particular value in a tuple by referencing that value's position &mdash; e.g., <span class="monoText">(#1 myTuple)</span> to access the value in position 1. Why not just use records? Because tuples are such a common data structure that we provide it a syntax of its own; a form of <span class="term">syntactic sugar</span>.</p>
</section>

<section id="sum_types">
	<h4>Sum Types</h4>
	<p>A sum type describes the values containing a value of <span class="italicsText">one of</span> the types ${t_1, t_2, \ldots, \textit{ or } \space  t_n.}$ An example of sum type data is <span class="monoText">int option</span>. Here, the data type either contains an <span class="monoText">int</span> <span class="underlineText">or</span> it does not. Functional languages like ML tend to handle sum types succinctly, at least as compared to object-oriented languages like Java, where sub-classing is almost always required.</p>

	<p><span class="topic">Datatype Bindings.</span> To create custom product types, we create <span class="italicsText">datatype bindings</span>. For example:</p>
	<pre class="language-sml"><code>
		dataType fooType = TwoInts of int * int
										 | Str of string
										 | xyz
	</code></pre>
	<p>This data type defines a new type whose values have one of three types: (1) <span class="monoText">int*int</span>, (2) <span class="monoText">string</span>, or (3) nothing. These three values determine what <span class="term">variant</span> of the data type the value is (e.g., is it an <span class="monoText">int*int</span>, a <span class="monoText">string</span>, or nothing). These &#8220;tags&#8221; are called <span class="term">constructors</span>.</p>
	<p>When we include the constructor above, we insert four new entities to the environment: (1) a new type called <span class="monoText">fooType</span> to be used like any other type; (2) a constructor <span class="monoText">TwoInts</span>; (3) a constructor <span class="monoText">Str</span>; and (4) a constructor <span class="monoText">xyz</span>.</p>

	<p><span class="topic">Accessing Data in a Datatype Binding.</span> To access data in a datatype binding, we must determine what variant the binding is. To do so, we use a <span class="term">case expression</span>:</p>

	<pre class="language-sml"><code>
		fun f x = (* f has type fooType --> int *)
			case x of
				xyz => 3
			| TwoInts(i1, i2) => i1 + i2
			| Str s => String.size s
	</code></pre>

	<p>In the case expression above, <span class="monoText">x</span> is evaluated first. Then, the expression of which branch <span class="italicsText">first matches</span>. Here, we have three branches: (1) <span class="monoText">x</span> is an <span class="monoText">xyz</span>, (2) <span class="monoText">x</span> is a <span class="monoText">TwoInts(i1, i2)</span>, or (3) <span class="monoText">x</span> is an <span class="monoText">Str</span>. We can see that each branch in the case expression takes the form:</p>
	<figure class="math-display">
		<ul class="syntax"><li>${p}$ => ${\textit{exp}}$</li></ul>
	</figure>
	<p>Where ${p}$ is a pattern, and ${\textit{exp}}$ is an expression. A more general syntax:</p>
	<figure class="math-display">
		<ul class="syntax">
			<li>fun ${f}$ ${x}$ =</li>
			<ul>
				<li>case ${x}$ of</li>
				<ul>
					<li>${p_0}$ => ${exp_0}$</li>
					<li>| ${p_1}$ => ${exp_1}$</li>
					<li>| ${p_2}$ => ${exp_2}$</li>
					<li>| ${\vdots}$</li>
					<li>| ${p_n}$ => ${exp_n}$</li>
				</ul>
			</ul>
		</ul>
	</figure>
	<p>Patterns are the construct used to <span class="underlineText">match</span> against the result of evaluating the case's first expression (in the syntax above, <span class="monoText">${p_0}$ => ${exp_0}$</span>.) This form of evaluation has a specific name &mdash; <span class="term">pattern-matching</span>.</p>
	<p>Importantly, case expressions are <span class="term">first-match</span>, meaning that the moment there is a <span class="italicsText">pattern match</span>, the entire expression evaluates to that pattern match's expression. ML will not continue to check the remaining branches.</p>

	<p><span class="topic">Enumerations.</span> An enumeration, or <span class="term">an enumerated type</span>, are one kind of sum type. In object-oriented languages, they are often called <span class="monoText">enum</span>s (&#8220;eh-nooms&#8221;), and in R, it is called a <span class="monoText">factor</span>. In formal mathematics and statistics, they are broadly referred to as <span class="italicsText">categorical variables</span>. Some examples: U.S. currency has many different enumerations: penny, nickel, quarter, half-dollar, one-dollar, five-dollar, ten-dollar, twenty-dollar, fifty-dollar, a hundred-dollar. Traffic lights in North America have three enumerations: red, yellow, green. Here is another example in ML code:</p>

	<pre class="language-sml"><code>
		datatype suit = Club | Diamond | Heart | Spade
	</code></pre>

	<p>Regardless of what variant of <span class="monoText">suit</span> the value is, that variant can itself contain data:</p>

	<pre class="language-sml"><code>
		datatype rank = Jack | Queen | King | Ace | Num of int
	</code></pre>

	<p>We can combine these two sum types into a product type: <span class="monoText">suit * rank</span>. Sum types are particularly useful when we want to have different data in response to the state of the world. For example, maybe we are operating a library where we want to identify a book by an ID number, but if the book does not have an ID, use instead the book's title:</p>

	<pre class="language-sml"><code>
		datatype id = BookNum of int
								| Title of string*(string option)*string 
	</code></pre>
</section>

<section id="recursive_types">
	<h4>Recursive Types</h4>
	<p>A recursive compound data type is a type that can refer to itself in its definition to describe a recusive structure. We've seen one such recursive type, lists. An <span class="monoText">int</span> list describes values that contain either nothing, <span class="underlineText">or</span> contains an <span class="monoText">int</span> <span class="underlineText">and</span> another <span class="monoText">int</span> list. We can see this to be the case when we build a list recursively:</p>

	<figure class="math-display">
		<ul class="syntax">
			<li>1 :: [ 2 :: [3 :: [4 :: [5 :: [6 :: []]]]]]</li>
			<li>${\darr}$</li>
			<li>[1, 2, 3, 4, 5, 6]</li>
		</ul>
	</figure>

	<p>Compound data types can nest, so we can have many different combinations of the data types above. We might have a recursive-sum type, or a sum-product type, or a recursive-sum-product type, etc.</p>
</section>


	</article>
</main>

<!-- Scripts -->
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js " integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
		<script>
			document.addEventListener("DOMContentLoaded", function () {
				renderMathInElement(document.body, {
					// customised options
					// • auto-render specific keys, e.g.:
					delimiters: [
						{ left: "$$", right: "$$", display: true },
						{ left: "$", right: "$", display: false },
						{ left: "\\(", right: "\\)", display: false },
						{ left: "\\[", right: "\\]", display: true },
					],
					// • rendering keys, e.g.:
					throwOnError: false,
				});
			});
		</script>
		<!-- <script src="https://unpkg.com/function-plot@1.22.2/dist/function-plot.js"></script> -->
		<script src="js/csfoundations.js"></script>
		<script src="js/prism.js"></script>
</body>
</html>
