<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>csf_java</title>
		<!-- <base href="http://127.0.0.1:5500/csfoundations/" /> -->
		<link rel="stylesheet" href="css/csfoundations.css" />
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous" />
		
	</head>

	<body>
		<header>
			<h1>Computer Science Fundamentals</h1>
		</header>
		<main>
		<!-- Java Programming -->
			<article class="java_introduction grid" data-colcade="columns: .grid-col, items: .grid-item">
				<!-- grids -->
					<div class="grid-col grid-col--1"></div>
					<div class="grid-col grid-col--2"></div>
					<div class="grid-col grid-col--3"></div>
					<div class="grid-col grid-col--4"></div>
				<section id="java_preface" class="grid-item">
					<h2>Computer Science Basics with Java</h2>
					<p>A <span class="boldText">program</span> is a set of instructions to be carried out by a computer. When the computer carries out the instructions, the program is said to have <span class="italicsText">executed</span>. Like humans, computers can only carry out those instructions if actually understands the them. However, unlike humans, computers can only understand 0s and 1s. To ensure our instructions are translated to 0s and 1s, we write our instructions in a <span class="boldText">programming language</span> &mdash; a systematic set of rules used to describe computations in a format that we, as humans, can edit.</p>
					<p>The instructions we write in a program are broadly referred to as <span class="boldText">source code</span>. When we're ready to execute, we <span class="italicsText">compile</span> the program, whereupon the <span class="italicsText">Java compiler</span> translates our source code into <span class="boldText">byte code</span> &mdash; code that the computer understands.</p>
					<p>There are numerous programming languages, many of which are designed with a particular &#8220;philosophy&#8221; or &#8220;principle.&#8221; <span class="italicsText">Procedural languages</span> are those whose programs are a series of commands. These languages include Pascal and C. <span class="italicsText">Functional programming languages</span> are premised on the idea that programs are composed of functions, mapping inputs to outputs. Examples of such languages include Lisp, ML, and Haskell. Then there are <span class="italicsText">object-oriented languages</span> &mdash; programs are composed of interacting &#8220;objects.&#8221; This family includes Smalltalk, C++, and Java. Finally, there are <span class="italicsText">logic programming languages</span>, where programs consist of sentences in logical form, expressing facts and rules about problems. This group includes languages like Prolog and Datalog.</p>
					<p>Most languages result from programmers attempting to solve a problem where either (a) there was no language available, or (b) an existing language was insufficient. For example, C is used primarily for low-level operating systems and devices, and C++ was the result of C not providing a means for object-oriented design. JavaScript was borne out of frustrations with static web pages.</p>
					<p>Java, the language explored in these next sections, was originally intended for use by embedded systems &mdash; devices like digital timers, MP3 players, recording devices, etc. Over time, however, it began to be used for web applications. If we use a very old web browser and visit very old webpages, we might see this historical fact in the form of Java applets (if you don't know what those are, that's a good thing; Java applets have been outdated for many, many years). Today, JavaScript has taken that mantle, but Java is now the language of choice for the most popular mobile operating system, Android OS. Moreover, along with Python, Java is a common language for introductory computer scince courses.</p>
					<p>Here is a basic program in Java:</p>
					<pre class="language-java"><code>
						int x = 5;
						int y = 6;
						System.out.println(x + y);
						int z = x + y + 1;
						System.out.println(z);
					</code></pre>
					<pre class="language-bash"><code>
						11
						12
					</code></pre>
					<p>This is a simple arithmetic computation in Java. As we've seen, computers can do simple math. Another example:</p>
					<pre class="language-java"><code>
						int temperature = 
						if (temperature < 0) {
							System.out.println("Ok this is cold")
						} else {
							System.out.println("Meh, typical winter")
						}
					</code></pre>
					<pre class="language-bash"><code>
						Line 3: error: extraneous input 'if' expecting {'boolean', 'byte', 'char', 'double', 'float', 'int', 'long', 'new', 'record', 'short', 'super', 'switch', 'this', 'void', DECIMAL_LITERAL, HEX_LITERAL, OCT_LITERAL, BINARY_LITERAL, FLOAT_LITERAL, HEX_FLOAT_LITERAL, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL, TEXT_BLOCK_LITERAL, 'null', '(', '{', '<', '!', '~', '++', '--', '+', '-', '@', IDENTIFIER}
						if (temperature < 0) {
						^
						Line 3: error: missing ';' at '{'
						if (temperature < 0) {
												^
						Line 5: error: extraneous input 'else' expecting {'abstract', 'assert', 'boolean', 'break', 'byte', 'char', 'class', 'continue', 'do', 'double', 'final', 'float', 'for', 'if', 'import', 'int', 'interface', 'long', 'native', 'new', 'private', 'protected', 'public', 'record', 'return', 'short', 'static', 'strictfp', 'super', 'switch', 'synchronized', 'this', 'throw', 'transient', 'try', 'void', 'volatile', 'yield', 'while', DECIMAL_LITERAL, HEX_LITERAL, OCT_LITERAL, BINARY_LITERAL, FLOAT_LITERAL, HEX_FLOAT_LITERAL, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL, TEXT_BLOCK_LITERAL, 'null', '(', '{', '}', ';', '<', '!', '~', '++', '--', '+', '-', '@', IDENTIFIER}
						} else {
						^
						3 errors
					</code></pre>
					<p>The code above was supposed to compute a simple conditional. But, the output is a large error message. This is a typical error message in Java. In this case, the error message is telling us we neglected to assign a value to the variable <span class="monoText">temperature</span>. If we actually assign a value to <span class="monoText">temperature</span>:</p>
					<pre class="language-java"><code>
						int temperature = 10
						if (temperature < 0) {
							System.out.println("Ok this is cold")
						} else {
							System.out.println("Meh, typical winter")
						}
					</code></pre>
					<pre class="language-bash"><code>
						Meh, typical winter
					</code></pre>
					<p>Now the code works. Computers are good at making simple decisions. Here is another example:</p>
					<pre class="language-java"><code>
						long i = 0;
						while (i < 1000000L) {
							i++;
						}
						System.out.println("Finished");
					</code></pre>
					<pre class="language-bash"><code>
						Finished
					</code></pre>
					<p>The code above incremented the value <span class="monoText">0</span> by 1 a million times before it outputs the string <span class="monoText">"Finished"</span>. Executing this code, it takes less than a second to output the string. Compare that to how long it would take a human. If you held then dropped a tennis ball, a typical modern computer could easily have executed over a billion instructions before the ball even hit the floor. Computers can perform repetitive tasks very very quickly.</p>
					<p>Computers can also communicate:</p>
					<pre class="language-java"><code>
						System.out.println("Hello, world!");
					</code></pre>
					<pre class="language-bash"><code>
						Hello, world!
					</code></pre>
					<p>Putting it all together, computers are good at four things:</p>
					<ol>
						<li>Basic arithmetic</li>
						<li>Simple decision making</li>
						<li>Repeating tasks over and over again, very fast</li>
						<li>Communicating</li>
					</ol>
					<p>These are all things we generally aren't very good at. We might be good at the fourth point, but really, when it comes to communicating <span class="italicsText">efficiently</span> and <span class="italicsText">clearly</span>, most of us fall short.</p>
					<p>These four points evidence an implicit value of studying computer science &mdash; it teaches us more about what separates humans from everything else. The conjecture: If a computer can do $x$, where $x$ is some activity, then $x$ is <span class="underlineText">not</span> a uniquely human activity."</p>
				</section>

				<section id="types_and_variables_in_java" class="grid-item">
					<h3>Types and Variables in Java</h3>
					<p><span class="topic">Declarations</span>. Programs need data. To give our programs that data, they must be stored somewhere in memory. But before we store any data in Java, we must tell Java beforehand that you are going to store data. To do so, we need <span class="boldItalics">variables</span>. In Java, every variable has a <span class="boldItalics">name</span> and a <span class="boldItalics">type</span>. In the example below, there are <span class="italicsText">comments</span>, denoted by two forward slashes (<span class="monoText">//</span>). Every other statement is called a <span class="boldItalics">declaration</span>. The left side is the variable's <span class="boldItalics">type</span>, and the right side the variable's <span class="boldItalics">name</span>.</p>
					<pre class="language-java"><code>
						// Declare variable named c of type char
						char c;

						// Declare variable named num of type int
						int num;

						// Declare variable named isPresent of type boolean  
						boolean isPresent;
					</code></pre>
					<p><span class="topic">Names in Java</span>. In Java, names must begin with either Unicode letters and digits, the dollar sign (<span class="monoText">$</span>), or the underscore (<span class="monoText">_</span>). By convention, however, names should always begin with a letter. Names in Java also follow camelCasing (capitalizing every other word to indicate spacing), rather than pothole_casing (using underscores to indicating spacing). The exception to this convention is with constants &mdash; very letter in a constant should be in upper case, with spaces indicated by undercores. Finally, Java places heavy emphasis on <span class="underlineText">descriptive</span> and <span class="underlineText">concise</span> variable names, erring on the side of <span class="underlineText">descriptive</span>.</p>
					<pre class="language-java"><code>
						// This is good
						int age = 22;

						// These are good
						int NUM_ATTENDEES = 87;
						boolean ATTENDED = true;

						// This is bad
						float $pi = 3.14;

					</code></pre>
					<p>In general, there are three guidelines we should follow when creating variable names:</p>
					<ol>
						<li>The variable name should describe the data stored in the variable.</li>
						<li>Our code is read more times than it is written (whether by ourselves or others). Our priority should be &#8220;easy to understand,&#8221; not &#8220;easy to write.&#8221;</li>
						<li>If there are standard conventions, follow them; else, create a name and be consistent.</li>
					</ol>
					<p>Additionally, like any other programming language, there are certain words we cannot use as names in Java. These are called <span class="boldItalics">reserved words</span>:</p>
					<div class="compare">
						<pre class="language-pseudo"><code>
							abstract, assert
							boolean, break, byte
							case, catch, char, class, const, continue
							default, do, double
							else, extends
							false, final, finally, float, for
							goto
							if, implements, import, instanceof, int, interface
						</code></pre>
						<pre class="language-pseudo"><code>
							long
							native, new, null
							package, private, protected, public
							return
							short, static, strictfp, super, switch, synchronized
							this, throw, throws, transient, true, try
							void, volatile, while
						</code></pre>
					</div>
					<p><span class="topic">Redeclaring Variables</span>. With few exceptions relating to scope &mdash; in Java, once you have declared a variable name of a particular type, you cannot redeclare it later down the program:</p>
					<pre class="language-java"><code>
						// Declare variable named c of type char
						char c;

						// Variable is already declared, this will return an error
						char c;

						// This also won't work, even if it's of different type
						int c;
					</code></pre>
					<p>Even if the last example worked, it would be a stark example of <span class="italicsText">dirty code</span>, poor programming hygiene. How will our future selves or other coders tell the two apart?</p>
					<p><span class="topic">Comments in Java</span>. As mentioned previously, comments in Java are indicated by two forward slashes (<span class="monoText">//</span>). Everything indicated as a comment will not be executed. In Java, there are two types of comments:</p>
					<pre class="language-java"><code>
						// This is an inline comment, it starts with //

						/*
						 * This is a block, or multiline, comment. It starts with /* 
						 * and ends with 
						*/
					</code></pre>
					<p><span class="topic">Types in Java</span>. In Java, there are eight <span class="boldItalics">primitive data types</span>. All other data in Java is represented by some combination of these eight primitive types. The types fall into four broad categories:</p>
					<ol>
						<li>integers</li>
						<li>floating point numbers</li>
						<li>text</li>
						<li>boolean</li>
					</ol>
					<p><span class="topic">Integers</span>. Integers are the whole numbers and their negative counterparts (e.g., 0, 5, -11, 27, etc.). In Java, these numbers can be represented by any one of these four types:</p>
					<pre class="language-java"><code>
						byte
						short
						int
						long
					</code></pre>
					<p><span class="topic">Floating Point Numbers</span>. Floating point numbers, or real numbers, are those numbers with fractional parts, or decimal points (i.e., 0.0, 12.9, 3.14, -1.29, etc.) We can represent these numbers with any one of these two types:</p>
					<pre class="language-java"><code>
						float
						double
					</code></pre>
					<p><span class="topic">Text</span>. Text is represented in Java with a single data type:</p>
					<pre class="language-java"><code>
						char
					</code></pre>
					<p><span class="topic">Boolean</span>. Boolean values are the binary values <span class="monoText">true</span> and <span class="monoText">false</span>. These are the only two values under the type:</p>
					<pre class="language-java"><code>
						boolean
					</code></pre>
					<p>With just these eight types:</p>
					<ul>
						<li><span class="monoText">byte, short, int, long</span></li>
						<li><span class="monoText">float, double</span></li>
						<li><span class="monoText">char</span></li>
						<li><span class="monoText">boolean</span></li>
					</ul>
					<p>we can represent any data that a computer can work with. </p>
					<p><span class="topic">Initialization</span>. Once we have declared a variable, we can assign it data. In doing so, we <span class="boldItalics">initialize</span> the variable (we give the variable an <span class="italicsText">initial</span> value):</p>
					<pre class="language-java"><code>
						float increment = 0.1;
						boolean isItSnowing = false;
						long weightBlueWhale = 330000;  
					</code></pre>
					<p>Note that every statement in Java ends with a semicolon (<span class="monoText">;</span>). Like C, Java is a <span class="boldItalics">semicolon-delimited language</span>.</p>
					<p>To use variables in Java, they <span class="underlineText">must</span> be initialized:</p>
					<pre class="language-java"><code>
						double x;
						System.out.println(x);
					</code></pre>
					<pre class="language-bash"><code>
						Line 3: error: variable x might not have been initialized
						System.out.println(x);
						                 ^
						1 error
					</code></pre>
					<p>The number or value we explicitly assign to a variable is called a <span class="boldItalics">literal</span>. In programs, there are values that change as the program runs. An <span class="italicsText">incrementer</span> or <span class="italicsText">accumulator</span>, for example. Literals are those values that do not change. They might be manipulated, but the value we explicitly wrote always appears directly in our source code.</p>
					<pre class="language-java"><code>
						// These are literals
						char tic = 'x';
						char tac = 'o'; 

						// Note the L suffix; this is how we tell Java that this is big number
						long bigNum = 10000L;

						boolean isComplete = true;
						boolean isIncomplete = false;
					</code></pre>
					<p><span class="topic">Modifying Variables</span>. Once a value is assigned to a variable, we can modify it as the program runs:</p>
					<pre class="language-java"><code>
						int changing = 10; 

						changing = 20; // assign a new value

						changing = 20 + 20; // Arithmetic is ok right of =

						changing += 1; // Add 1, assign it the result

						changing -= 1; // Subtract 1, assign it the result

						changing *= 2; // Multiply by 2, assign it the result

						changing /= 2; // Divide by 2, assign it the result 
					</code></pre>
					<p>We can also modify variables by assigning existing variables. Always read assignments from right to left:</p>
					<pre class="language-java"><code>
						double first = 10.0;
						double second = 5.0;
						first = second // assignment, right to left
						second = 20.0;
						first = second + 10.0;
						double third = 2.0;
						first = second + third; // arithmetic with variables on right is ok

						int z = 10;
						z = z + 1; // z is now 11
					</code></pre>
					<p>The last example reveals a crucial point about assignment, and why we want to always read them from right to left. The value assigned to <span class="monoText">z</span> at the very last line is first computed &mdash; <span class="monoText">z + 1</span> &mdash; then assigned. The value stored in <span class="monoText">z</span> when <span class="monoText">z + 1</span> is computed is <span class="monoText">10</span>, so the value assigned to <span class="monoText">z</span> at the very last line is <span class="monoText">11</span>.</p>
					<p><span class="topic">Type Maintenance</span>. Once we declare a variable in that variable must maintain its type. We cannot, say, declare a variable <span class="monoText">num</span> of type <span class="monoText">int</span>, and thereafter assign to it data of type <span class="monoText">float</span>:</p>
					<pre class="language-java"><code>
						int num = 10;
						num = 10.0; # error is returned for this
					</code></pre>
					<p>Failure to remember this rule can lead to unexpected results:</p>
					<pre class="language-java"><code>
						int num = 35;
						num /= 2;
						System.out.println(num);
					</code></pre>
					<pre class="language-bash"><code>
						11
					</code></pre>
					<p>The correct answer to the above should be ${11.\overline{6}.}$ (The overline, called a <span class="italicsText">vinculum</span>, indicates repeating digits). We're getting <span class="monoText">11</span> because <span class="monoText">num</span> was declared to store data of type <span class="monoText">int</span>. Note that there is no rounding occurring here. Java is simply dropping the fractional digits.</p>
					<p><span class="boldText monoText">string</span>. Strings in Java script must be enclosed in double quotes:</p>
					<pre class="language-java"><code>
						System.out.println("Hello, world!'); // causes an error
						System.out.println("Hello, world!"); // no error
					</code></pre>
					<p><span class="topic">Why &#8220;Primitive&#8221; Type?</span> The eight types above are referred to as &#8220;primitive&#8221; types because they can all be represented by numbers. The numeric data types <span class="monoText">byte, short, int, long, float, double</span> can obviously all be represented by numbers. But what about <span class="monoText">char</span> and <span class="monoText">boolean</span>? Well, <span class="monoText">boolean</span> is simply a binary value &mdash; we can represent <span class="monoText">false</span> with <span class="monoText">0</span> and <span class="monoText">true</span> with <span class="monoText">1</span>. <span class="monoText">char</span> is more interesting. In programming, English characters have a corresponding numeric code called an <span class="boldItalics">ASCII code</span>, found in the ASCII table. Because each letter is encoded in ASCII with numbers, they too can be represented as numbers. ASCII has generally gone along the wayside, replaced by the much larger UNICODE enconding system. This is due to ASCII encoding only English characters &mdash; obviously English isn't the only language we speak. UNICODE encodes a large set of characters, from &#x627;&#x644;&#x641;&#x628;&#x627;&#x6CC; &#x641;&#x627;&#x631;&#x633;&#x6CC; to &#129313;.</p>
					<p><span class="topic">Why are there so many types?</span> Like C, Java provides a variety of types to manage memory. Each of the types takes up a certain amount of memory. Below is a table:</p>
					<figure class="table">
						<table>
							<thead>
								<th>Java Primitive Type</th>
								<th>Bytes Required</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">boolean</span></td>
									<td rowspan="2">1 byte</td>
								</tr>
								<tr>
									<td><span class="monoText">byte</span></td>
								</tr>
								<tr>
									<td><span class="monoText">char</span></td>
									<td rowspan="2">2 bytes</td>
								</tr>
								<tr>
									<td><span class="monoText">short</span></td>
								</tr>
								<tr>
									<td><span class="monoText">int</span></td>
									<td rowspan="2">4 bytes</td>
								</tr>
								<tr>
									<td><span class="monoText">float</span></td>
								</tr>
								<tr>
									<td><span class="monoText">long</span></td>
									<td rowspan="2">8 bytes</td>
								</tr>
								<tr>
									<td><span class="monoText">double</span></td>
								</tr>
							</tbody>
						</table>
					</figure>
					<p>These memory usages are crucial to keep in mind when working with data. Failing to recall them can lead to unexpected results:</p>
					<pre class="language-java"><code>
						byte num = 10;
						num += 256;
						System.out.println(num);
					</code></pre>
					<pre class="language-bash"><code>
						10
					</code></pre>
					<p>Why isn't the console displaying <span class="monoText">356</span>? Because the type <span class="monoText">byte</span> is restricted to exactly 1 byte &mdash; it can only store integers up to 256.</p>
					<p><span class="topic">Arithmetic Operator Precedence.</span> Operators are evaluated in a specific order. Parentheses are always evaluated first. Inside the parentheses or otherwise, operators are evaluated left-to-right. Going from left to right, multiplication (<span class="monoText">*</span>) and modulus (<span class="monoText">%</span>) are evaluated before addition (<span class="monoText">+</span>) and subtraction (<span class="monoText">-</span>).</p>
					<p><span class="topic">Modulus Operator.</span> Many computer science newcomers are unfamiliar with the modulus operator. This operator simply returns the remainder from dividing some number $a$ by ${b.}$ This is a particularly useful operation. With it, we can check several things. For example, if ${a \bmod 2}$ returns a remainder of 0, then we know that $a$ is an even number. If ${a \bmod 2}$ returns a remainder greater than 0, then we know that $a$ is an odd number. The modulus is also helpful for obtaining the last $x$ digits of a particular squence of numbers.</p>
					<p><span class="topic">Strongly-typed v. Weakly-typed Languages</span> In many languages, like Python and JavaScript, we, the programmers, are not required to explicitly state what types our data are. These are called <span class="italicsText">weakly-typed languages</span>. Java and C, however, are <span class="italicsText">strongly-typed</span> languages &mdash; we must explicitly provide a datum's type. The benefit of strongly-typed languages: It forces us to specify how much space we need to store data. This means we have no choice but to be efficient. Moreover, it helps us catch some of the most common programming errors.</p>
				</section>

				<section id="conditional_statements_in_java" class="grid-item">
					<h3>Conditional Statements in Java</h3>
					<p>The values <span class="monoText">true</span> and <span class="monoText">false</span> of type <span class="monoText">boolean</span> are the building blocks of computer decision-making. This due to the way computers make decision &mdash; they take complex expressions and reduce them to true or false evaluations.</p>
					<p><span class="topic">Comparisons in Java</span> In Java, we can compare variables against either literal values or other values. This forms the basis for simple decision making. They return <span class="monoText">true</span> or <span class="monoText">false</span>, values of type <span class="monoText">boolean</span>:</p>
					<pre class="language-java"><code>
						int num = 10;
						System.out.println(num == 0);
						System.out.println(num != 0);
						System.out.println(num != 10);
						System.out.println(num < 10);
						System.out.println(num <= 10);
						System.out.println(num > 10);
						System.out.println(num >= 10);
					</code></pre>
					<pre class="language-bash"><code>
						false
						true
						false
						false
						true
						false
						true
					</code></pre>
					<p>The code above demonstrates Java's comparison operators:</p>
					<figure class="table">
						<table>
							<thead>
								<th>Operator</th>
								<th>Computation Requested</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">a == b</span></td>
									<td>Is <span class="monoText">a</span> equal to <span class="monoText">b</span>?</td>
								</tr>
								<tr>
									<td><span class="monoText">a != b</span></td>
									<td>Is <span class="monoText">a</span> not equal to <span class="monoText">b</span>?</td>
								</tr>
								<tr>
									<td><span class="monoText">a < b</span></td>
									<td>Is <span class="monoText">a</span> less than <span class="monoText">b</span>?</td>
								</tr>
								<tr>
									<td><span class="monoText">a <= b</span></td>
									<td>Is <span class="monoText">a</span> less than or equal to <span class="monoText">b</span>?</td>
								</tr>
								<tr>
									<td><span class="monoText">a > b</span></td>
									<td>Is <span class="monoText">a</span> greater than <span class="monoText">b</span>?</td>
								</tr>
								<tr>
									<td><span class="monoText">a >= b</span></td>
									<td>Is <span class="monoText">a</span> greater than or equal <span class="monoText">b</span>?</td>
								</tr>
							</tbody>
						</table>
					</figure>
					<p><span class="topic">Comparing Variables</span> We can also compare two variables:</p>
					<pre class="language-java"><code>
						int firstNum = 1;
						int secondNum = 2;
						System.out.println(firstNum > secondNum);
						System.out.println(firstNum < secondNum);
					</code></pre>
					<pre class="language-bash"><code>
						false
						true
					</code></pre>
					<p><span class="topic">Comparing Variables with Arithmetic</span> We can also compare results from computations involving variables directly:</p>
					<pre class="language-java"><code>
						int firstNum = 1;
						int secondNum = 2;
						System.out.println(firstNum + secondNum == 3);
						System.out.println(firstNum - secondNum <= 2);
					</code></pre>
					<pre class="language-bash"><code>
						true
						true
					</code></pre>
					<p><span class="topic">Connecting Comparisons</span> We can connect a comparison expression with another comparison express to form a compound comparison. This is done with the <span class="monoText">and</span> operator (<span class="monoText">&&</span>) and the <span class="monoText">or</span> operator (<span class="monoText">||</span>). There are two rules that always apply when using these two operators, stemming directly from logic:</p>
					<div class="rule">
						<p><span class="topic">Rule</span> Given Boolean expressions $p$ and ${q,}$ the compound expression ${p \texttt{ \&\& } q}$ returns <span class="monoText">true</span> if, and only if, both $p$ returns <span class="monoText">true</span> and $q$ returns <span class="monoText">true</span>.</p>
						<p><span class="topic">Rule</span> Given Boolean expressions $p$ and ${q,}$ the compound expression ${p \texttt{ || } q}$ returns <span class="monoText">false</span> if, and only if, both $p$ returns <span class="monoText">false</span> and $q$ returns <span class="monoText">false</span>.</p>
					</div>
					<p>For example:</p>
					<pre class="language-java"><code>
						int num = 10;
						System.out.println(num > 5 && num < 10);
						System.out.println(num < 10 && num > 5);
						System.out.println(num > 10 || num > 5);
						System.out.println(num > 10 || false);
					</code></pre>
					<pre class="language-bash"><code>
						false
						false
						true
						false
					</code></pre>
					<p><span class="topic">Evaluation Order &amp; Grouping</span> Suppose we have the following Boolean expression:</p>
					<figure class="math-display">
						<div>
							<p>${p \texttt{ \&\& } q \texttt{ \&\& } (r \texttt{ || } (s \texttt{ \&\& } t))}$</p>
						</div>
					</figure>
					<p>Java applies severaly rules for dealing with these complicated expressions. First, Boolean expressions are <span class="underlineText">always</span> evaluated from left to right. Second, as soon as Java knows what the entire expression's result is, it will stop. It will not continue evaluating the expression. If we want Java to evaluate particular expressions first, we use parentheses. In practice, however, these rules should not cause problems &mdash; we should not be writing complex Boolean expressions like that above. An example:</p>
					<pre class="language-java"><code>
						int num = 10;
						System.out.println((num > 0 && num < 10) || (num == 10));
						System.out.println((num > 0 && num < 10) && (num == 10));
						System.out.println(num < 10 && (num == 10 || num == 10));
						System.out.println(num < 10 && num == 10 || num == 10);
					</code></pre>
					<pre class="language-bash"><code>
						true
						false
						false
						true
					</code></pre>
					<p>The last line returns <span class="monoText">true</span> because the expression is evaluated from left to right. <span class="monoText">num < 10</span> is <span class="monoText">false</span>. <span class="monoText">num == 10</span> is <span class="monoText">true</span>. Thus, the <span class="monoText">and</span> expression thus far is <span class="monoText">false</span>. But, that expression logically connected with <span class="monoText">||</span> to the expression <span class="monoText">num == 10</span>, which is <span class="monoText">true</span>. Thus, the entire expression is <span class="monoText">true</span>.</p>
					<div class="rule">
						<p><span class="topic">Rule</span> Given a compound Boolean expression $p$ in Java, $p$ is always evaluated from left to right. If $p$ contains parentheses, then the expressions contained in the parentheses are evaluated first. Else or therein, the expressions are evaluated in the following order:</p>
						<ol>
							<li>the unary operators are evaluated (<span class="monoText">++, --, -, !, ~, !</span>)</li>
							<li>the mulplicative operators are evaluated (<span class="monoText">*, /, %</span>);</li>
							<li>the additive operators are evaluated (<span class="monoText">+ -</span>);</li>
							<li>the relational operators (<span class="monoText"><, >, <=, >=</span>) are evaluated;</li>
							<li>the equality operators (<span class="monoText">==, !=</span>) are evaluated;</li>
							<li>the logical <span class="monoText">AND</span> operator (<span class="monoText">&&</span>) is evaluated;</li>
							<li>the logical <span class="monoText">OR</span> operator (<span class="monoText">||</span>) is evaluated;</li>
							<li>the ternary operator (<span class="monoText">? :</span>) is evaluated;</li>
							<li>the assignment operators (<span class="monoText">=, +=, -=, *=, /=, %=</span>) are evalauted last.</li>
						</ol>
					</div>
					<p><span class="topic">Querying Data</span> With the comparison operators, Java can make simple decisions:</p>
					<pre class="language-java"><code>
						int num = 10;
						if (num > 20) {
							System.out.println("num is greater than 20");
						} else {
							System.out.println("num is not greater than 20")
						}
					</code></pre>
					<pre class="language-bash"><code>
						num is not greater than 20
					</code></pre>
					<p>When we combine keywords <span class="monoText">if</span> and <span class="monoText">else</span>, we produce <span class="italicsText">conditional statements</span>. These statements tell Java to execute a <span class="italicsText">code block</span> &mdash; a set of statements &mdash; if, and only if, a specified condition is true. Every single computer makes decisions using this general structure, <span class="monoText">if-else</span>. As an aside, note the indentation in the example above. This indentation must be used in Java.</p>
					<p>With the <span class="monoText">else if</span> keyword, we can produce more complex conditional statements:</p>
					<pre class="language-java"><code>
						int num = 0;
						if (num == 1) {
							System.out.println("if block executed");
						} else if (num < 1) {
							System.out.println("first else if block executed");
						} else if (num > 1) {
							System.out.println("second else if block executed");
						} else {
							System.out.println("else block executed");
						}
					</code></pre>
					<pre class="language-bash"><code>
						first else if block executed
					</code></pre>
					<p>The code outputs as expected. Each of the conditional statements are evaluated one by one, top to bottom. If a conditional statement's condition returns <span class="monoText">false</span>, then Java moves to the next conditional statement. The very last statement, an <span class="monoText">else</span> statement, is called a <span class="italicsText">false block</span>. Think of the <span class="monoText">else</span> statement as the default rule, and the statements before it as the exceptions &mdash; if none of the <span class="monoText">if</span> or <span class="monoText">else if</span>s return <span class="monoText">true</span>, then the <span class="monoText">else</span> applies.</p>
					<p>A critical point: As soon as one of the conditional statements returns <span class="monoText">true</span>, the conditional statements thereafter are <span class="underlineText">never</span> run:</p>
					<pre class="language-java"><code>
						int num = 0;
						if (num == 0) {
							System.out.println("if block executed");
						} else if (num < 1) {
							System.out.println("first else if block executed");
						} else if (num > 1) {
							System.out.println("second else if block executed");
						} else {
							System.out.println("else block executed");
						}
					</code></pre>
					<pre class="language-bash"><code>
						if block executed
					</code></pre>
					<p>Here we changed the first conditional statement to <span class="monoText">num == 0</span>. This returns <span class="monoText">true</span>, so Java goes into that <span class="italicsText">arm</span>, or <span class="italicsText">branch</span>, of the program. Java does not enter any of the other arms. Java will move to the next statements to execute, whether that's inside the conditional statement's code block or outside the branches. Note what this means: If there is an <span class="monoText">else</span> statement, then there is <span class="italicsText">exactly one</span> conditional statement executed. If there is no <span class="monoText">else</span> statement, then there is either (a) no conditional statements executed, or (b) <span class="italicsText">at most one</span> conditional statement executed.</p>
					<p><span class="topic">Nested Conditionals</span> We can nest conditional statements inside conditional statements to create more complex branching:</p>
					<pre class="language-java"><code>
						int num = 3;
						if (num == 0) {
							System.out.println("I am 0!");
						} else if (num > 0) {
							if (num == 1) {
								System.out.println("I am 1!");
							} else if (num == 2) {
								System.out.println("I am 2!");
							} else {
								System.out.println("I am positive, but not 0, 1, or 2!");
							}
						} else if (num < 0) {
							System.out.println("I am a negative!");
						} else {
							System.out.println("I am a positive!");
						}
					</code></pre>
					<pre class="language-bash"><code>
						I am positive, but not 0, 1, or 2!
					</code></pre>

					<p><span class="topic">Switch Statements.</span> A branching structure consisting of <span class="monoText">if</span> and <span class="monoText">else-if</span> statements can be reduced to <span class="italicsText">switch statements</span>:</p>
					<pre class="language-java"><code>
						// This structure:
						if (condition_A) {
							...
						} else if (condition_B) {
							...
						} else if (condition_C) {
							...
						};

						// is equivalent to:
						switch (variable) {
							case A:
								...
							case B:
								...
							case C:
								...
							default:
								...
						}
					</code></pre>
					<p>Switch statements are common in many languages, but some languages implement them much more efficiently and powerfully. Java is not one of those languages. Switch statements are somewhat limited in Java, and they are not nearly as commonly seen in Java programs compared to say, Haskell programs. For example, switch statements in Java are inherently limited to the <span class="monoText">variable</span> component above. That <span class="monoText">variable</span> can only be a primitive type or a <span class="monoText">string</span>. However, compared to <span class="monoText">if</span> and <span class="monoText">else-if</span> statements, switch statements can match multiple cases in a single <span class="monoText">switch</span> statement (i.e., a switch statement can have multiple arms, while the formers cannot).</p>
					<p>There is a nuance to the way switch statements work that can lead to frustration: The execution starts at a matching case statement, then continues until a <span class="monoText">break</span> statement is reached. In other words, the case analysis will not stop at the first match. It will continue testing. For this reason, we often must include a break at each case.</p>
					<p>Finally, notice the <span class="monoText">default</span> case at the last line above. This means what it says: If none of the cases return <span class="monoText">true</span>, Java will execute that particular line.</p>
					<pre class="language-java"><code>
						int test = 2;
						switch (test) {
							case 0: System.out.println("A");
							case 1: System.out.println("B");
							case 2: System.out.println("C");
							case 3: System.out.println("D");
							default: System.out.println("E");
						}
					</code></pre>
					<pre class="language-bash"><code>
						C
						D
						E
					</code></pre>
					<p>Notice how Java continued execution after the match. To ensure only the test <span class="monoText">case 2</span> is executed, we need a break statement:</p>
					<pre class="language-java"><code>
						int test = 2;
						switch (test) {
							case 0: System.out.println("A");
							case 1: System.out.println("B");
							case 2: System.out.println("C");
								break;
							case 3: System.out.println("D");
							default: System.out.println("E");
						}
					</code></pre>
					<pre class="language-bash"><code>
						C
					</code></pre>
				</section>

				<section id="java_variable_scope" class="grid-item">
					<h4>Variable Scope in Java</h4>
					<p>As we saw with conditional statements, blocks of code in Java are a set of statements. They are enclosed by braces:</p>
					<pre class="language-java"><code>
						if (...) {
							// a block of code
						}
					</code></pre>
					<p>A block of code is essentially a &#8220;mini&#8221; program inside a bigger program. And because they are effectively sub-programs, there are rules about what we can and cannot do inside or outside blocks of code. In particular: Variables declared <span class="italicsText">inside</span> the block are not visible <span class="italicsText">outside</span> the block. Once we leave the block of code, Java can no longer see that variable &mdash; the variable is no longer available for us to access. It is only accessible inside the block.</p>
					<p>Inversely, if a variable is declared <span class="italicsText">outside</span> a block, then the variable is visible <span class="italicsText">inside</span> the block. If we declare a variable outside the block, then Java can see that variable inside the block.</p>
					<pre class="language-java"><code>
						int outsideBlock = 1
						if (true) {
							int insideBlock = 10;
							System.out.println(outsideBlock);
						}
						System.out.println(insideBlock);
					</code></pre>
					<pre class="language-bash"><code>
						Line 6: error: cannot find symbol
						System.out.println(inside);
												^
						symbol:   variable inside
						1 error
					</code></pre>
					<p>We get an error because we are telling Java to print the value assigned to a variable it cannot see. Once we left the <span class="monoText">if</span> statement's block &mdash; <span class="monoText">insideBlock</span>'s <span class="italicsText">enclosing block</span> (also called <span class="italicsText">enclosing scope</span>) &mdash; <span class="monoText">insideBlock</span> no longer exists for all intents and purposes. However, we can still access <span class="monoText">outsideBlock</span> because it exists outside the <span class="monoText">if</span> statement's block:</p>
					<pre class="language-java"><code>
						int outsideBlock = 1
						if (true) {
							int insideBlock = 10;
							System.out.println(outsideBlock);
						}
					</code></pre>
					<pre class="language-bash"><code>
						1
					</code></pre>
					<p>Scope is precisely why programming languages require, or encourage, indentation. Assuming we follow proper indentation like the examples above, the general rule of thumb is: We <span class="underlineText">can</span> access variables &#8220;to the left&#8221; or on the same level; we <span class="underlineText">cannot</span> access variables &#8220;to the right.&#8221; (Where the directions are relative to the start of the line).</p>
				</section>

				<section id="java_arrays" class="grid-item">
					<h4>Arrays in Java</h4>
					<p>In the preceding sections, the data we used were <span class="italicsText">single</span> data values. These values are represented by single numbers (integers or floats), truth values (true and false), and characters (ASCII or Unicode encodings). What if want to <span class="italicsText">multiple</span> values? After all, data does not just consist of single data values. A single character does not make a novel, nor does a single temperature make a weather forecast. More often than not, our use of data involves multiple data values.</p>
					<p>Every piece of text we see on a computer is called a <span class="boldText">string</span> in computer science. All strings are a sequence of <span class="monoText">char</span> values. And since <span class="monoText">char</span> values are just a unique sequence of numbers, text is just a sequence of numbers to a computer.</p>
					<p>The concept of a sequence implies its <span class="italicsText">elements</span> are meaningfully <span class="italicsText">ordered</span>. If we scrutinized this fact, we'd realize that there are numerous data that require ordering. DNA, for example, consists of ordered bases. Time series data consists of measurements taken at regular intervals (e.g., temperatures, stock prices, pandemic deaths). Elton John's <span class="italicsText">Bennie and the Jets</span> on Spotify consists of ordered air pressure measurements. All of these are data consisting of multiple data values ordered meaningfully.</p>
					<p><span class="topic">Arrays</span>. How do we store all of this data? Through <span class="boldText">arrays</span>. A Java array is a variable representing a series of zero or more values of the <span class="italicsText">same</span> type. More specifically, an array is a <span class="boldText">data structure</span> that places, or arranges, values in order, one after another.</p>
					<p>Because arrays place values in order, each value inside an array has a place or position in the array, called its <span class="boldText">index</span>. That index is broadly referred to as <span class="boldText">metadata</span> &mdash; data about the relationship between the value stored and the data structure. Metadata is critical to a data structure. For arrays, the metadata is <span class="italicsText">index</span>. If we took that metadata away, the array would no longer be ordered &mdash; Bach would sound like white noise and Hemmingway would look like ASCII splatter. Moreover, given that the index tells us what a particular value's position is in the array, we can access a specific value inside the array using its index.</p>
					<p><span class="topic">Declaring Arrays</span>. Like any other variable, arrays have a <span class="italicsText">name</span> and a <span class="italicsText">type</span>. The difference, however, is the way we declare them. To do so, we include brackets after the type, rather than just the type:</p>
					<pre class="language-java"><code>
						// This is a single int variable named integer
						int integer; 

						// This is an array of integers 
						int[] multipleIntegers;

						// A single character
						char letter;

						// An array of characters
						char[] word;
					</code></pre>
					<p><span class="topic">Initializing Arrays</span>. When an array is merely declared, it is empty. To fill it with values, we <span class="underlineText">must</span> tell Java how many <span class="boldText">elements</span> &mdash; the individual data values &mdash; it will take. The number of elements an array stores is the array's <span class="boldText">length</span> &mdash; the <span class="italicsText">size</span> of the array. That size <span class="underlineText">cannot be changed</span> once the array is initialized. Once an array is initialized, it has a set length, and we can access that length with the <span class="monoText">.length</span> property.</p>
					<pre class="language-java"><code>
						// An array of 8 integers named multipleIntegers
						int[] multipleIntegers = new int[8];

						// An array of characters named word
						char[] word;
						// Initialize word to hold 4 characters
						word = new char[4];

						System.out.println(multipleIntegers.length);
						System.out.println(word.length);
					</code></pre>
					<pre class="language-bash"><code>
						8
						4
					</code></pre>
					<p>Note the two ways we can use to initialize an array. We can first declare the array, then indicate its size, or, we can write it all in one line. We can also initialize an array by directly assigning values to the array in a single line:</p>
					<pre class="language-java"><code>
						// An array of integers 0, 1, 2, 3, 4
						int[] integerSequence = { 0, 1, 2, 3, 4 };

						// An array of characters 'j','a','v','a'
						char[] word = { 'j', 'a', 'v', 'a' };

						System.out.println(integerSequence.length);
						System.out.println(word.length);
					</code></pre>
					<pre class="language-bash"><code>
						5
						4
					</code></pre>
					<p>Observe the difference between Java and many other languages: We assign values to an array with curly braces, <span class="monoText">{}</span>, rather than square brackets. Notice also that we do not explicitly provide a size in the initialization method above. This is because Java will automatically count how many elements are in the assignment when we initialize in this manner, producing the array's <span class="monoText">.length</span> property.</p>
					<p><span class="topic">Accessing Specific Values in an Array</span>. Once an array is initialized and values are assigned to it, we can access the individual values in the array with <span class="italicsText">bracket syntax</span>. Inside that bracket, we pass the integer representing our sought value's index:</p>
					<pre class="language-java"><code>
						char[] word = {'j', 'a', 'v', 'a'}; 
						
						System.out.println(word.length);
						System.out.println(word[0]);
						System.out.println(word[1]);
						System.out.println(word[2]);
						System.out.println(word[3]);
					</code></pre>
					<pre class="language-bash"><code>
						4
						j
						a
						v
						a
					</code></pre>
					<p>Notice that the array <span class="monoText">word</span> has a length of <span class="monoText">4</span>, but the last element in the array has an index of <span class="monoText">3</span>. This is because the first element in an array has <span class="monoText">index = 0</span>. In computer science, we almost always count starting from <span class="monoText">0</span> (we say almost always because some programming languages count from 1; e.g., Smalltalk, COBOL, Julia, Matlab, Mathematica, etc.). This means that, if an array has, say, 10 elements, then the first element has an index of 0, and the last element has an index of 9. Thus, in such an array, an index we pass is valid if, and only if, that index is 0, 9, or an integer in between 0 and 9.</p>
					<div class="rule">
						<p><span class="topic">Java Rule.</span> Given an array of size ${n}$ containing elements, each element has an index ${i,}$ where ${0 \leq i < n.}$ The <span class="italicsText">first</span> element of the array has the index ${i = 0,}$ and the <span class="italicsText">last</span> element of the array has the index ${i = n - 1.}$</p>
					</div>
					<p>Because the array index is just an integer value, we can insert code into the square brackets of a particular array to obtain a value therein, so long as the code returns a nonnegative <span class="monoText">int</span> value and such value is a valid index:</p>
					<pre class="language-java"><code>
						int[] nums = {0, 1, 2};
						
						system.out.println(nums.length - 1);
					</code></pre>
					<pre class="language-bash"><code>
						2
					</code></pre>
					<p>When we initialize arrays by declaring and assigning values to the array in a single statement, we must be sure to include the square brackets. Failing to do so will lead to an error:</p>
					<pre class="language-java"><code>
						int oddNumberSequence = {1, 3, 5, 7};

						System.out.println(oddNumberSequence[0]);
					</code></pre>
					<pre class="language-bash"><code>
						HelloWorld.java:5: error: illegal initializer for int
						int oddNumberSequence = {1, 3, 5, 7};
														^
						HelloWorld.java:7: error: array required, but int found
						System.out.println(oddNumberSequence[0]);
																		^
						2 errors
					</code></pre>
					<p><span class="topic">Replacing Values in an Array</span>. The square bracket syntax also allows us to replace <span class="italicsText">existing</span> values in an array:</p>
					<pre class="language-java"><code>
						char[] name = {'j', 'o', 'h', 'n'};
						System.out.println(name[2]);
						
						name[2] = 'a';
						System.out.println(name[2]);
					</code></pre>
					<pre class="language-bash"><code>
						h
						a
					</code></pre>
					<p><span class="topic">Invalid Indices.</span> In Java, indices can only be nonnegative integers less than the array's size. If we try to pass an invalid index (an index that does not satisfy the rule stated above), we will get an error:</p>
					<pre class="language-java"><code>
						// an array of size 4
						int[] primeSequence = {2, 3, 5, 7};

						System.out.println(primeSequence[4]);
					</code></pre>
					<pre class="language-bash"><code>
						Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
								at HelloWorld.main(HelloWorld.java:7)
					</code></pre>
					<p>In programming parlance, this is a <span class="boldText">crash</span>. The program completely failed to execute.</p>
				</section>

				<section id="loops_in_java" class="grid-item">
					<h4>Loops in Java</h4>
					<p>The process of repeatedly doing the same thing over and over again is called a <span class="boldText">loop</span>. In the previous section, we the most basic data structure, an array. Loops are a common way to work with data stored in array. There are two types of loops &mdash; <span class="monoText">while</span> loops and <span class="monoText">for</span> loops.</p>

					<p><span class="topic">The <span class="monoText">while</span> Loop.</span> The simplest loop is the <span class="monoText">while</span> loop. It takes the following form in Java:</p>

					<pre class="language-java"><code>
						while (x) {
							...
							...
							...
						}

						// 'x'  &rarr; some code that outputs true or false
						// ...  &rarr; a statement to execute
					</code></pre>

					<p>In the <span class="monoText">while</span> loop, we pass into the parentheses some code that outputs true or false. Most often, these are Boolean expressions. <span class="italicsText">As long as</span> the condition, in the example above <span class="monoText">x</span>, returns <span class="monoText">true</span>, the code block enclosed by the <span class="monoText">while</span> loop executes.</p>
					<p>In sum, the <span class="monoText">while</span> loop has two parts:</p>

					<ol>
						<li>A condition that must be true each time the loop is entered, called the <span class="italicsText">test statement</span> (represented by <span class="monoText">x</span> in the syntax above); and</li>
						<li>a block of code to repeat (represented by the set of ellipses above)</li>
					</ol>

					<p>As soon as the condition is false, the block of code <span class="underlineText">is not executed</span>, and execution continues after the loop. Otherwise, the block of code continues executing. In loops, each execution  of a loop's block of code is called an <span class="boldText">iteration</span>. For example:</p>

					<pre class="language-java"><code>
						int iteration = 0;
						while (iteration < 4) {
							System.out.println(iteration);
							iteration++;
						}
						System.out.println("Done");
					</code></pre>
					<pre class="language-bash"><code>
						0
						1
						2
						3
						Done
					</code></pre>

					<p>The operator <span class="monoText">++</span> is the increment-by-1 operator; it adds the integer 1 to a particular value. This will cause different inputs for the <span class="monoText">while</span> loop, allowing it evaluate to either <span class="monoText">true</span> or <span class="monoText">false</span>. We call this the <span class="italicsText">updating statement</span>. In the code above, the condition is <span class="monoText">iteration < 4</span>. Since <span class="monoText">iteration = 0</span>, the condition in plain English is, &#8220;As long as <span class="monoText">iteration</span> is less than <span class="monoText">4</span>, execute the following.&#8221; The first time we encounter the <span class="monoText">while</span> loop, <span class="monoText">iteration = 0</span>; the condition returns <span class="monoText">true</span>. So, we print the current value assigned to <span class="monoText">increment</span>, <span class="monoText">0</span>, and then we increment: <span class="monoText">iteration = 1</span>. We go back to the condition: Is <span class="monoText">1 < 4</span>? Yes. Print <span class="monoText">1</span> and increment: <span class="monoText">iteration = 2</span>. Is <span class="monoText">2 < 4</span>? Yes. Print <span class="monoText">2</span> and increment: <span class="monoText">iteration = 3</span>. Is <span class="monoText">3 < 4</span>? Yes. Print <span class="monoText">3</span> and increment: <span class="monoText">increment = 4</span>. Is <span class="monoText">4 < 4</span>? No. Java ignores the <span class="monoText">while</span> loop's code block and moves to the next statement &mdash; print <span class="monoText">"Done"</span>.</p>

					<p><span class="topic">The <span class="monoText">do-while</span> Loop.</span> The <span class="monoText">do-while</span> loop takes the following form:</p>
					<figure class="math-display">
						<pre class="language-pseudo"><code>
							do {
								<span class="italicsText">expressions</span>
							} while ( <span class="italicsText">condition</span> )
						</code></pre>
					</figure>
					<p>Compared to the <span class="monoText">while</span> loop, the <span class="monoText">do-while</span> loop checks the condition <span class="italicsText">after</span> the expressions are executed. In effect, the <span class="monoText">do while</span> loop operates similarly to the <span class="monoText">while</span> loop (it is still a loop), with the difference being the loop's body always executes <span class="underlineText">at least once</span> (in contrast to <span class="monoText">while</span> loops, where no such requirement exists; the loop body may never execute if the first condition check returns <span class="monoText">false</span>).</p>

					<pre class="language-java"><code>
						// the loops below have the same condition
						// only one will have its body executed 

						int i = 0;
						while (i < 0) {
							System.out.println("while " + i);
							i++
						};

						i = 0;
						do {
							System.out.println("do-while" + i);
							i++;
						} while (i < 0)
					</code></pre>
					<pre class="language-bash"><code>
						do-while 0
					</code></pre>

					<p><span class="topic">Infinite Loops.</span> If we're going to use a <span class="monoText">while</span> loop, we must have code that eventually causes its condition to return <span class="monoText">false</span>. In other words, we need to ensure that the <span class="monoText">while</span> loop will eventually <span class="italicsText">halt</span>. Otherwise, the loop becomes an <span class="italicsText">unterminated loop</span>, which will cause our code to <span class="italicsText">hang</span>, or hit a <span class="italicsText">timeout</span>.</p>

					<p>Most often, such code is included in the <span class="monoText">while</span> loop's body. If we fail to write this code, the <span class="monoText">while</span> loop's code block will continue executing endlessly &mdash; an infinite loop. Here is an example of an unterminated <span class="monoText">while</span> loop:</p>

					<pre class="language-java"><code>
						int index = 0;
						while (index < 4) {
							System.out.println(index);
							index--;
						}
						System.out.println("Done");
					</code></pre>

					<p>The <span class="monoText">while</span> loop never terminates because its condition will always return <span class="monoText">true</span>. The <span class="monoText">while</span> loop here will run for as long as it can until the console eventually returns a <span class="monoText">(Program Timed Out)</span>. Here is a more explicit example of an unterminated loop:</p>

					<pre class="language-java"><code>
						while (true) {
							System.out.println("Looping");
						}
					</code></pre>

					<p>This is such a clear example of an unterminated loop that we have a special name for it &mdash; the <span class="monoText">while true</span> loop. If we ever feel the need to use a <span class="monoText">while true</span> loop, we must always ask ourselves what we're using it for &mdash; we're playing with fire.</p>

					<p><span class="topic"><span class="monoText">while</span> Loops and Arrays.</span> With the <span class="monoText">while</span> loop, we can loop through the values in an array:</p>

					<pre class="language-java"><code>
						char[] word = {'j', 'a', 'v', 'a'};
						int index = 0;
						while (index < 4) {
							System.out.println(word[index]);
							index++;
						}
						System.out.println("Done");
					</code></pre>
					<pre class="language-bash"><code>
						j
						a
						v
						a
						Done
					</code></pre>

					<p><span class="topic">The <span class="monoText">for</span> Loop.</span> Looping through data structures like arrays is so common in programming that we have an alternative and cleaner way of looping, the <span class="monoText">for</span> loop. The syntax is the following:</p>

					<pre class="language-java"><code>
						for (int i = 0; i < n; i++) {
							...
							...
							...
						}

						/* 
						where: 
							i is an index (an integer)
							n is the number of times we want to loop
							... is a statement to execute
						*/ 
					</code></pre>

					<p>The <span class="monoText">for</span> loop accomplishes the same task as the <span class="monoText">while</span> loop &mdash; it's just cleaner. Compare the two:</p>

					<div class="compare">
						<pre class="language-java"><code>
							int i = 0;
							while (i < n) {
								...
								...
								...
							}
						</code></pre>
						<pre class="language-java"><code>
							for (int i = 0; i < n; i++) {
								...
								...
								...
							}
						</code></pre>
					</div>

					<p>Notice that in the <span class="monoText">for</span> loop, there are four parts:</p>

					<ol>
						<li><span class="boldText monoText">int i = 0;</span> The <span class="boldText">counter</span>, a variable to be used by the test condition. This variable is only available inside the loop. We cannot access it outside the loop.</li>
						<li><span class="boldText monoText">i < 4;</span> The condition to test, called the <span class="italicsText">test statement</span>. This is checked every time we enter the loop, <span class="italicsText">including</span> the first time. As long as this condition is true, the block of code is executed, and the loop continues. As soon as the condition is false, the loop terminates, and Java ignores all statements thereafter.</li>
						<li><span class="boldText monoText">i++</span> The code that changes the index, causing different inputs to the test's condition, called the <span class="italicsText">updating statement</span>. This code is executed <span class="italicsText">only</span> when we return to the top of the loop. It is <span class="underlineText">not</span> executed the first time.</li>
						<li><span class="boldText monoText">{ ... }</span> The statements to execute.</li>
					</ol>

					<p>The first three parts (the statements contained inside the parentheses), is called the <span class="monoText">for</span> loop's <span class="boldText">header</span>, and the block of code to execute is called the <span class="monoText">for</span> loop's body. Bearing these parts in mind, an example:</p>

					<pre class="language-java"><code>
						char[] word = {'j', 'a', 'v', 'a'};
						for (int index = 0; index < 4; index++) {
							System.out.println(word[index]);
						}
						System.out.println("Done");
					</code></pre>
					<pre class="language-bash"><code>
						j
						a
						v
						a
						Done
					</code></pre>

					<p>Again, a <span class="monoText">for</span> loop operates exactly the same as a <span class="monoText">while</span> loop, just shorter and more concise. Here is a <span class="monoText">while</span> loop implementation:</p>

					<pre class="language-java"><code>
						int[] primes = {2, 3, 5, 7, 11};
						int i = 0;

						while (i < 5) {
							System.out.println(primes[i]);
							i++;
						}

						System.out.println("Done");
					</code></pre>
					<pre class="language-bash"><code>
						2
						3
						5
						7
						11
						Done
					</code></pre>
					<p>And here is a <span class="monoText">for</span> loop implementation:</p>
					<pre class="language-java"><code>
						int[] primes = {2, 3, 5, 7, 11};

						for (int i = 0; i < primes.length; i++) {
							System.out.println(primes[i]);
						}

						System.out.println("Done");
					</code></pre>
					<pre class="language-bash"><code>
						2
						3
						5
						7
						11
						Done
					</code></pre>
					<p>A helpful way to loop through the array is to use the array's <span class="monoText">.length</span> property. This spares us from manually counting each of the individual elements in the array; a task that may be impossible or cumbersome with large arrays.</p>
					<p><span class="topic"><span class="monoText">for</span> Loop Nuances.</span> In a <span class="monoText">for</span> loop, the <span class="italicsText">counter</span> variable is initialized <span class="underlineText">only once</span>. It does not get &#8220;reinitialized&#8221; at each iteration. The value assigned to it changes, but there is no new initialization. The loop's <span class="italicsText">test expression</span> is evaluated <span class="underlineText">every time</span> the loop block is executed, including the first time. The loop's <span class="italicsText">updating statement</span> is executed <span class="underlineText">after</span> each time the block is executed and <span class="underlineText">before</span> the condition is checked. Putting altogether, the algorithm consists of the following steps in order:</p>
					<ol>
						<li>Evaluate the condition.</li>
						<li>If the condition is false, ignore the <span class="monoText">for</span> loop's block of code and go to the statement after the <span class="monoText">for</span> loop.</li>
						<li>If the condition is true, execute the loop's block of code.</li>
						<li>After the block finishes executing, update the loop variable.</li>
						<li>Repeat.</li>
					</ol>
					<p><span class="topic">Changes to a Loop Variable.</span> We can change a variable initialized outside a <span class="monoText">while</span> loop with code inside the <span class="monoText">while</span> loop:</p>
					<pre class="language-java"><code>
						int i = 0;
						while (i < 10) {
							i++;
						}
						System.out.println(i);
					</code></pre>
					<pre class="language-bash"><code>
						10
					</code></pre>
					<p>The same goes for a <span class="monoText">for</span> loop:</p>
					<pre class="language-java"><code>
						int num = 0;
						for (int i = 0; i < 10; i++) {
							num++;
						}
						System.out.println(num);
					</code></pre>
					<pre class="language-bash"><code>
						10
					</code></pre>
					<p><span class="topic">Incomplete <span class="monoText">for</span> Loops.</span> We are not <span class="italicsText">required</span> to provide the counter, test statement, or the update statement inside the <span class="monoText">for</span> loop's header. They can be stated outside the <span class="monoText">for</span> loop, and used inside the header, or omitted entirely:</p>
					<pre class="language-java"><code>
						int i = 0;
						for (; i < 10; i++) {
							// this will execute 10 times
						}
						for (; i < 10; ) {
							// this will execute exactly once
						}
						for (;;) {
							// this will hang
						}
					</code></pre>
					<p>Note, we should not write loops this way unless we have a good reason for doing so &mdash; such code is difficult to read and a breeding ground for bugs.</p>
					<p><span class="topic">Loop Control.</span> We can control loops by using the keywords <span class="monoText">break</span> and <span class="monoText">continue</span>. The keyword <span class="monoText">break</span> tells Java &#8220;Get out of this loop now&#8221; We might use this if our loop eventually returns the data we sought, or if a particular condition occurs. For example, we might search a particular array, and once a match is found, we <span class="monoText">break</span>, rather than continuing to check the remaining values. For example:</p>
					<p>Oppositely, the word <span class="monoText">continue</span> tells Java, &#8220;Get back to the top of the loop now, perform the update, and continue to the code block.&#8221; This keyword is often used when our loop runs, and returns data that isn't interesting. For example, we might have an array of user emails, and we only want to send a newsletter to those who agreed to receiving newsletters. We loop through all of the user emails &mdash; if the user opted to receive newsletters, we send the newsletter, otherwise, we <span class="monoText">continue</span>.</p>
					<p>Here is an example utilizing the two key words:</p>
					<pre class="language-java"><code>
						int query = 5;
						int[] primes = {2, 3, 5, 7};
						for (int i = 0; i < primes.length; i++) {
							if (primes[i] == query) {
								System.out.println("Match found: " + query);
								break;
							} else if ((primes[i] != query) && (i < primes.length-1)) {
								continue;
							} else {
								System.out.println("No match: " + query);
								break;
							}
						}
						System.out.println("Loop exited");
					</code></pre>
					<pre class="language-bash"><code>
						Match found: 5
						Loop exited
					</code></pre>
					<p><span class="topic">Enhanced <span class="monoText">for</span> Loop.</span> Going through the values in an array one at a time is so common in programming that Java provides syntactic sugar for it. On the left is a regular <span class="monoText">for</span> loop, and on the right is the enhanced <span class="monoText">for</span> loop:</p>
					<div class="compare">
						<pre class="language-java"><code>
							// Regular for loop

							int[] arr = {0, 1, 2, 3};
							for (int i = 0; i < arr.length; i++) {
								System.out.println(arr[i]);
							}
						</code></pre>
						<pre class="language-java"><code>
							// Enhanced for loop

							int[] arr = {0, 1, 2, 3};
							for (int element : arr) {
								System.out.println(element);
							}
						</code></pre>
					</div>
					<p>If we just want to iterate through the values inside an array, we can use the enhanced <span class="monoText">for</span> loop. It's cleaner, more concise, and we don't need to worry about indexes. The tradeoff: We don't have access to a indices. Thus, if our computation needs access to index, we should use the regular <span class="monoText">for</span> loop.</p>
					<p><span class="topic"><span class="monoText">while</span> v. <span class="monoText">for</span> Loops.</span> If we want to execute a statement or set of statements as long as some condition is true, but we do not know how many times the statement should execute, a <span class="monoText">while</span> loop would be best to use. <span class="monoText">while</span> Loops are an example of an <span class="boldText">indefinite loop</span>. If, however, we know exactly how many times we want to iterate or we have data that provides such number, a <span class="monoText">for</span> loop is ideal &mdash; it is a <span class="boldText">definite loop</span>.</p>
					<p><span class="topic">Fencepost Problem.</span> A very common error when handling <span class="monoText">for</span> loops is the <span class="italicsText">fencepost problem</span> (also called <span class="italicsText">of-by-one error</span>). Suppose we wanted to build a fence with 5 posts and 4 wires between the posts. The fencepost problem is represented with the following diagram:</p>
					<figure><img src="images/fence_post_problem.svg" alt="fencepost" loading="lazy" class="eighty-p"></figure>
					<p>In its simplest form, the problem occurs because a procedure involves two steps, say $a$ and ${b,}$ and $a$ must be repeated $n$ times, while $b$ must be repeated ${n - 1}$ times. Whenever we see this procedural pattern, we must first execute $b$ before we begin iterating $a$ and $b$ together, as seen in the diagram above.</p>
				</section>

				<section id="loop_exercises" class="exercises grid-item">
					<p><span class="exh">Exercise</span>. How many times do the following loops execute?</p>
					<ol>
						<li>
							<pre class="language-java"><code>
								int counter = 0;
								for (int loop = 4; loop <= 8; loop += 2) {
									counter++;
								}
								System.out.println(counter);
							</code></pre>
								<details class="answer">
									<summary>Solution</summary>
									<p>The counter starts at 0. The loop variable starts at 4. As long as it is less than or equal to 8, we execute, and update the counter. After each execution, the counter updates by 2. Thus, at <span class="monoText">loop = 4</span>, the test statement returns <span class="monoText">true</span>. So, <span class="monoText">counter = 1</span>, and <span class="monoText">loop = 6</span>. Is <span class="monoText">6 <= 8</span>? Yes. <span class="monoText">counter = 2</span>; <span class="monoText">loop = 8</span>. Is <span class="monoText">8 <= 8</span>? Yes. <span class="monoText">counter = 3</span>; <span class="monoText">loop = 10</span>. Is <span class="monoText">10 <= 8</span>? No. We leave the loop and go to the next statement, print <span class="monoText">counter</span>. Counter was updated to <span class="monoText">3</span>, so this is the value printed out:</p>
									<pre class="language-bash"><code>
										3
									</code></pre>
								</details>
						</li>
						<li>
							<pre class="language-java"><code>
								int count = 0;
								for (int i = 10; i >= 10; i -= 3) {
									count++;
								}
								System.out.println(count);
							</code></pre>
							<details class="answer">
								<summary>Solution</summary>
								<p>The variable <span class="monoText">count</span> starts at 0, and it is updated by 1 inside the loop. The loop's counter starts at <span class="monoText">i = 10</span>. If <span class="monoText">i >= 10</span>, we execute then decrement <span class="monoText">i</span> by 3. Thus, the first time: <span class="monoText">i = 10</span>. Condition is true, so <span class="monoText">count = 1</span>, and <span class="monoText">i = 7</span>. Test, and the condition is false &mdash; ${7 \nleq 10.}$</span> Thus, the loop executes exactly once: <span class="monoText">count = 1</span>.</p>
							</details>
						</li>
						<li>
							<pre class="language-java"><code>
								int i = 0;
								for (int j = 2; j >= 4; j++) {
									i++;
								}
								System.out.println(i);
							</code></pre>
							<details class="answer">
								<summary>Solution</summary>
								<p>This loop never executes. Remember, the test statement is evaluated the first time. In this case, the test statement returns <span class="monoText">false</span> &mdash; ${2 \nleq 4.}$</p>
								<pre class="language-bash"><code>
									0
								</code></pre>
							</details>
						</li>
					</ol>
					<p><span class="exh">Exercise.</span> Given the array below, print each element with a loop:</p>
						<pre class="language-java"><code>
							char[] letters = {'a', 'b', 'c', 'd'};
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Using a <span class="monoText">for</span> loop:</p>
							<pre class="language-java"><code>
								char[] letters = {'a', 'b', 'c', 'd'};

								for (int i = 0; i < letters.length; i++) {
									System.out.println(letters[i]);
								}
							</code></pre>
							<pre class="language-bash"><code>
								a
								b
								c
								d
							</code></pre>
							<p>Or, with an enhanced <span class="monoText">for</span> loop:</p>
							<pre class="language-java"><code>
								char[] letters = {'a', 'b', 'c', 'd'};

								for (char elements : letters) {
									System.out.println(elements);
								}
							</code></pre>
							<pre class="language-bash"><code>
								a
								b
								c
								d
							</code></pre>
						</details>
					<p><span class="exh">Exercise.</span> Given the array below, print every other element on the same line:</p>
						<pre class="language-java"><code>
							char[] letters = {'b', 'h', 'y', 'e', 'e', 'y'};
						</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Here is one implementation:</p>
							<pre class="language-java"><code>
								char[] letters = {'b', 'h', 'y', 'e', 'e', 'y'};

								for (int i = 1; i <= letters.length; i+=2) {
									System.out.print(letters[i]);
								}
							</code></pre>
							<pre class="language-bash"><code>
								hey
							</code></pre>
						</details>
					<p><span class="exh">Exercise.</span> Given the array below, print only the elements with even indices:</p>
					<pre class="language-java"><code>
						int[] nums = {1, 2, 3, 4, 5, 6, 7, 8};
					</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<pre class="language-java"><code>
								int[] nums = {1, 2, 3, 4, 5, 6, 7, 8};

								for (int i = 2; i < nums.length; i+=2) {
									System.out.println(nums[i]);
								}
							</code></pre>
							<pre class="language-bash"><code>
								3
								5
								7
							</code></pre>
						</details>
					<p><span class="exh">Exercise.</span> Given the array below, print the sum of all its elements:</p>
						<pre class="language-java"><code>
							int[] primesArr = {2, 3, 5, 7, 11, 13, 17, 19, 23};
						</code></pre>
							<details class="answer">
								<summary>Solution</summary>
								<p>Here is one possible implementation:</p>
								<pre class="language-java"><code>
									int[] primesArr = {2, 3, 5, 7, 11, 13, 17, 19, 23};
									int primesArrSum = 0;
									for (int i = 0; i < primesArr.length; i++) {
										primesArrSum += primesArr[i];
									}
									System.out.println(primesArrSum);
								</code></pre>
								<pre class="language-bash"><code>
									100
								</code></pre>
							</details>
				</section>

				<section id="java_algorithms" class="grid-item">
					<h3>Algorithms in Java</h3>
					<p>An <span class="boldText">algorithm</span> is a sequence of steps, or a set of rules, for solving a problem. Computer scientist or otherwise, humans use algorithms daily. The child brushing her teeth; the father preparing her sandwich for lunch; the traveler changing a flat tire; the doctor deciding to order a biopsy; the lawyer filing an appeal and the judge deciding the issue is moot &mdash; regardless of complexity, these are all actions involving algorithms.</p>
					<p>In computer science, however, we're concerned with a particular kind of algorithm &mdash; those that can be implemented by a computer, called <span class="italicsText">effective procedures</span>. More explicitly, these are algorithms that can be completed by relying only on what computers can do: Performing simple arithmetic, store results, make simple decisions, and repeating the preceding actions as fast as possible, over and over.</p>
					<p>A common misconception, often perpetuated by the media, is that algorithms are code. No. Algorithms are abstractions. We can <span class="italicsText">implement</span> that algorithm with code, in which case the code becomes an <span class="boldText">implementation</span>. But we can just as well implement the same algorithm with a checkbox and have a human compute and store the results themselves. Regardless of implementation, the algorithm is still there: ${\text{algorithm} \nRightarrow \text{code} .}$</p>
					<div class="example">
						<p><span class="exh">Problem</span>. Given three integers assigned to separate variables, find the maximum value.</p>
						<p>The first step to solving this problem is figuring out what we know. How do we compare two numbers? Well, say we have $a$ and ${b,}$ $a$ being the first number. To determine if $a$ is greater, we have to rule out the two cases: ${a < b}$ and ${a = b.}$ If ${a < b,}$ then $a$ is not greater. If ${a = b,}$ then its irrelevant whether $a$ or $b$ is greater. This means there are only two relevant cases ${a < b,}$ and ${a > b.}$ If ${a > b,}$ then $a$ is the greatest number. If ${a < b,}$ then $b$ is the greatest number.</p>
						<p>Great, now we have to implement. To do so, we have to remember that a computer can only see values one at a time. That is a mindset we must always have when thinking of implementations.</p>
						<pre class="language-java"><code>
							int first = 12;
							int second = 28;
							int third = 9;
							int biggest = first;

							if (first < second) {
								biggest = second;
							}
							if (biggest < third) {
								biggest = third;
							}
							System.out.println(biggest);
						</code></pre>
						<pre class="language-bash"><code>
							28
						</code></pre>
						<p>Now, suppose we had instead an array of integers. How would we find the maximum?</p>
						<pre class="language-java"><code>
							int[] values = {3, 12, 27, 91, 2, 98, 14, 76};
							int maxValue = values[0];
							for (int i = 1; i < values.length; i++) {
								if (values[i] > maxValue) {
									maxValue = values[i];
								}
							}
							System.out.println(maxValue);
						</code></pre>
						<pre class="language-bash"><code>
							98
						</code></pre>
						<p>Note that in the above implementation, we started the counter at <span class="monoText">1</span> rather <span class="monoText">0</span>. Why? Because we don't need to look at the first value.</p>
					</div>
				</section>

				<section id="java_console_programming" class="grid-item">
					<h3>Console Programming in Java</h3>
					<p><span class="term">Console programs</span> are programs that run on a console (the window displayed by a terminal). Console programs go all the way back to the early days of modern computing, before word processors and GUI applications grew popular. The basic idea of a console program is that text appears on the console (e.g., a Terminal window), prompting the user to supply data. A program then executes on the basis of that data.</p>
					<p>While console programs have largely been replaced by applications with GUIs, they remain a useful way of studying programming in the context of user interaction without having to deal with the complexities of graphic implementation (an entire field on to itself). As an aside, there is a difference between a terminal and a console. A &#8220;terminal&#8221; is a colloquial term that broadly refers to programs providing access to a <span class="italicsText">shell</span>. A console is simply a rectangle that displays program behavior.</p>
					<p><span class="topic">Using <span class="monoText">acm</span> Packages.</span> For some of the applications below, we will use the <span class="monoText">acm</span> packages provided by the ACM Java Task Force. To do so, ensure that you have the <span class="monoText">acm.jar</span> file in the same working directory as the <span class="monoText">.java</span> file containing our program. All code should be written inside the <span class="monoText">public void run() {}</span> method:</p>
					<pre class="language-java"><code>
						import acm.program.*;

						public class zing extends ConsoleProgram {
							public void run() {
								println("Hello world!");
							}
						}
					</code></pre>
					<p>To compile and execute the program above, we write:</p>
					<pre class="language-bash"><code>
						java -cp .:acm.jar zing
					</code></pre>
					<p>Alternatively, we will also use the <span class="monoText">Scanner</span> object to create console programs for certain examples. To create a new console program with a <span class="monoText">Scanner</span> object, we use the following:</p>
					<figure class="math-display">
						<pre class="language-java"><code>
							import java.util.scanner;

							public class foo {
								public static void main(String[] args) {
									Scanner namePrompt = new Scanner(System.in); // create new scanner object
									System.out.println("Name: "); // prompt for user input
									String name = namePrompt.nextLine(); // read user input
									System.out.println("Hello " + name); // use user input
								}
							}
						</code></pre>
					</figure>
					<p>There is a fair amount of new keywords in the code, and we will explore them in due course. For now, all we need to do is follow the template above, replacing <span class="monoText">file_name</span> with the name of the <span class="monoText">.java</span> file containing our code, and <span class="monoText">statements</span> with the code we actually want to run. Console programs have two key components: (1) <span class="term">user inputs</span> &mdash; the data read by the program that the user types; and (2) <span class="monoText">console outputs</span> &mdash; the messages displayed by the program.</p>
					<p>The <span class="monoText">nextLine()</span> method is used to read Strings. To read other types:</p>
					<figure class="table">
						<table class="loop_table">
							<thead>
								<th>Method</th>
								<th>Description</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">nextBoolean</span></td>
									<td>Reads a <span class="monoText">boolean</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextByte()</span></td>
									<td>Reads a <span class="monoText">byte</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextDouble()</span></td>
									<td>Reads a <span class="monoText">double</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextFloat()</span></td>
									<td>Reads a <span class="monoText">float</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextInt()</span></td>
									<td>Reads a <span class="monoText">int</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextLine()</span></td>
									<td>Reads a <span class="monoText">String</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextLong()</span></td>
									<td>Reads a <span class="monoText">long</span> user input</td>
								</tr>
								<tr>
									<td><span class="monoText">nextShort()</span></td>
									<td>Reads a <span class="monoText">short</span> user input</td>
								</tr>
							</tbody>
						</table>
					</figure>
				</section>

				<section id="functions_in_java" class="grid-item">
					<h3>Functions: Structuring Good Programs</h3>
					<p>With the tools we have thus far, we can create a wide variety of programs. But, programs have <span class="italicsText">structure</span>, and there is a distinction between <span class="italicsText">well-structured programs</span> and <span class="italicsText">poorly-structured programs</span>. The most obvious characteristics of a well-structured program:</p>
					<ol>
						<li>Code is broken down into reusable, testable, and understandable pieces (i.e., modular code);</li>
						<li>Code combines state and behavior;</li>
						<li>Code is documented concisely and clearly; and</li>
						<li>Code reuses preexisting solutions as much as possible.</li>
					</ol>
					<p><span class="topic">Functions.</span> A <span class="italicsText">function</span> is a collection of statements aimed at completing a specific task, and whenever such a task must be completed, the collection can be reused to complete the task. For example, suppose we wanted to compute the average of several values. We can write several statements that computes the average, using the values as inputs. Instead of writing these statements every time we must compute an average, we would write these statements in such a way that they can take any quantity of values as inputs. We would then package these statements into a &#8220;unit&#8221;, or collection, which can reference anytime we must compute an average.</p>
					<p>In Java, a function, also called a <span class="italicsText">subroutine</span> or <span class="italicsText">method</span>, takes zero or more inputs (called <span class="italicsText">arguments</span>), and produces zero or <span class="italicsText">exactly one</span> output. Inside a function are the statements that produce output. Thus, a function is effectively a block of code, much like the blocks of code we saw with conditional statements. That block of code is an instance of <span class="italicsText">imperative programming</span> &mdash; structuring our program with direct statements to be executed one after another, top to bottom &mdash; explicitly commanding the computer how to accomplish a particular task. The function, in contrast, is an instance of <span class="italicsText">functional programming</span> &mdash; structuring our programs by way of functions.</p>
					<p>A good function has several characteristics. First, good functions have <span class="italicsText">specificity</span>: it should perform one, and only one, task, and it should perform it well. Second, they are <span class="italicsText">testable</span> &mdash; we can easily determine whether it outputs correctly. To ensure this prong is met, a good function should perform tasks we already know the outcome of. Third, they are <span class="italicsText">reusable</span>: We can use them anywhere in our program where we need to accomplish that function's task. Finally, good functions are <span class="italicsText">well-documented</span>. The function should include a description of what the function does, what inputs it takes, and what output it returns. Here is an example of a Java function:</p>
					<pre class="language-java"><code>
						/**
						 * Add two numbers
						 *
						 * @param firstNum: the first number to add
						 * @param secondNum: the second number to add
						 * @return the sum of firstNum and secondNum
						 */
						 int add(int firstNum, int secondNum) {
							 return firstNum + secondNum;
						 }
					</code></pre>
					<p><span class="topic">javadoc.</span> In the code above, we see a block comment. This is a special comment in Java, called a <span class="boldText">javadoc</span>. As its name suggests, a javadoc documents a function. It is structured exactly as it appears in the example. It describes what the function does, the function's <span class="italicsText">parameters</span> (the inputs the function takes, demarcated by the word <span class="monoText">@param</span>), and the function's return (the function's output, demarcated by the word <span class="monoText">@return</span>). Like all comments, javadocs are ignored by the compiler.</p>
					<p>In mathematics, we must always be clear about what assumptions we make. The same goes for programming &mdash; it is good practice to include in a javadoc the assumptions underlying our functions. This will make our functions much easier to understand and debug later. For example:</p>
					<pre class="language-java"><code>
						/**
						 * Add two numbers
						 *
						 * @param firstNum: the first number to add
						 * @param secondNum: the second number to add
						 * @return the sum of firstNum and secondNum
						 *
						 * Assumptions:
						 *   both addends are integers
						 */
						 int add(int firstNum, int secondNum) {
							 return firstNum + secondNum;
						 }
					</code></pre>
					<p><span class="topic">Function Type.</span> What is not ignored is the function declaration thereafter. There are several parts to this function. First, we give the function a <span class="italicsText">type</span>. That type is the type for the function's output. In this case, this function will return an <span class="monoText">int</span>, so we provide the function's type as <span class="monoText">int</span>.</p>
					<p><span class="topic">Function Name.</span> Next, we give the function a <span class="italicsText">name</span>. In this case, <span class="monoText">add</span>. This is what we will use to <span class="italicsText">call</span>, or <span class="italicsText">invoke</span>, the function. The guidelines for variable names are applicable here: descriptive, concise, and erring on the side of descriptive. They should also be in camelCase. The one distinction: Because functions perform a task, their names should be <span class="italicsText">verbs</span>.</p>
					<p><span class="topic">Parameters.</span> Just after the name, we have a set of parentheses, <span class="monoText">(int firstNum, int secondNum)</span>, containing what appear to be variable declarations. These are the function's <span class="italicsText">parameters</span>. They define what arguments the function will take as input. These appear like variable declarations because they effectively are. The variables indicated inside the parentheses are what will be used inside the function's body.</p>
					<p>Note, however, that functions need not have parameters. They can simply take no arguments. In the example above, the function has two parameters, so it takes two arguments. Both those arguments must be of type <span class="monoText">int</span>.</p>
					<p><span class="topic monoText">return.</span> Now we enter the function's body. There, we have the keyword <span class="monoText">return</span>. This keyword tells Java to output a particular thing. In this case, the result of <span class="monoText">firstNum + secondNum</span>.</p>
					<p>There is a crucial point with <span class="monoText">return</span> statements: Once Java reaches a <span class="monoText">return</span> statement, the entire function halts. If there are any other statements after the <span class="monoText">return</span> statement, they are <span class="underlineText">not</span> executed. Every function must have a <span class="monoText">return</span> statement, even if there is no output.</p>
					<p><span class="topic">Calling the Function.</span> Once we have defined a function, we can <span class="italicsText">call</span> the function in our program. When we call the function, if the function has parameters, we provide necessary arguments. The code that calls the function is called the <span class="italicsText">caller</span>. Once Java reaches the caller, the caller will halt momentarily, and Java goes to the <span class="italicsText">callee</span> &mdash; the code defining the function. The caller waits as Java executes the function. Once the function returns with an output (if any), Java goes back to the caller with that output, and the caller continues.</p>
					<p>What the caller does with that output is up to the programmer. We can save the output by assigning it to a variable, use it like a literal, or simply ignore it. For example:</p>
					<pre class="language-java"><code>
						static int add(int firstNum, int secondNum) {
							return firstNum + secondNum;
						}

						System.out.println("Just before the first call");
						int result = add(9, 1);
						System.out.println(result);
						System.out.println(add(2, 3));
						int bigResult = add(10, 20) + add(30, 40) + 50;
						System.out.println(bigResult);
						add(4, 6);
						System.out.println("No more calls");
					</code></pre>
					<pre class="language-bash"><code>
						Just before the first call
						10
						5
						150
						No more calls
					</code></pre>
					<p>For now, ignore the word <span class="monoText">static</span>. We will return to this word later. The crucial point is that the function works as expected. Observe the various ways we can use the function. The last call &mdash; <span class="monoText">add(4, 6)</span> &mdash; will compile, but its output will simply become a garbage value. If you are curious, about the code above, it was compiled in Java with the following program:</p>
					<pre class="language-java"><code>
						public class MyClass {
							public static void main(String args[]) {
								System.out.println("Just before the first call");
								int result = add(9, 1);
								System.out.println(result);
								System.out.println(add(2, 3));
								int bigResult = add(10, 20) + add(30, 40) + 50;
								System.out.println(bigResult);
								add(4, 6);
								System.out.println("No more calls");
							}
							
							static int add(int firstNum, int secondNum) {
								return firstNum + secondNum;
							}
						}
					</code></pre>
					<p>Again, ignore these details. We will address them in due time. If a function has $n$ parameters, we <span class="underlineText">must</span> provide exactly $n$ arguments. Failing to do so will lead to errors:</p>
					<pre class="language-java"><code>
						static int add(int firstNum, int secondNum) {
							return firstNum + secondNum;
						}

						int result = add(9);
						System.out.println(result);
					</code></pre>
					<pre class="language-bash"><code>
						required: int,int
						found: int
						reason: actual and formal argument lists differ in length
						1 error
					</code></pre>
					<p>This error directly tells us that we failed to give all the required arguments. Similarly, if we give too many arguments:</p>
					<pre class="language-java"><code>
						static int add(int firstNum, int secondNum) {
							return firstNum + secondNum;
						}

						int result = add(9, 10, 11);
						System.out.println(result);
					</code></pre>
					<pre class="language-bash"><code>
						required: int,int
						found: int,int,int
						reason: actual and formal argument lists differ in length
						1 error
					</code></pre>
					<p>Functions are what allow us to <span class="boldText">decompose</span> programs &mdash; we take a problem, and break it down into smaller pieces that can be solved with commands. Some of those commands are built into Java, but most are not. When we write functions, we are essentially creating a new command we can use in Java.</p>
				</section>

				<section id="strings_in_java" class="grid-item">
					<h3>Strings in Java</h3>
					<p>A significant amount of data is <span class="italicsText">textual data</span>. This text constitutes textual data. Text messages, Wikipedia articles, tweets, Google results, instagram captions, these all constitute textual data. In computers, textual data is represented by a <span class="boldText">string</span> &mdash; a sequence of characters.</p>
					<p>Textual data is so important that Java provides a unique type for it, the data type <span class="monoText">String</span>. Just like any of other data types, we can initialize variables of type <span class="monoText">String</span>:</p>
					<pre class="language-java"><code>
						String greeting = "Hello, world!";
						System.out.println(greeting);
					</code></pre>
					<pre class="language-bash"><code>
						Hello, world!
					</code></pre>
					<p>In Java, data of type <span class="monoText">String</span> are <span class="italicsText">always</span> enclosed in double quotes, whereas data of type <span class="monoText">char</span> are always enclosed in single quotes. In actuality, strings in Java are an array of characters. <span class="monoText">String</span> itself is not a primitive type. However, it is composed of a primitive type, <span class="monoText">char</span>. This means that we can apply to strings many of the actions we would perform with arrays. For example:</p>
					<pre class="language-java"><code>
						String name = "Marcus Aurelius Antoninus";
						System.out.println(name.length());
						System.out.println(name.equals("Lucius Aurelius Verus"));
					</code></pre>
					<pre class="language-bash"><code>
						25
						false
					</code></pre>
					<p>Notice the difference between the way we obtain a string's length and that of typical arrays. It appears as though we called functions, <span class="monoText">length()</span> and <span class="monoText">equals()</span>. We can see that <span class="monoText">length()</span> returns the string's length, and <span class="monoText">equals()</span> appears to check whether two strings are equivalent.Indeed, that is what both these <span class="italicsText">functions</span> do.</p>
					<p><span class="topic">Objects.</span> The fact that we used a <span class="italicsText">function</span>, rather than a <span class="italicsText">property</span>, is evidence of the fact that strings are <span class="boldText">objects</span>. Objects are a special kind of data. Unlike the primitive types, objects combine both <span class="italicsText">state</span> (as primitive types do) and <span class="italicsText">behavior</span> (as functions do). This means that they have data values bound to them, and at the same time, provide functions associated with those values. Strings are the clearest and simplest example of an object. They have data values (the actual textual data) and they have functions associated with those data values (e.g., <span class="monoText">length()</span> and <span class="monoText">equals()</span>). Those functions are called <span class="boldText">methods</span>, and we call them with <span class="boldText">dot notation</span>.</p>
					<p>Every string has a <span class="boldText">state</span> &mdash; the array of characters bound to the string. Every string also has <span class="boldText">behavior</span> &mdash; the functions (methods) we can call to operate on the <span class="monoText">String</span>'s state. With strings, there are numerous such methods. State and behavior are the two things we always ask about when deal with objects.</p>
					<ol>
						<li>State &rarr; What does the object <span class="italicsText">store</span>?</li>
						<li>Behavior &rarr; What does the object <span class="italicsText">do</span>?</li>
					</ol>
					<p><span class="topic">Objects v. Primitives.</span> Objects are different from primitives. Primitives only <span class="italicsText">store</span> data values that can be presented as a <span class="italicsText">single number</span>. In Java, they are indicated by the fact that their names <span class="italicsText">always</span> start with a lower case letter: <span class="monoText">float, int, char, boolean, etc.</span> Primitive types also do not have behavior &mdash; they do not come with functions or methods we can use with their stored data values.</p>
					<p>In contrast, objects can both store data values <span class="italicsText">and</span> provide methods we can use on those data values. In contrast to primitives, object type names <span class="italicsText">always</span> start with an uppercase letter (e.g., <span class="monoText">String</span>). Every object, however, boils down to primitives. An object may be composed of other objects, but at the end of it all are primitives. For example, arrays in Java are actually objects. Those arrays, however, boil down to primitives &mdash; an array of <span class="monoText">char</span>, or an array of <span class="monoText">int</span>, etc.</p>
					<p><span class="topic">Initializing Strings.</span> Normally, to initialize a string in Java, we must use the <span class="monoText">new</span> keyword. We saw this with arrays.</p>
					<pre class="language-java"><code>
						// an array object
						int[] array = new int[8]; 

						// string objects
						String salutate = new String("Hi!");
						String valedict = new String("Bye!"); 
					</code></pre>
					<p>However, strings are so important and common that Java allows us to initialize them as though they were literals:</p>
					<pre class="language-java"><code>
						String salutate = "Hi!";
						String valedict = "Bye!";
					</code></pre>
					<p><span class="topic">Concatenation.</span> We can combine separate strings into a single string. In doing so, we <span class="italicsText">concatenate</span> the strings:</p>
					<pre class="language-java"><code>
						String firstName = "David";
						String lastName = "Hume";
						String fullName = firstName + " " + lastName;

						System.out.println(fullName);
					</code></pre>
					<pre class="language-bash"><code>
						David Hume
					</code></pre>
					<p>Notice that in the example above, we included what appears to be an empty string. It is not empty. That string contains a space. This reveals a crucial fact for when we handle strings: Spaces count as characters. Furthermore, the <span class="monoText">+</span> operator does not work as addition. It concatenates. Because the <span class="monoText">+</span> operator can either compute addition or concatenate strings, we say that the <span class="monoText">+</span> operator is <span class="italicsText">overloaded</span>.</p>
					<p><span class="topic">Dot Notation.</span> Whenever we have an object, we always access that object's state and methods using <span class="italicsText">dot notation</span>:</p>
					<pre class="language-java"><code>
						String word = "sad";

						int lengthOfWord = word.length();
						String replaceLetter = word.replace('s', 'm');
						String upperCaseWord = word.toUpperCase();

						System.out.println(lengthOfWord);
						System.out.println(replaceLetter);
						System.out.println(upperCaseWord);
					</code></pre>
					<pre class="language-bash"><code>
						3
						mad
						SAD
					</code></pre>
					<p>Observe the way we called the methods above: <span class="monoText">variableName.method()</span>. Also observe what the methods above do. <span class="monoText">.replace()</span> will replace characters inside a string, and <span class="monoText">.toUpperCase()</span> will transform characters in the string from lower case to upper case. As can be seen from <span class="monoText">.replace()</span>, some methods have parameters, so we must pass arguments to use them. The <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">Java documentation</a> provides an exhaustive list of these methods.</p>
					<p>Note, however, that once we initialize a string, that string will never change. This is a significant difference between Java and many other languages like Python. Once a string is initialized, we cannot modify it. If we want the modified string, we must separately initialize it.</p>
					<pre class="language-java"><code>
						String blurt = "hey";
						blurt.toUpperCase();
						System.out.println(blurt);
					</code></pre>
					<pre class="language-bash"><code>
						hey
					</code></pre>
					<p><span class="topic">Chaining Methods with Dot Notation.</span> We can execute multiple methods in dot notation by chaining the methods together:</p>
					<pre class="language-java"><code>
						String stringX = "hehe";
						String stringY = stringX.replace("e", "a").toUpperCase(); 

						System.out.println(stringX);
						System.out.println(stringY);
					</code></pre>
					<pre class="language-bash"><code>
						hehe
						HAHA
					</code></pre>
					<p>Whenever we work with strings and want to accomplish a particular task, we should always check the documentation first. More likely than not, there's a method for whatever it is we'd like to do.</p>
					<p><span class="topic">Testing for Equality of Strings.</span> One idiosyncracy with Java is the way it tests the equality of <span class="italicsText">objects</span> (more on objects later). Because strings are objects, we should never test whether two given strings are equal with the <span class="monoText">==</span> operator. Instead, we must use the <span class="monoText">.equals()</span> method.</p>
					<pre class="language-java"><code>
						String one = "hello";
						String two = "hello";
						System.out.println(one == two);

						String three = new String("bye");
						String four = new String("bye");
						System.out.println(three == four);

						String five = new String("sup");
						String six = new String("sup");
						System.out.println(five.equals(six));
 					</code></pre>
					<pre class="language-bash"><code>
						true
						false
						true
					</code></pre>
					<p><span class="exh">Exercise.</span> For the following string, print a character in the string if, and only if, a consecutive character is the same character.</p>
					<pre class="language-java"><code>
						String stringX = "Massachusetts";
					</code></pre>
						<details class="answer">
							<summary>Solution</summary>
							<p>Here is one possible implementation:</p>
							<pre class="language-java"><code>
								String stringX = "Massachusetts"; 
								for (int i = 0; i < stringX.length() - 1; i++) {
									if (stringX.charAt(i) == stringX.charAt(i + 1)) {
										System.out.println(stringX.charAt(i));
									}
								}
							</code></pre>
							<pre class="language-bash"><code>
								s
								t
							</code></pre>
						</details>
					<p><span class="topic"><span class="monoText">char</span> v. <span class="monoText">int</span>.</span> There are some unique characteristics of the primitive type <span class="monoText">char</span> that we cannot do with strings. For starters, every <span class="monoText">char</span> is mapped to an integer value internally (called the <span class="monoText">char</span>'s <span class="italicsText">ASCII</span> value). For example, the <span class="monoText">char</span> value <span class="monoText">'A'</span> is mapped to the integer 65; <span class="monoText">'a'</span> to 97; <span class="monoText">'B'</span> to 66; <span class="monoText">'b'</span> to 98, <span class="monoText">'C'</span> to 67; <span class="monoText">'C'</span> to 99, etc.</p>
					<p>This means we can convert <span class="monoText">char</span> values to <span class="monoText">int</span> values:</p>
					<pre class="language-java"><code>
						System.out.println('a' + 10);
						System.out.println('A' + 'A');
					</code></pre>
					<pre class="language-bash"><code>
						107
						103
					</code></pre>
					<p>This is not something we do often, but we can use this fact to encode strings:</p>
					<pre class="language-java"><code>
						public class foo {
							public static void main(String[] unused) {
								String secretMessage = "Chicken ribs";
								System.out.println("The secret message: " + secretMessage);
								String encoded = "";
								for (int i = 0; i < secretMessage.length(); i++) {
									char ch = secretMessage.charAt(i);
									ch++;
									encoded += ch;
								}
								System.out.println("The encoded message: " + encoded);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						The secret message: Chicken ribs
						The encoded message: Dijdlfo!sjct
					</code></pre>
					<p>In the code above, we looped through each of the characters in the string <span class="monoText">secretMessage</span>, an incremented by 1. This effectively changes the current character to the next character in the ASCII table.</p>
					<p>The encoding approach of shifting every character in a string by a given amount is called a <span class="italicsText">rotation cipher</span>. One famous rotation cipher is the <span class="italicsText">Caesar cipher</span>, named after its famous user, Julius Caesar. In a Caesar cipher, every character in the string is shifted by exactly 13 units (half the Roman alphabet).</p>
					<p>Using this idea, we might help Julius Caesar encode his messages with a function:</p>
					<pre class="language-java"><code>
						public class foo {
							public static void main(String[] args) {
								String message = "In vino veritas";
								String messageEncoded = encode(message, 13);
								System.out.println(messageEncoded);
							}
							static String encode(String message, int key) {
								String encoded = "";
								for (int i = 0; i < message.length(); i++) {
									char ch = message.charAt(i);
									ch += key;
									encoded += ch;
								}
								return encoded;
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						V{-v{|-rvn
					</code></pre>
					<p>Suppose we do not want to convert the spaces in the message. We can do so by simply redefining our method: Include an <span class="monoText">if</span> statement. Here, we want to only shift letters that run from <span class="monoText">'a'</span> to <span class="monoText">'Z'</span>. Since <span class="monoText">char</span> values are integers, we can use the comparison operators. Let's also change the encoding <span class="monoText">key</span> to 5:</p>
					<pre class="language-java"><code>
						public class foo {
							public static void main(String[] args) {
								String message = "In vino veritas";
								String messageEncoded = encode(message, 5);
								System.out.println(messageEncoded);
							}
							static String encode(String message, int key) {
								String encoded = "";
								for (int i = 0; i < message.length(); i++) {
									char ch = message.charAt(i);
									if ('a' <= ch && ch <= 'z') {
										ch += key;
									}
									encoded += ch;
								}
								return encoded;
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Is {nst {jwnyfx
					</code></pre>
					<p>Now, Julius Caesar might not have had curly braces at the time, so let's rewrite our method to ensure only characters appear in the encoded message. Well, we want to keep the characters inside the 26 letters of the Roman alphabet. This means: If the changed character is greater than <span class="monoText">'z'</span>, then we need to go back to <span class="monoText">'a'</span>. How do we do that? Well, there are 26 letters, so &#8220;wrapping around&#8221; implies subtracting 26. Let's also use 13 for <span class="monoText">key</span>, true to spirit:</p>
					<pre class="language-java"><code>
						public class foo {
							public static void main(String[] args) {
								String message = "In vino veritas";
								String messageEncoded = encode(message, 13);
								System.out.println(messageEncoded);
							}
							static String encode(String message, int key) {
								String encoded = "";
								for (int i = 0; i < message.length(); i++) {
									char ch = message.charAt(i);
									if ('a' <= ch && ch <= 'z') {
										ch += key;
										if (ch > 'z') {
											ch -= 26;
										}
									}
									encoded += ch;
								}
								return encoded;
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Ia ivab irevgnf
					</code></pre>
					<p>Great, now we only see Roman letters.</p>
				</section>

				<section id="function_overloading" class="grid-item">
					<h3>Functions Continued</h3>
					<p>In these sections, we address some more topics on functions. In particular, we discuss the concept of <span class="italicsText">overloading</span> and <span class="italicsText">type casting</span>.</p>
					<p><span class="topic">Method Overloading in Java.</span> In previous sections, we said that <span class="italicsText">generally</span>, functions cannot have the same name. We said <span class="italicsText">generally</span> because there is an exception &mdash; overloading:</p>
					<pre class="language-java"><code>
						static int sum(int first, int second) {
							return first + second;
						}
						static double sum(double first, double second) {
							return first + second;
						}
						System.out.println(sum(10, 20));
						System.out.println(sum(10.0, 20.0));
					</code></pre>
					<pre class="language-bash"><code>
						30
						30.0
					</code></pre>
					<p>Notice we have two functions with the same name &mdash; <span class="monoText">sum</span>. The difference? The first function takes two <span class="monoText">int</span> arguments, the second function takes two <span class="monoText">double</span> arguments. Why might this work?</p>
					<p>One hypothesis is that the two functions have different return types. But, it turns out that isn't the case:</p>
					<pre class="language-java"><code>
						static int sum(int first, int second) {
							return first + second;
						}
						static int sum(double first, double second) {
							return (int) first + (int) second;
						}
						System.out.println(sum(10, 20));
						System.out.println(sum(10.0, 20.0));
					</code></pre>
					<pre class="language-bash"><code>
						30
						30
					</code></pre>
					<p>We will discuss the use of <span class="monoText">(int)</span> in a moment. But, we can see that it isn't the return type. Another hypothesis: it's the argument types. And indeed, that is supported by the evidence:</p>
					<pre class="language-java"><code>
						static int sum(int first, int second) {
							return first + second;
						}
						static int sum(int first, int second) {
							return first + second;
						}
						System.out.println(sum(10, 20));
						System.out.println(sum(10, 20));
					</code></pre>
					<pre class="language-bash"><code>
						Line 4: error: method sum(int,int) is already defined in class Main
						static int sum(int first, int second) {
									^
						1 error
					</code></pre>
					<p>Java's error message tells us that we have already defined a method called <span class="monoText">sum</span> that takes two <span class="monoText">int</span> arguments.</p>
					<p>Java uses <span class="term">function signatures</span> to identify functions. The method signature consists of four different components: (1) the return type; (2) the name; and (3) the number of arguments; and (4) the argument types. As long as at least one of these components is different, we can have multiple functions with the same name. The functions above demonstrate a phenomenon called <span class="term">method overloading</span>. This is a type of <span class="italicsText">polymorphism</span>, a topic to be discussed in later sections. We introduce it now as notice of when we encounter it while proceeding.</p>
					<p><span class="topic">Type Casting.</span> In the code above, we had the following line:</p>
					<pre class="language-java"><code>
						return (int) first + (int) second;
					</code></pre>
					<p>This is an example of <span class="term">type casting</span>. Another example of type casting:</p>
					<pre class="language-java"><code>
						static double sum(double first, double second) {
							return first + second;
						}
						System.out.println(sum(10, 20));
					</code></pre>
					<pre class="language-bash"><code>
						30.0
					</code></pre>
					<p>Notice that <span class="monoText">sum</span> takes two arguments of type <span class="monoText">double</span>. We passed it two <span class="monoText">int</span> arguments, and it outputted a <span class="monoText">double</span>. This occurs because we converted the result into <span class="monoText">double</span>. This is called <span class="italicsText">type casting</span>, a feature common to many languages, one of which is Java. Casting can be done by Java, or ourselves:</p>
					<pre class="language-java"><code>
						int i = 1;
						double d = i; // will cast, no data is lost
						i = d // will not cast because we are chopping off a fraction (data is lost)
						i = (int) d; // compel Java to cast anyway
					</code></pre>
					<p>As we can see from above, the general rule is: We can cast data of one type into another type, if and only if no data is lost. However, we can compel Java to perform the cast with the syntax seen in the last line. A key point to understand: There is no rounding when you cast from a float to an integer. That data is simply deleted.</p>
					<p><span class="topic">Argument Validation.</span> Because of type casting, a common function design pattern is to always check the function's arguments at the very top. To do so, we think about all the potentially bad arguments the function can receive from the caller and check accordingly. This is one type of <span class="term">sanity check</span> &mdash; a check on the most basic, foundational assumptions.</p>
					<pre class="language-java"><code>
						int sum(int[] numbers) {
							// sanity check
						}
					</code></pre>
					<p>For example, suppose we wanted to summate all of the numbers in an array:</p>
					<pre class="language-java"><code>
						int sum(int[] numbers) {
							int sum = 0;
							for (int number : numbers) {
							  sum += number;
							}
							return sum;
						}
						int[] arr = {1, 2, 3, 4};
						int arrTotal = sum(arr);
						System.out.println(arrTotal)
					</code></pre>
					<pre class="language-bash"><code>
						9
					</code></pre>
					<p>The function works. But there is an array we can pass that will cause a problem. In Java, the value of an uninitialized array is the value <span class="monoText">null</span> &mdash; the value representing the absence of value. The most dangerous aspect of <span class="monoText">null</span> &mdash; it has no properties of methods we can use. <span class="underlineText">Any</span> attempt to use <span class="monoText">null</span> &mdash; arithmetic, passing it as an argument &mdash; pretty much anything &mdash; will return an error (we say pretty much because there are a few exceptions). We cannot use <span class="monoText">null</span> whatsoever.</p>
					<pre class="language-java"><code>
						int sum(int[] numbers) {
							int sum = 0;
							for (int number : numbers) {
							  sum += number;
							}
							return sum;
						}
						System.out.println(sum(null));
					</code></pre>
					<p>The code above does not work at all. <span class="monoText">null</span> is the value that breaks the function. The reason why <span class="monoText">null</span> is so dangerous (it is often called Oracle's billion dollar mistake) is because every object in Java has a default value of <span class="monoText">null</span>. If we merely declare a variable without initializing, that variable's default value is <span class="monoText">null</span>.</p>
					<p>One of the few exceptions to the prohibition on using <span class="monoText">null</span> is with conditionals:</p>
					<pre class="language-java"><code>
						int sum(int[] numbers) {
							// sanity check:
							if (numbers == null) {
								return 0;
							}
							int sum = 0;
							for (int number : numbers) {
							  sum += number;
							}
							return sum;
						}
						int[] arr = {1, 2, 3, 4};
						int arrTotal = sum(arr);
						System.out.println(arrTotal)
					</code></pre>
					<p>The sanity check above ensures that a valid array is passed in as an argument. That check is done with a conditional: If an array bound to <span class="monoText">null</span> is passed (e.g., an uninitialized array), we return <span class="monoText">0</span>, a common convention for returning errors. Otherwise, continue.</p>
					<p>We should not confuse an array bound to <span class="monoText">null</span> with an empty array. Those are two different entities. An empty array will work just fine, granted it does not actually run through a loop:</p>
					<pre class="language-java"><code>
						int sum(int[] numbers) {
							int sum = 0;
							for (int number : numbers) {
							  sum += number;
							}
							return sum;
						}
						int[] arr = {};
						int arrTotal = sum(arr);
						System.out.println(arrTotal)
					</code></pre>
					<pre class="language-bash"><code>
						0
					</code></pre>
					<p>Of course, we can always check for an empty array:</p>
					<pre class="language-java"><code>
						int sum(int[] numbers) {
							// sanity check:
							if (numbers == null || numers.length == 0) {
								return 0;
							}
							int sum = 0;
							for (int number : numbers) {
							  sum += number;
							}
							return sum;
						}
						int[] arr = {1, 2, 3, 4};
						int arrTotal = sum(arr);
						System.out.println(arrTotal)
					</code></pre>
				</section>

				<section id="multidimensional_data" class="grid-item">
					<h3>Multidimensional Data</h3>
					<p>Arrays can have have multiple dimensions:</p>
					<pre class="language-java"><code>
						// single-dimensional array - size 4

						int[] samples = new int[4];

						// 2-dimensional array
						// first dimension: size 4
						// second dimension: size 8

						char[][] board = new char[4][8]

						// 3-dimensional array
						// first dimension: size 6
						// second dimension: size 8
						// third dimension: size 10

						double[][][] temperature = new double[6][8][10]
					</code></pre>
					<p>As we can see, when we want multidimensional arrays, we indicate how many dimensions there are with square brackets. In all of these arrays, we have metadata. All multidimensional arrays are actually one giant array, with arrays as elements. Thus, the following 4-dimensional array:</p>
					<pre class="language-java"><code>
						int[][][][] deck = new int[12][12][12][12]
					</code></pre>
					<p>is one big array called <span class="monoText">deck</span>, containing four indices: index 0 contains an array of size 12, index 1 contains an array of size 12, index 2 contains an array of size 12, and index 3 contains an array of size 12. In each of the arrays, there too are indices. Perhaps index 0 of the array at index 0 is a clubs of value 2, and 12 an ace, etc. The takeaway: Every multidimensional array is just an array storing arrays.</p>
					<pre class="language-java"><code>
						int[][] arr = new int[4][8];

						int[] arrSlice = arr[0];

						System.out.println(arr.length);
						System.out.println(arrSlice.length);
					</code></pre>
					<pre class="language-bash"><code>
						4
						8
					</code></pre>
					<p>We can also initialize arrays in one line:</p>
					<pre class="language-java"><code>
						// initialize in one line:

						int[][] arr = {
							{ 1, 2 },
							{ 3, 4 }
						};

						// the above initialization is equivalent to:

						int arr = new int[2][2];
						arr[0][0] = 1;
						arr[0][1] = 2;
						arr[1][1] = 3;
						arr[1][2] = 4;
					</code></pre>
					<p>We can easily access values in a multidimensional array with square bracket notation:</p>
					<pre class="language-java"><code>
						int[][] arr = {
							{ 1, 2 },
							{ 3, 4 }
						};

						t = arr[0][0]; // t = 1
						u = arr[0][1]; // u = 2
						v = arr[1][0]; // v = 3
						w = arr[1][1]; // w = 4
					</code></pre>
					<p>Do not, under any circumstances, think of multidimensional arrays as akin to rows and columns. This warning is particularly pertinent to those coming from finance or accounting backgrounds; likely due to years of working with spreadsheets or tables. A better way to think of arrays: A horizontal line of boxes numbered from left to right starting at 0, and each box contains a horizontal line of boxes numbered from left to right starting at 0:</p>
					<figure>
						<img src="images/multi_array.svg" alt="multi-array" loading="lazy" class="sixty-p">
						<figcaption>4-dimensional array; each dimension is of size 3.</figcaption>
					</figure>
					<p><span class="topic">Multi-level Loops.</span> When using multidimensional arrays, we frequently must loop through multiple levels:</p>
					<pre class="language-java"><code>
						for (int i = 0; i < array.length; i++) {
							for (int j = 0; j < array[i].length; j++) {
								System.out.println(array[i][j]);
							}
						}
					</code></pre>
					<p><span class="topic">Why Use Multidimensional Arrays?</span> Numerous pieces of data are conceptually multidimensional arrays. Images, for example, can be thought of as multidimensional arrays. There are numerous pixels, with every pixel containing colors. Those pixels in turn have a position, which, when placed in a particular order (i.e., an array), an image is produced.</p>
					<p>Chronological weather data (e.g., climate change models) is particularly dependent on the concept of multidimensional arrays. Each day contains hours, and at each hour, there might be temperatures.</p>
					<p>Recorded sound relies on the concept of multidimensional arrays. There are units of time, and in each unit of time, there are pressure measurements. Those units of time themselves are stored in an array of size two: the left ear and the right ear.</p>
				</section>

				<section id="compilation_java" class="grid-item">
					<h3>Compiling in Java</h3>
					<p>In languages like Java, these lower level implementations are abstracted away by the language, so we need not worry about them. This is in contrast to languages like C and even more strikingly, Assembly, where the low level details are front and forward. In these next sections, we pop the hood: What actually happens when we execute Java code?</p>
					<p>From a bird's eye view, when we execute Java code, there are two steps: (1) <span class="italicsText">compilation</span> and (2) <span class="italicsText">execution</span>.</p>
					<p><span class="topic">Compilation.</span> Once we tell the computer to run Java code, the Java source code (what we've written) is <span class="italicsText">compiled</span> to a simpler representation called <span class="italicsText">Java bytecode</span> by a program called the compiler. More specifically, the <span class="italicsText">Java Compiler</span> (called <span class="monoText">javac</span>). We call this transformation &mdash; going from source code to Java bytecode &mdash; <span class="term">compilation</span>. The code has not executed yet. It is simply being transformed into bytecode.</p>
					<p>If we get errors at this stage, they are called <span class="term">compilation errors</span>. And if the source code does not compile, it will not execute. Compilation errors are essentially violations of Java's language conventions &mdash; syntax rules, naming rules, rules for writing expressions, data type rules, etc. Whenever we use Java, or any language for that matter, we effectively enter into a contract with the compiler: I will follow the compiler's rules, and in return, the compiler will compile.</p>
					<p>This is a key difference between Java and languages like C. Java was one of the first languages that required a transformation of source code into bytecode <span class="italicsText">before</span> proceeding to the next stage, <span class="term">execution</span>. No computer processor can run Java bytecode. That bytecode must proceed still proceed to the next stage.</p>
					<p>To compile Java code in a shell, we use the <span class="monoText">javac</span> key word. Suppose, for example, we have the following code in a file called <span class="monoText">foo.java</span>:</p>
					<pre class="language-java"><code>
						System.out.println("Hello world!");
					</code></pre>
					<p>To compile this, we write:</p>
					<pre class="language-bash"><code>
						javac foo.java

						foo.java:1: error: class, interface, enum, or record expected
						System.out.println("Hello world!");
						^
						1 error
					</code></pre>
					<p>We get an error. This is because our Java code violated a compiler rule &mdash; we must place our code inside a <span class="italicsText">class</span> and inside a <span class="italicsText">method</span> inside that class (we will explore this in more detail in later sections). Thus, our code must be written as:</p>
					<pre class="language-java"><code>
						public class foo {
							public static void main(String args[]) {
								System.out.println("Hello world!");
							}
						}
					</code></pre>
					<p>Now when we execute the code above, we don't get any error messages. But, we don't see any output. This is a good sign for compiling a program &mdash; everything turned out ok. But, we can see there's a new file inside working directory:</p>
					<pre class="language-bash"><code>
						ls

						foo.class
						foo.java
					</code></pre>
					<p>We see file called <span class="monoText">foo.class</span>. That wasn't there before (we didn't create that file ourselves). What is that file? Well, we could <span class="monoText">cat</span> the file, but it would display numerous lines of unreadable code. Fortunately, Java provides an operator we can use to display a human-readable version:</p>
					<pre class="language-bash"><code>
						javap -c foo.class

						Compiled from "foo.java"
						public class foo {
						public foo();
							Code:
								0: aload_0
								1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
								4: return

						public static void main(java.lang.String[]);
							Code:
								0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
								3: ldc           #13                 // String Hello world!
								5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
								8: return
						}
					</code></pre>
					<p><span class="topic">Execution.</span> The Java bytecode is executed by another program, called the <span class="italicsText">Java Virtual Machine</span> (JVM, or what we have personified, and refer to anthropomorphically, as &#8220;Java&#8221;).</p>
					<p>The errors that occur at this stage are called <span class="term">runtime errors</span>. In contrast to compilation errors, runtime errors are all those errors that are not caught by the compiler:</p>
					<pre class="language-java"><code>
						String s = null;
						System.out.println(s.length());
					</code></pre>
					<pre class="language-bash"><code>
						Exception in threat "main" java.lang.NullPointerException
							at line 2
					</code></pre>
					<p>These statements comply with the compiler's rules &mdash; there are no blatant violations of the Java language. But, there are violations to a more powerful entity &mdash; logic. Here, we initialized a string to <span class="monoText">null</span> &mdash; we effectively told Java, &#8220;Hey, this is a string called <span class="monoText">S</span>, and it has no value.&#8221; Then, right after that, we told Java, &#8220;Remember that string <span class="monoText">S</span>? Yeah, give me that string's length.&#8221; The Java compiler does not have a problem with this, because its only job is to transform the source code into bytecode. So, the compiler translates it, and sends it off to the Java virtual machine. Once there, Java throws us back the error above.</p>
					<p>We can think of the compiler and JVM as an English-speaking lawyer trying to draft a contract in French with the assistance of two other lawyers. The English-speaking lawyer writes a first draft, and sends it over to the French-speaking lawyer. That lawyer &mdash; the compiler &mdash; translates the contract into French. This lawyer will flag English words that do not directly translate. Once this lawyer is done, the translated draft is sent to the other lawyer (JVM), an expert in French contract law. That lawyer reviews substance &mdash; the contract's underlying logic.</p>
					<p>We might ask, why doesn't the French-speaking lawyer just catch the mistakes in the first place? This is a perfectly reasonable question, and it is a point of discussion among those concerned with the lower-level implementations of Java. Why doesn't the Java compiler just catch these runtime errors in the first place?</p>
					<p>This question has led to numerous commentary and research attempting to answer the question: How do we transform runtime errors into compiler errors? However, there is an argument for keeping these errors separate. Compiler errors are errors that are never actually seen by the user. They are also errors that should not exist at all before the code is released to hundreds, if not thousands, of people for use. Runtime errors, however, are those that will be seen by users &mdash; crashes, freezes, delays, etc. These types of errors may not be immediately apparent at compilation because it is difficult to think of every possible scenario. For this reason, it is often best that runtime errors are kept separate, to be left for users to report back to the developers in the form of product reviews and system reports.</p>
					<p>However, this is not to say that every runtime error should be classified as a runtime error. Runtime errors like the above, assigning <span class="monoText">null</span> to a variable and performing operations with that variable, are so blatantly illogical and nonsensical statement that they arguably should be caught by the compiler. In other words, there are runtime errors that result from statements that never have any legitimate use, and for that reason, should be caught by the compiler as early as possible.</p>
					<p>That aside, to execute the code above, we write:</p>
					<pre class="language-bash"><code>
						java foo

						Hello world!
					</code></pre>
					<p>Everytime we execute Java code in a shell, we must recompile if there are any revisions to the source code.</p>
					<p><span class="topic">Bytecode v. Machine Code.</span> The difference between Java and languages like C is that the code is translated into bytecode, which is the code actually executed. (As an aside, JVM, the program that translates Java source code into bytecode, is written in <span class="monoText">C++</span>). In C, the source code is compiled into <span class="term">machine code</span> &mdash; the symbols the actual CPU or processor can understand and execute.</p>
					<p>At the time, Java's approach was particularly innovative. In the olden days (about thirty years ago in computer science terms), computers all had different processors. Apple used PowerPC processors, Dell used Intel, Acers used AMD, etc. These processors all spoke different machine languages. Thus, if you compiled a program into machine code on an Apple computer and it executed perfectly, there was no guarantee it would do the same on a Lenovo.</p>
					<p>Bytecode was the solution to this problem. The <span class="monoText">foo.class</span> file from the examples above could be sent to anyone, who would then be able to run the program on their machine, regardless of processor, as long as they had the Java Virtual Machine program (this is why we often see numerous popups on our computers to update Java). This was a groundbreaking approach, embodied in the language's motto, &#8220;Write One, Run Anywhere.&#8221; In providing a feature many languages lacked, Java's implementers effectively cemented the language's place among the most widely-used. Today, Java keeps its place as the de facto language for the most widely used mobile operating system &mdash; Android</p>
					<p>Where the interpreter was the battle ground of years past, the future is compilers. At the end of the day, these are simply programs. And as computers have gotten faster, so too have compilers. The competition today is to make compilers as fast as possible, to the point where we can do away with interpreters.</p>
				</section>

				<section id="objects_in_java" class="grid-item">
					<h3>Objects in Java</h3>
					<p>All of the topics covered thus far are concepts we can collect into our programming toolbox and use as needed. Indeed, a substantial part of being a programmer is discovering new concepts to add to that toolbox. We now introduce another concept &mdash; <span class="italicsText">objects</span>.</p>
					<p>Objects are placed in the tool slot for data structures &mdash; objects are one possible approach for organizing data. More specifically, they allow us to create custom <span class="italicsText">types</span>. So far, we have only used primitive types &mdash; the types Java provides by default. Objects give us a way to have more types.</p>
					<p>Recall: How do we structure good programs? So far, we've seen one approach: Using <span class="italicsText">functions</span> &mdash; break down the program into smaller, reusable, testable, and understandable pieces. Objects give us a second approach: Combining <span class="italicsText">state</span> and <span class="italicsText">behavior</span> &mdash; modeling data (state) and what we can do with that data (behavior).</p>
					<p>Creating objects is a strenous exercise of creativity, imagination, holistic thinking, and intuition. This is in contrast to implementing functions, which often involves logic, fact analysis, and computation. This is because implementing objects depends much more heavily on design, rather than sequences of steps.</p>
					<p><span class="topic">What is an object?</span> Objects are data structures that combine <span class="italicsText">state</span> (e.g., variables; storing information) and <span class="italicsText">behavior</span> (e.g., functions; what things we can do with that stored information). </p>
					<p>For something to be an object, it must answer the following questions: (1) What does it store? In other words, what <span class="italicsText">state</span>, or information, does this thing store? (2) What does it do? What sort of functionality does the thing provide?</p>
					<p>We've seen one object repeatedly, strings. Strings have a state: They store values of type <span class="monoText">char</span>, along with those values' respective indices. Strings also have functions (called <span class="italicsText">methods</span>) that operate on all strings: indexing, concatentation, slicing, upper-casing, etc. Thus, strings satisfy the definition of an object: (1) they store data, and (2) they implement algorithms.</p>
					<p><span class="topic">Objects in Java.</span> In the discussion above, we used the term &#8220;object&#8221; loosely. To be very specific, an <span class="italicsText">object</span> is an instance of a <span class="term">class</span> &mdash; a representation of real-world objects. An object is simply one instance of that class. For example, <span class="monoText">reptile</span> is a class, and <span class="monoText">crocodile</span> is an instance of that class. Of course, <span class="monoText">crocodile</span> itself can be a class, with <span class="monoText">Nile crocodile</span> and <span class="monoText">Saltwater crocodiles</span> as instances of that class. An individual saltwater crocodile would be instance of <span class="monoText">Saltwater crocodiles</span>. Thus, as a matter of logic, classes are objects, but not all objects are classes.</p>
					<p><span class="topic">Class in Java.</span> A <span class="term">class</span> in Java determines how a particular <span class="italicsText">type</span> of object will behave. We can think of a class as a blueprint that creates object instances of a particular type.</p>
					<p>Analogously, we can think of a class as a statute that defines certain persons. For example, metaphysically, there is no such thing as an &#8220;asylum seeker&#8221; (epistemology and philosophy of language aside). Such an entity exists only because of the definition provided by 8 U.S.C.  1158. Absent that statute, there are no asylum seekers. If a person is an asylum seeker, there are certain things we can do with that person, separating it from other persons &mdash; we can allow them to obtain certain visas, they can follow special tracks to obtaining a Green Card, there are certain things the federal government cannot do with them, etc. The same concept underlies classes in programming.</p>
					<p>Here is an example of a <span class="italicsText">class declaration</span> creating a new type called <span class="monoText">Person</span>:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							int age;
							void printName() {
								System.out.println(this.name);
							}
						}
					</code></pre>
					<p>When we define a class, we start with the special keyword <span class="monoText">class</span>. Then we give it a name, in this case, <span class="monoText">Person</span>. As a matter of convention, class names are capitalized.</p>
					<p>After the name, we have a block, the class definition's body. Inside that block, we have pieces of data and algorithms. In the example above, the body says: every instance of <span class="monoText">Person</span>, i.e., every object of type <span class="monoText">Person</span>, has a <span class="monoText">name</span>, a piece of data of type <span class="monoText">String</span>, and an <span class="monoText">age</span>, a piece of data of type <span class="monoText">int</span>. This is the <span class="italicsText">state</span> that every object of type <span class="monoText">Person</span> stores.</p>
					<p>Furthermore, every object of type <span class="monoText">Person</span> can perform an algorithm called <span class="monoText">printName()</span>. This is the <span class="italicsText">behavior</span> that every object of type <span class="monoText">Person</span> stores. In the method's definition, we indicate that the method takes no arguments, and returns nothing (<span class="monoText">void</span>). Recall that <span class="monoText">void</span> is a special type, used only with method declarations to indicate the method does not return anything.</p>
					<p>A word of caution: Unlike languages like Python and JavaScript, Java classes <span class="underlineText">cannot</span> be modified after the program is compiled. This means that if we needed to make a change to a class definition, we must recompile the program before execution. This can be frustrating when writing smaller pieces of code, but it is particularly useful once we start dealing with very large programs.</p>
					<p><span class="topic">The <span class="topic">new</span> Keyword.</span> In the previous sections, we often used the keyword <span class="monoText">new</span>, and we stated we would discuss it in later sections. Now that we've introduced objects, we can begin that discussion. An <span class="term">instance</span> of a class is an object of the type created by that class. To create an instance, we must use the <span class="monoText">new</span> keyword:</p>
					<pre class="language-java"><code>
						// create a new type called Person

						class Person {
							String name;
							int age;
							void printName() {
								System.out.println(this.name);
							}
						}

						// create an object of type Person
						
						Person adam = new Person();
					</code></pre>
					<p>The type <span class="monoText">Person</span> can be used just like how an <span class="monoText">int</span> or <span class="monoText">char</span> is are used, but we must use the keyword <span class="monoText">new</span>.</p>
					<p><span class="topic">Getting and Setting an Object's State and Methods.</span> Like many other object-oriented languages, the states and behaviors of Java objects are accessed and set using <span class="term">dot notation</span>:</p>
					<pre class="language-java"><code>
						// create a new type called Person
						class Person {
							String name;
							int age;
							void printName() {
								System.out.println(this.name);
							}
						}

						// create an object of type Person
						Person adam = new Person();

						// set the instance variables
						adam.age = 40;
						adam.name = "Adam";

						// use the instance variables
						System.out.println(adam.age);

						// call the method
						adam.printName();
					</code></pre>
					<pre class="language-bash"><code>
						40
						Adam
					</code></pre>
					<p><span class="topic">Instance Variables.</span> With classes, we can use instance variables that are of <span class="italicsText">primitive types</span> or of <span class="italicsText">types we've created</span>. This ability allows us to create classes of varying complexity:</p>
					<pre class="language-java"><code>
						class Dimensions {
							int length;
							int width;
							int height;
						}
						class Room {
							String name;
							Dimensions dimensions;
						}
						Room diningRoom = new Room();
						diningRoom.dimensions = new Dimensions();
						diningRoom.dimensions.length = 50;
						diningRoom.dimensions.width = 20;
						diningRoom.dimensions.height = 40;
					</code></pre>
					<p>Why might we write a separate class for dimensions? Well, rooms aren't the only things with dimensions. Windows, tables, cabinets, closets, these all have dimensions. We don't want to repeat ourselves.</p>
					<p><span class="topic">Class Instances and the Value <span class="monoText">null</span>.</span> If we create a new class instance without initializing its instance variables, those instance variables have a default value of <span class="monoText">null</span>. This is a common Java feature that confuses those new to the language.</p>
					<pre class="language-java"><code>
						class Dimensions {
							int width;
							int height;
						}
						class Room {
							String name;
							Dimensions dimensions;
						}
						Room diningRoom = new Room();
						System.out.println(diningRoom.dimensions.width);
					</code></pre>
					<pre class="language-bash"><code>
						null
					</code></pre>
					<p><span class="topic">Methods.</span> The methods we define in a class have access to the variables defined <span class="italicsText">inside</span> that class; i.e., the instance variables. Thus:</p>
					<pre class="language-java"><code>
						class Dimensions {
							int width;
							int height;

							int area() {
								System.out.println(width);
								return width * height;
							}
						}
						Dimensions example = new Dimensions();
						example.width = 10;
						example.height = 20;
						Dimensions second = new Dimensions();
						second.width = 20;
						second.height = 20;
						System.out.println(example.area());
						System.out.println(second.area());
					</code></pre>
					<pre class="language-bash"><code>
						10
						200
						20
						400
					</code></pre>
					<p><span class="topic">The <span class="monoText">this</span> Keyword.</span> The <span class="monoText">this</span> keyword is a special variable used to refer to the instance of the class. Thus, when we define a method, we use <span class="monoText">this</span> to refer to the instance's instance variables.</p>
					<pre class="language-java"><code>
						class Dimensions {
							int width;
							int height;

							int area() {
								return this.width * this.height;
							}
						}
					</code></pre>
					<p>Unlike many other programming languages, we do not <span class="italicsText">have</span> to use the <span class="monoText">this</span> keyword. We can, but because the method has access to the instance variables, the keyword is not necessary.</p>
				</section>

				<section id="constructors_and_visibility" class="grid-item">
					<h3>Constructors</h3>
					<p>Up until this point, we've been purposefully hiding certain parts of the Java program:</p>
					<pre class="language-java"><code>
						public class foo {
							public static void main(String[] unused) {
								System.println("Hello, world!")
							}
						}
					</code></pre>
					<p>We avoided discussing things like <span class="monoText">class</span>, <span class="monoText">public</span>, and <span class="monoText">static</span> to prevent overcomplicating introductory matters. Now that we've seen classes, however, we can address these mysterious symbols.</p>
					<p>In Java, everything we write <span class="underlineText">must</span> be inside a class. In the code above, we have class called <span class="monoText">foo</span>. The name <span class="monoText">foo</span> is the name of the <span class="monoText">.java</span> file containing the code. Inside the class <span class="monoText">foo</span>, we have a method called <span class="monoText">main</span>. The method is called <span class="monoText">main</span> because that is where all of our actual, executed code is placed. It effectively tells Java, &#8220;Start here.&#8221;</p>
					<p>When we actually define classes, we place them outside the <span class="monoText">foo</span> class:</p>
					<pre class="language-java"><code>
						class Dimensions {
							public int width;
							public int height;

							public int area() {
								return width * height;
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Dimensions firstRoom = new Dimensions();
								firstRoom.width = 10;
								firstRoom.height = 20;

								Dimensions secondRoom = new Dimensions();
								secondRoom.width = 8;
								secondRoom.height = 4;

								System.out.println(firstRoom.area());
								System.out.println(secondRoom.area());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						200
						32
					</code></pre>
					<p>What exactly is <span class="monoText">String[]</span> and <span class="monoText">args[]</span>? These parameters must be placed inside the <span class="monoText">main()</span> method because we they serve as placeholder variables for when arguments are passed into the overall program itself. Those arguments are placed in an array. We will further develop this point in later sections. We will also speak at greater lengths in later sections what the symbol <span class="monoText">public</span> means, but for now: The <span class="monoText">public</span> keyword tells Java that a particular object is visible to all other classes (i.e., all other classes can access that particular object, whether its a variable or a method). Again, we will elaborate on these points as we continue.</p>
					<p><span class="topic">Default Values for Instance Variables.</span> Note that we can set default values for instance variables. This is particularly useful when we know an instance variable should have a value, but for whatever reason, either we or a user fail to provide that value:</p>
					<pre class="language-java"><code>
						class Dimensions {
							public int width = 1;
							public int height = 1;

							public int area() {
								return width * height;
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Dimensions firstRoom = new Dimensions();
								firstRoom.width = 10;
								firstRoom.height = 20;

								Dimensions secondRoom = new Dimensions();

								System.out.println(firstRoom.area());
								System.out.println(secondRoom.area());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						200
						1
					</code></pre>
					<p>Notice that we did not define instance variables for the object <span class="monoText">secondRoom</span>, but an area was returned because the instance variables are assigned the value <span class="monoText">1</span> by default.</p>
					<p><span class="topic">Constructors: What Happens when an Object is Created?</span> Whenever we create a new instance of a class, we use the keyword <span class="monoText">new</span>. Notice, however, that when we create the instance, it almost looks like a method call:</p>
					<pre class="language-java"><code>
						Dimensions example = new Dimensions();
					</code></pre>
					<p>The parentheses are included because calling a method is precisely what happens when we create an object. Every new object is created through a special method in Java called a <span class="term">constructor</span>. When a new class is created, the constructor in the code below is executed:</p>
					<pre class="language-java"><code>
						class Course {
							String name;

							// This is a constructor
							Course(String setName) {
								name = setName;
							}
						}
					</code></pre>
					<p>A constructor is called <span class="underlineText">exactly once</span> &mdash; when the class is first created. There is no way to call it again later. It also does not explicitly return anything other than the instance of the class.</p>
					<p>There is something odd about the constructor method: There is no return type. The method does not have a return type because it will always return just one thing &mdash; an instance of the class. As such, there is no reason or need for the constructor to have a return type. Furthermore, the method shares the same name as the class. This is a syntax requirement for constructors.</p>
					<p>We use constructors because they allow us to be much more specific when we initialize a class. For those familiar with Python, constructors are the Java equivalent of <span class="italicsText">default arguments</span>. Java's approach to this feature is undoubtedly much worse than Python's, but we must make do.</p>
					<p>If we do not define a constructor, Java will define a constructor for us:</p>
					<pre class="language-java"><code>
						class Course {
							String name;
						}

						// The above is the same as:

						class Course {
							String name;
							Course() {

							}
						}
					</code></pre>
					<p>The most important point with respect to constructors: The constructor <span class="underlineText">must</span> return a new instance of the class.</p>
					<pre class="language-java"><code>
						class Course {
							String name;
							Course(String setName) {
								name = setName;
								// But what if name is invalid?
							}
						}
					</code></pre>
					<p>Because of this requirement, under no circumstances can a constructor fail. This is a point of more than mild annoyance for Java programmers, because it effectively means there is no way to perform argument validation within a constructor itself other than with errors and exceptions.</p>
					<p>Constructors, however, provide a useful way to ensure arguments are provided:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person();
								System.out.println(bill.name);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						null
					</code></pre>
					<p>We get back <span class="monoText">null</span> because we did not initialize the instance variable <span class="monoText">name</span>. To ensure this does not occur, we can use a constructor:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person() {
								name = "name_uninitialized";
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person();
								System.out.println(bill.name);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						name_uninitialized
					</code></pre>
					<p>Notice that in the examples above, we've had to reference the static variable each time for initialization:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person() {
								name = "name_uninitialized";
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person();
								bill.name = "Bill";
								System.out.println(bill.name);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Bill
					</code></pre>
					<p>It would be much easier if we could just pass that name as an argument when we first create the instance. Something that looks like this:</p>
					<pre class="language-java"><code>
						Person bill = new Person("Billy");
					</code></pre>
					<p>To do so, we must use a constructor that takes a name as an argument:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person(String setName) {
								name = setName;
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person("Bill");
								System.out.println(bill.name);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Bill
					</code></pre>
					<p>Great, it worked. As we can see, if we want to create new instances with their instance variables initialized by passing arguments into the method, we can do so with a constructor.</p>
					<p>Note that if we do not pass an argument into <span class="monoText">Person()</span> when we create a new instance, we will see an error message:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person(String setName) {
								name = setName;
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person("Bill");
								System.out.println(bill.name);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						foo.java:10: error: constructor Person in class Person cannot be applied to given types;
								Person bill = new Person();
												^
						required: String
						found:    no arguments
						reason: actual and formal argument lists differ in length
						1 error
					</code></pre>
					<p>This is a very helpful error message, because it tells us where we went wrong &mdash; we forget to pass a necessary argument into <span class="monoText">Person()</span>. This feature also shows another aspect of constructors: As we soon as we define a constructor, we automatically lose the default constructor.</p>
					<p>Since our <span class="monoText">Person</span> class also has an instance variable <span class="monoText">age</span>, we should probably also require an <span class="monoText">age</span> argument:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person(String setName, double setAge) {
								name = setName;
								age = setAge;
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person("Bill", 32.5);

								System.out.println(bill.name);
								System.out.println(bill.age);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Bill
						32.5
					</code></pre>
					<p><span class="topic">Default Values for Instance Variables.</span> Suppose we want to allow creating a new instance of <span class="monoText">Person</span> even if an <span class="monoText">age</span> argument is not provided. To do so, we can simply write another constructor without the <span class="monoText">age</span> parameter:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person(String setName, double setAge) {
								name = setName;
								age = setAge;
							}
							Person(String setName) {
								name = setName;
								age = 0.0;
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person("Bill");

								System.out.println(bill.name);
								System.out.println(bill.age);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Bill
						0.0
					</code></pre>
					<p>We can shorten the code above by simply writing:</p>
					<pre class="language-java"><code>
						class Person {
							String name;
							double age;

							Person(String setName, double setAge) {
								name = setName;
								age = setAge;
							}
							Person(String setName) {
								this(setName, 0.0);
							}
						}

						public class foo {
							public static void main(String[] args[]) {
								Person bill = new Person("Bill");

								System.out.println(bill.name);
								System.out.println(bill.age);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Bill
						32.0
					</code></pre>
				</section>

				<section id="getters_and_setters" class="grid-item">
					<h3>Getters and Setters</h3>
					<p>Let's continue our study of objects by further refining what we've learned so far. Here, we will address the notion of <span class="italicsText">access modifiers</span>, <span class="italicsText">getters</span>, and <span class="italicsText">setters</span>.</p>
					<p><span class="topic">Access Modifiers.</span> Consider the following code:</p>
					<pre class="language-java"><code>
						class Person {
							public String name;
							private int age;

							private void printName() {
								System.out.println(name);
							}
							
							public int getAge() {
								return age;
							}
						}
					</code></pre>
					<p>There are a few symbols in the code above that we have been actively avoiding &mdash; <span class="monoText">public</span> and <span class="monoText">private</span>. What are these symbols and what do they mean?</p>
					<p>These symbols are called <span class="term">access modifiers</span>. They are provided by Java as a way to control <span class="italicsText">access</span> to a class's instance variables and methods.</p>
					<p>Access modifiers are provided because is often the case that (a) we do want certain information hidden, or (b) we do not want the information accessed unless the seeker undergoes a particular process. Accordingly, the two main kinds of access modifiers are (i) <span class="italicsText">variable access modifiers</span> and (ii) <span class="italicsText">method access modifiers</span>. In Java, access modifiers <span class="underlineText">always</span> go to the left of the type as a matter of convention.</p>
					<p><span class="topic"><span class="monoText">public.</span></span> The symbol <span class="monoText">public</span>, when used as a variable access modifier, tells Java that the relevant variable can be modified by anyone. In the context of our <span class="monoText">Person</span> class, we wrote: <span class="monoText">public String name</span>. This essentially tells Java, &#8220;Anything anyone can modify the instance variable <span class="monoText">name</span> using dot notation.&#8221;</p>
					<p><span class="topic"><span class="monoText">private.</span></span> In contrast, when the symbol <span class="monoText">private</span> is used as a variable access modifier, then the relevant variable can be accessed and modified <span class="underlineText">only if</span> the access or modification is done with a method defined on that class. Thus, when we wrote <span class="monoText">private int age</span>, we told Java: &#8220;The instance variable <span class="monoText">age</span> is <span class="monoText">private</span> &mdash; stop anyone that tries to access or modify <span class="monoText">age</span> with anything other than a <span class="monoText">Person</span> method.&#8221;</p>
					<figure><img src="images/public_v_private.png" alt="public v. private" loading="lazy" class="fifty-p"></figure>
					<p>Thus, if we or another user want to modify the instance variable <span class="monoText">age</span>, we must include a method in <span class="monoText">person</span> that allows accessing and modifying <span class="monoText">age.</span> Accordingly, the code below will not work:</p>
					<pre class="language-java"><code>
						class Person {
							// anyone and anything can modify name
							public String name;

							// age can only be read and written with this class's methods
							private int age;
						}

						public class foo {
							public static void main(String[] unused) {
								Person lukas = new Person();
								lukas.name = "Lukas";

								// this returns a compilation error
								System.out.println(lukas.age);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						foo.java:9: error: age has private access in Person
								System.out.println(lukas.age);
																^
						1 error
					</code></pre>
					<p>Believe it or not, it is rare for Java programs to have public variables. We will see why in later sections. Thus, in summary:</p>
					<div class="compare">
						<div>
							<p class="subheading"><span class="monoText">public</span></p>
							<p>Every person can read and write the variable.</p>
						</div>
						<div>
							<p class="subheading"><span class="monoText">private</span></p>
							<p>A person can read and write the variable <span class="underlineText">only if</span> the person uses a method defined for the variable's class.</p>
						</div>
					</div>
					<p><span class="topic">Method Access Modifiers.</span> Access modifiers work the same way with methods. The difference: Rather than reading and writing, the privilege is whether we can call the method.</p>
					<p>A <span class="italicsText">public method</span> is one that we can call at any time. However, a <span class="italicsText">private method</span> cannot be called unless another method in the class is used to call it. In other words, we can call a private method <span class="underlineText">only if</span> we use another method in the class. Thus, if we are in another method in the class marked as <span class="topic">public</span> that allows calling the <span class="monoText">private</span> method, then we can call the <span class="monoText">private</span> method.</p>
					<p><span class="topic">Getting Around <span class="monoText">private</span> Access Modifiers.</span> Suppose we have the following code:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private int age;
						}

						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient();
							}
						}
					</code></pre>
					<p>We want to keep the two variables, <span class="monoText">name</span> and <span class="monoText">age</span>, private. However, we also want to be able to quickly set the <span class="monoText">name</span> and <span class="monoText">age</span> when we create the new instance of <span class="monoText">Patient</span>, <span class="monoText">jekyll_hyde</span>. One way to do so is to use a constructor:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private int age;

							Patient(String setName, int setAge) {
								name = setName;
								age = setAge;
							}
						}

						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
							}
						}
					</code></pre>
					<p>The code above compiles successfully. However, the <span class="monoText">name</span> and <span class="monoText">age</span> are still hidden because they are private. Suppose we want to be able to verify <span class="monoText">jekyll_hyde</span>'s name. One way to do so is to use a public method:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private int age;

							Patient(String setName, int setAge) {
								name = setName;
								age = setAge;
							}

							public void printPatientInfo() {
								System.out.println("Patient name: " + name);
								System.out.println("Patient age: " + age);
							}
						}

						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
								jekyll_hyde.printPatientInfo();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Patient name: Jekyll Hyde
						Patient age: 50
					</code></pre>
					<p>Because we can work around private access variables with methods, we can obtain the values bound to variable access variables with public methods:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private int age;

							Patient(String setName, int setAge) {
								name = setName;
								age = setAge;
							}

							public String getName() {
								return name;
							}
						}

						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
								String jekyll_hyde_name = jekyll_hyde.getName();
								System.out.println(jekyll_hyde_name);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Jekyll Hyde
					</code></pre>
					<p>We might note this seems like a lot of work just to obtain the name. Why go through the trouble of writing a method just for obtaining the name when we can just use dot notation? We go through this trouble to ensure we keep two actions separate as possible: <span class="italicsText">setting</span> an instance variable, and <span class="italicsText">getting</span> an instance variable. By marking an instance variable <span class="monoText">private</span>, we place a hurdle on attempts to modify the value bound to that instance variable.</p>
					<p>Why place a hurdle? Because we generally do not want instance variables to change as the program runs. The issue is not so much with a user modifying the variable directly as it is writing code that will affect, or indirectly modify, the value bound to the instance variable. Indirect and unintended modifications can easily lead to bugs that are difficult to pinpoint.</p>
					<p>If, for whatever reason, we want to have the ability to modify the name <span class="italicsText">after</span> its been set, we can write another public method:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private int age;

							Patient(String setName, int setAge) {
								name = setName;
								age = setAge;
							}

							public String getName() {
								return name;
							}

							public void setName(String setName) {
								name = setName;
							}
						}

						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
								System.out.println(jekyll_hyde.getName());

								jekyll_hyde.setName("Harvey Dent");
								System.out.println(jekyll_hyde.getName());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Jekyll Hyde
						Harvey Dent
					</code></pre>
					<p>The distinction between setting an instance variable and getting a value bound to an instance variable introduces the distinction between <span class="term">getters</span> and <span class="term">setters</span>.</p>
					<p><span class="topic">Qualfying Setters.</span> If we provide methods that allow modifying initialized variable instances, we might want to further restrict the modification. We can do so inside the setter. For example, unless the patient is Benjamin Button, we might want to ensure negative numbers are not passed into an <span class="monoText">age</span> setting method:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private int age;

							Patient(String setName, int setAge) {
								name = setName;
								age = setAge;
							}

							public String getName() {
								return name;
							}
							public int getAge() {
								return age;
							}

							public void setName(String setName) {
								name = setName;
							}

							public void setAge(int setAge) {
								if (setAge > 0) {
									age = setAge;
								}
							}
						}

						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient("Jekyll Hyde", 50);
								jekyll_hyde.setAge(-85);
								System.out.println(jekyll_hyde.getAge());
								jekyll_hyde.setAge(55);
								System.out.println(jekyll_hyde.getAge());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						50
						55
					</code></pre>
					<p>Notice <span class="monoText">setAge(-85)</span> did not actually set the age to <span class="monoText">-85</span>. We qualified the setter with a conditional: Java, set the age only if the provided argument is greater than <span class="monoText">0</span>.</p>
					<p>Getters and setters are the way we get around hurdles <span class="monoText">public</span> and <span class="monoText">private</span>. Good style in Java: always use <span class="monoText">private</span> for instance variables, and use <span class="monoText">public</span> methods to access the instance variables. <span class="italicsText">Getters</span> are the methods we use to read, or retrieve, values bound to instance variables, and <span class="italicsText">setters</span> are the methods we use to bind new values to instance variables.</p>
					<p>Getters and setters allow us to create <span class="italicsText">reactive objects</span> &mdash; objects that react to changes made to its instance variables. They also allow us to create read- and write-only variables:</p>
					<pre class="language-java"><code>
						class Patient {
							private String name;
							private String firstName;
							private String lastName;
						
							public void setName(String setName) {
								String[] nameParts = setName.split(" ");
								name = setName;
								firstName = nameParts[0];
								lastName = nameParts[1];
							}
						
							public String getName() {
								return name;
							}
							public String getFirstName() {
								return firstName;
							}
							public String getLastName() {
								return lastName;
							}
						
						}
						
						public class foo {
							public static void main(String[] unused) {
								Patient jekyll_hyde = new Patient();
								jekyll_hyde.setName("Jekyll Hyde");
								System.out.println(jekyll_hyde.getFirstName());
								System.out.println(jekyll_hyde.getLastName());
								System.out.println(jekyll_hyde.getName());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Jekyll
						Hyde
						Jekyll Hyde
					</code></pre>
					<p>The code above, of course, is flawed (names do not just consist of first and last; there are middle names, suffixes, ordinals, and eponyms).</p>
					<p><span class="topic">The <span class="monoText">static</span> Keyword.</span> When we prepend the <span class="monoText">static</span> symbol to an instance variable or method, we tell Java: &#8220;This variable or method belongs to the <span class="italicsText">class</span>, not to a specific instance of this class.&#8221; For example, we might see the following:</p>
					<pre class="language-java"><code>
						class Philosopher {
							private String name;
							private String field_of_study;
							private static int count = 0;
							Philosopher(String setName, String set_field_of_study) {
								name = setName;
								field_of_study = set_field_of_study;
							}
							public void printNameAndField() {
								System.out.println("Name: " + name);
								System.out.println("Field: " + field_of_study);
							}
						}
						
						public class foo {
							public static void main(String[] unused) {
								Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
								kant.printNameAndField();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Name: Immanuel Kant
						Field: metaphysics
					</code></pre>
					<p>We've seen the symbol <span class="monoText">static</span> numerous times. This symbol is similar to <span class="monoText">public</span> and <span class="monoText">private</span> in that it acts as an access modifier. The difference: When attach the <span class="monoText">static</span> modifier to a variable or method, there is one, and only one, &#8220;copy&#8221; of that variable or method. That copy exists only inside the class itself, not with any instance of the class.</p>
					<p>There is a specific order for where to include the symbol <span class="monoText">static</span>. Access modifiers like <span class="monoText">private</span> and <span class="monoText">public</span> are placed leftmost, then the modifier <span class="monoText">static</span>, then the <span class="monoText">type</span>.</p>
					<p><span class="topic">Static Methods.</span> One of the most common uses for <span class="monoText">static</span> is with <span class="italicsText">static methods</span>. For those familiar with JavaScript, we might have noticed tutorials referring to JavaScript's primitive math object as containing <span class="italicsText">static properties</span> and <span class="italicsText">static methods</span>. These correspond to Java's static variables and static methods. </p>
					<p>A <span class="term">static method</span> is a method that can be called <span class="underlineText">without</span> an instance of that class. For example, in the code below, we have a static variable called <span class="monoText">count</span>, and at every new instance of the class <span class="monoText">Philosopher</span>, we increment <span class="monoText">count</span>. Then, we have a static method called <span class="monoText">printPhilosopherCount()</span> that prints the current value bound to <span class="monoText">count</span>.</p>
					<pre class="language-java"><code>
						class Philosopher {
							private String name;
							private String field_of_study;
							private static int count = 0;
							Philosopher(String setName, String set_field_of_study) {
								name = setName;
								field_of_study = set_field_of_study;
								count++;
							}
							public void printNameAndField() {
								System.out.println("Name: " + name);
								System.out.println("Field: " + field_of_study);
							}
						}
						
						public class foo {
							public static void main(String[] unused) {
								Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
								kant.printNameAndField();
								Philosopher.printPhilosopherCount();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Name: Immanuel Kant
						Field: metaphysics
						1
					</code></pre>
					<p>Notice that the static method <span class="monoText">printPhilosopherCount()</span> executed without referencing a particular instance of the class <span class="monoText">Philosopher</span>. This is because it is a method that belongs only to the class <span class="monoText">Philosopher</span>, and as such, does not depend on an instance to execute. If we create multiple instances:</p>
					<pre class="language-java"><code>
						class Philosopher {
							private String name;
							private String field_of_study;
							private static int count = 0;
							Philosopher(String setName, String set_field_of_study) {
								name = setName;
								field_of_study = set_field_of_study;
								count++;
							}
							public static void printPhilosopherCount() {
								System.out.println(count);
							}
							public void printNameAndField() {
								System.out.println("Name: " + name);
								System.out.println("Field: " + field_of_study);
							}
						}
						
						public class foo {
							public static void main(String[] unused) {
								Philosopher kant = new Philosopher("Immanuel Kant", "metaphysics");
								Philosopher godel = new Philosopher("Kurt Godel", "logic");
								Philosopher locke = new Philosopher("John Locke", "political theory");
								Philosopher kierkegaard = new Philosopher("Soren Kierkegaard", "existentialism");
								Philosopher hart = new Philosopher("Herbert Hart", "jurisprudence");
								Philosopher.printPhilosopherCount();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						5
					</code></pre>
					<p>And if we create no instances:</p>
					<pre class="language-java"><code>
						class Philosopher {
							private String name;
							private String field_of_study;
							private static int count = 0;
							Philosopher(String setName, String set_field_of_study) {
								name = setName;
								field_of_study = set_field_of_study;
								count++;
							}
							public static void printPhilosopherCount() {
								System.out.println(count);
							}
							public void printNameAndField() {
								System.out.println("Name: " + name);
								System.out.println("Field: " + field_of_study);
							}
						}
						
						public class foo {
							public static void main(String[] unused) {
								Philosopher.printPhilosopherCount();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						0
					</code></pre>
					<p>The static method is a method that can be called without any instance of its class. This ability implies a limitation: Because static methods work outside of instances, they <span class="underlineText">cannot access</span> non-static instance variables. This in turn means we cannot use the keyword <span class="monoText">this</span>.</p>
					<p>Static methods are found throughout not just Java, but object-oriented languages as a whole. In Java, there are numerous <span class="term">packages</span> (Java's equivalent for <span class="italicsText">libraries</span> in C and <span class="italicsText">modules</span> in Python) containing static methods. One such package is the <span class="monoText">Math</span> package, which contains static methds like <span class="monoText">Math.sqrt(${n}$)</span>, where ${n}$ is the radicand.</p>
					<p><span class="topic">Static Variables.</span> Like, but somewhat different, to static methods, <span class="term">static variables</span> are variables shared by <span class="italicsText">all</span> instances of a given class. Thus, in our example <span class="monoText">Philosopher</span> class, the variable <span class="monoText">count</span> is shared by every instance of <span class="monoText">Philosopher</span>.</p>
					<p>As aforementioned, languages like JavaScript refer to these as <span class="italicsText">static properties</span>. For example, the value ${\sqrt{2}}$ is so commonly used in computation that we might want to provide it as a static variable. Indeed, Java has packages that provide such quick access. However, static variables are by and large extremely uncommon in Java programming. Generally, a task that requires a static variable can more than likely be accomplished through another means. One use for a static variable is something like a <span class="monoText">count</span>, intended to track how many instances of a given class there are.</p>
					<p><span class="topic">Not Marking a Method or Variable <span class="monoText">static.</span></span> If we do not indicate that a variable of method is <span class="monoText">static</span>, then by default, every instance of the class (a) has a copy of that variable, and (b) the method will only work on a particular instance of that class.</p>
					<p><span class="topic">Use Cases for Static Variables.</span> The most common use case for static variables is creating constants. In Java programs, this use case is often identifiable when the <span class="monoText">static</span> symbol is used alongside the <span class="monoText">final</span> symbol:</p>
					<pre class="language-java"><code>
						class Physics {
							public static final float ACCELERATION_GRAVITY = 9.807;
						}
					</code></pre>
					<p>The symbol <span class="monoText">final</span> tells Java: Under absolutely no circumstances can the variable <span class="monoText">ACCELERATION_GRAVITY</span> be modified. Any attempt, direct or indirect, to modify a final variable will return an error.</p>
					<p>Thus, the variable declaration above essentially communicates: (1) This is a public variable, so you can access, but because it is a final variable, you cannot modify. (2) This is a static variable, so there is only one copy, and it stays here in <span class="monoText">Physics</span>. If you want to use it, you will have to call <span class="monoText">Physics</span> first.</p>
					<p>Notice further that in Java, final variables (i.e., constants) are written in snake casing (underscores indicating spaces).</p>
				</section>

				<section id="inheritance_in_java" class="grid-item">
					<h3>Inheritance</h3>
					<p>In this section, we study the concept of <span class="italicsText">inheritance</span>. Inheritance provides a means of accomplishing two useful outcomes: (1) avoiding duplicated code, and (2) expressing real world relationships between data.</p>
					<p>Consider the following code:</p>
					<pre class="language-java"><code>
						class MythChar { };

						public class foo {
							public static void main(String[] unused) {
								MythChar hera = new MythChar(); 
								System.out.println(hera.toString());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						MythChar@7344699f
					</code></pre>
					<p>There was no error &mdash; it compiled and ran correctly, even if we neglected to explicitly define the body of the class <span class="monoText">MythChar</span>. No error is returned because of Java's principle of <span class="term">inheritance</span> &mdash; every object, or instance, inherits both <span class="italicsText">state</span> and <span class="italicsText">behavior</span> from another class. Inheritance exists because in the real world, data follows hierarchy &mdash; Every koala is a marsupial, every marsupial is a mammal, every mammal is an animal, etc.</p>
					<p>So, for example:</p>
					<pre class="language-java"><code>
						class MythChar {
							protected String name;
							protected String type;
						
							public void printMetadata() {
								System.out.println("This is an object of type " + type + " named " + name);
							}
						}
						
						class GreekMythChar extends MythChar {
							GreekMythChar(String setName) {
								name = setName;
								type = "GreekMythChar";
							}
						}
						
						
						public class foo {
							public static void main(String[] unused) {
								GreekMythChar hera = new GreekMythChar("Hera"); 
								hera.printMetadata();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						This is an object of type GreekMythChar named Hera
					</code></pre>
					<p>There are some new symbols in the code above, and we will address them in a moment. For now, observe that (1) every new instance of <span class="monoText">MythChar</span> has an instance variable called <span class="monoText">name</span> and another instance variable called <span class="monoText">type</span>; (2) every new instance of <span class="monoText">MythChar</span> has an instance method called <span class="monoText">printMetadata()</span>, which prints a string communicating the instance's <span class="monoText">name</span> and <span class="monoText">type</span>.</p>
					<p>Then, we have another class definition. This class is called <span class="monoText">GreekMythChar</span>, followed by <span class="monoText">extends MythChar</span>. Then, we have a constructor. But, there is something unusual about this constructor: We do not have any instance variables before the constructor, but we are initializing variables inside the constructor. How is this possible? Again, inheritance.</p>
					<p>By including <span class="monoText">extends</span> to the class definition for <span class="monoText">GreekMythChar</span>, we are effectively telling Java that <span class="monoText">GreekMythChar</span> is a subclass of <span class="monoText">MythChar</span>. Because <span class="monoText">GreekMythChar</span> is a subclass of <span class="monoText">MythChar</span>, all the instance and class variables and methods contained in <span class="monoText">MythChar</span> are available for <span class="monoText">GreekMythChar</span>. They are <span class="italicsText">inherited</span> from <span class="monoText">MythChar</span>.</p>
					<p>Notice that <span class="monoText">GreekMythChar</span> has a special relationship to <span class="monoText">MythChar</span> &mdash; it is a subset of mythological figures. We might have another subclass called <span class="monoText">NorseMythChar</span> and another one called <span class="monoText">CelticMythChar</span>. These two classes are collectively referred to as the <span class="italicsText">children</span> of <span class="monoText">MythChar</span>, and <span class="monoText">MythChar</span> is said to be the <span class="italicsText">parent</span> of the subclasses. The keyword we use for establishing these relationships is <span class="monoText">extends</span>.</p>
					<p>Java allows multiple inheritance. All of the classes shifted towards the left inherit all of the instance and class variables and methods of the classes to the right. All of the classes that a subclass inherits from are collectively called the subclass's <span class="italicsText">ancestors</span>, and all of the classes that a parent class provides behaviors to as the parent class's <span class="italicsText">descendants</span>:</p>
					<pre class="language-java"><code>
						public class MythChar {}
							public class GreekMythChar extends MythChar {}
								public class Olympian extends GreekMythChar {}
								public class Titan extends GreekMythChar {}
									public class Titanide extends Titan {}
									public class Titaness extends Titan {}
								public class Gigantes extends GreekMythChar {}
					</code></pre>
					<p>In Java, a class can only extend <span class="underlineText">one</span> parent class. In other words, we cannot have a subclass with two parent classes. We will revisit this concept and limitation again in later sections.</p>
					<p>A word of warning: If we ever find ourselves writing deeply nested classes like the above, we must ask ourselves whether inheritance is the proper approach to the problem, or whether the distinctions between parent and child are meaningful. Particularly tall inheritance trees can very easily open the gates to <span class="italicsText">inheritance hell</span> &mdash; the point where so many subclasses are created that the programmer loses track of an object's behavior and the states it stores.</p>
					<p><span class="topic">What Does <span class="monoText">protected</span> Mean?</span> One new access modifier we saw from the example above is <span class="monoText">protected</span>. Recall that a public variable can be read or written by anyone, and a private variable can only be read or written using methods defined by the private variable's class. A <span class="italicsText">protected variable</span> is a variable that can only be read or written using methods that are (a) defined by the protected variable's class, or (b) defined by a descendent of the protected variable's class.</p>
				</section>

				<section id="file_processing" class="grid-item">
					<h3>File Processing in Java</h3>
					<p>On a computer, a <span class="term">file</span> is just a storage unit that keeps data together. We can think of it as a big storage container, housing numerous pieces of data. With a file, we can do several things: we can <span class="italicsText">read</span>, <span class="italicsText">write</span>, <span class="italicsText">save</span>, or <span class="italicsText">destroy</span> the file.</p>
					<p><span class="topic">Creating File Objects.</span> To use files in a program, we must use a <span class="italicsText">file object</span>. The first step to doing so is using Java's built-in input output package:</p>
					<pre class="language-java"><code>
						import java.io.*;
					</code></pre>
					<p>Suppose we want to create a <span class="monoText">File</span> object to retrieve information about a file on our drive. We can write:</p>
					<pre class="language-java"><code>
						File f = new File("foo.txt");
						if (f.exists() && f.length() > 1000) {
							f.delete();
						}
					</code></pre>
					<p>There are a number of methods that come with <span class="monoText">File</span> objects:</p>
					<figure class="table">
						<table class="loop_table">
							<thead>
								<th>Method</th>
								<th>Description</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">f.canRead()</span></td>
									<td>Returns <span class="monoText">true</span> if the file can read</td>
								</tr>
								<tr>
									<td><span class="monoText">f.delete()</span></td>
									<td>Removes file from disk</td>
								</tr>
								<tr>
									<td><span class="monoText">f.getName()</span></td>
									<td>Returns the file's name.</td>
								</tr>
								<tr>
									<td><span class="monoText">f.length()</span></td>
									<td>Returns the number of <span class="italicsText">bytes</span> in the file.</td>
								</tr>
								<tr>
									<td><span class="monoText">f.renameTo(file)</span></td>
									<td>Changes name of a file.</td>
								</tr>
							</tbody>
						</table>
						<p><span class="topic">The <span class="monoText">Scanner</span> Object.</span> Suppose we have a file, called <span class="monoText">vroom.txt</span>, and another file called <span class="monoText">foo.java</span>, containing our program. We want to read the contents of <span class="monoText">vroom.txt</span> into the program. To do so, we use a <span class="monoText">Scanner</span> object:</p>
						<pre class="language-java"><code>
							import java.util.*; // import Scanner

							File file = new File("vroom.txt");
							Scanner input = new Scanner(file);

							// The above code can be written in one line:
							Scanner input = new Scanner(new File("vroom.txt"));
						</code></pre>
						<p>The <span class="monoText">Scanner</span> class includes several methods. The most useful of which are:</p>
						<figure class="table">
							<table class="loop_table">
								<thead>
									<th>Method</th>
									<th>Description</th>
								</thead>
								<tbody>
									<tr>
										<td><span class="monoText">sc.nextLine()</span></td>
										<td>reads and returns a one-line <span class="monoText">String</span> from the file.</td>
									</tr>
									<tr>
										<td><span class="monoText">sc.next()</span></td>
										<td>reads and returns a one-word <span class="monoText">String</span> from the file.</td>
									</tr>
									<tr>
										<td><span class="monoText">sc.nextInt()</span></td>
										<td>reads and returns an <span class="monoText">int</span> from the file.</td>
									</tr>
									<tr>
										<td><span class="monoText">sc.nextDouble()</span></td>
										<td>reads and returns an <span class="monoText">double</span> from the file.</td>
									</tr>
									<tr>
										<td><span class="monoText">sc.hasNextLine()</span></td>
										<td>returns <span class="monoText">true</span> if there are anymore lines in the file.</td>
									</tr>
								</tbody>
							</table>
						</figure>
					</figure>
				</section>

				<section id="polymorphism" class="grid-item">
					<h3>Polymorphism</h3>
					<p>In the previous sections, we saw how objects provide us a way to package state and behavior, and organize it into a hierarchy. A fair question to ask: Why organize objects into hierarchy? Because humans generally prefer viewing and understanding things in terms of sets and subsets. Humans are in the category of mammals, some humans are in the category of doctors, others mechanics, carpenters, stay-at-home parents, students, teachers, etc. Within doctors there are cardiologists, pathologists, neurosurgeons, and more. Within students there are those that study physics and those that study theology. Organizing objects hierarchically is an attempt to mimic this preference.</p>
					<p>In the real world, when a set contains multiple subsets, there is usually something members of the subsets have in common that warrants their membership in the superset other than being a subset. For example, an LLC and a C Corporation are all subsets of business entities, but both entities are citizens of a particular jurisdiction (e.g., a C Corporation incorporated in Delaware is a Delaware citizen, while an LLC formed in New York is a New York citizen). Similarly, an LLC and a general partnership are business entities, and while they differ in how they are formed, they are generally taxed in a similar manner (passthrough entities).</p>
					<p>Because of these shared characteristics, we often want a member of one subset to be able to act as if they were members of another subset. A California-born student at the University of Washington at Tacoma should be able to vote in California once they become a resident of the state. That particular student is a member of many subclasses &mdash; University of Washington at Tacoma students; California-born persons; American citizens; Washington citizens, etc.</p>
					<p>However, recall that in Java, classes are parthenogenetic &mdash; a subclass can only extend one parent class; no subclass can ever have more than one parent. How then do we accomplish the preceding phenomenon, where objects of one class might <span class="italicsText">behave</span> like the objects of another class? Through <span class="italicsText">polymorphism</span>.</p>
					<p><span class="topic">The Java Object.</span> To understand polymorphism, we need to clarify a common point of confusion. As we've stated before, everything in Java must be wrapped in a class. Now, because classes can only extend one parent class, there necessarily must be something at the very root of it all. It cannot be turtles all the way down. Indeed, there is a root &mdash; the Java Object. Every class in Java inherits from the Java Object. We will discuss in more detail what this Object is in later sections, but for now, the key point is: When we use the term Object with a capital "O," we are referring to the Java Object, rather than object we have created.</p>
					<pre class="language-java"><code>
						public class Chemicals { }

						// The class declaration above is equivalent to:
						
						public class Chemicals extends Object { }

						// We do not have to write this^ line
						// Java assumes this is the case when we do not include an extends symbol
					</code></pre>
					<p>This means that every state and method of a newly declared class inherits from Object. Does it inherit all of Object's states and methods? No. The class inherits a small number of the states and methods. Some of the most important methods inherited from Object are the following:</p>
					<figure class="table">
						<table class="loop_table">
							<thead>
								<th>Object Method</th>
								<th>Description</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">String toString()</span></td>
									<td>Return a <span class="monoText">String</span> representing the instance. This is used primarily for debugging.</td>
								</tr>
								<tr>
									<td><span class="monoText">boolean equals(object_1 object_2)</span></td>
									<td>Return a <span class="monoText">boolean</span> indicating whether <span class="monoText">object_1</span> is the same as <span class="monoText">object_2</span>.</td>
								</tr>
								<tr>
									<td><span class="monoText">int hashCode()</span></td>
									<td>Return an <span class="monoText">int</span> uniquely representing an object's contents (more on this later).</td>
								</tr>
							</tbody>
						</table>
					</figure>
					<p>The methods inherited from <span class="monoText">Object</span> are very rarely used. This is because classes can <span class="italicsText">override</span> methods inherited from their ancestors, using their own instead.</p>
					<pre class="language-java"><code>
						public class bar {
							public static void main(String[] args) {
								Apache geronimo = new Apache();
								geronimo.name = "Geronimo";
								System.out.println(geronimo.toString());
							}
						}

						class NativeAmerican {}

						class SouthwestNative extends NativeAmerican {
							public String name;
						}

						class Apache extends SouthwestNative {
							public String toString() {
								return name + " is an Apache.";
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Geronimo is an Apache.
					</code></pre>
					<p>Notice that we created an instance of the class <span class="monoText">Apache</span>, and initialized its instance variable <span class="monoText">name</span> to <span class="monoText">"Geronimo"</span>. How are we allowed to do this when there is no such instance variable in the class <span class="monoText">Apache</span>? Because <span class="monoText">Apache</span> inherits everything from its ancestors. The class <span class="monoText">SouthwestNative</span> is an ancestor of <span class="monoText">Apache</span>, and as such, all instances of <span class="monoText">Apache</span> have an instance variable called <span class="monoText">name</span> that can be initialized.</p>
					<p>The same goes for the <span class="monoText">toString()</span> method. When we called that method with the instance <span class="monoText">geronimo</span>, Java went and checked if the <span class="monoText">Apache</span> class contained such a method and verified that it is <span class="monoText">public</span>. If no such method existed, then Java would check the parent, <span class="monoText">SouthwestNative</span>; otherwise <span class="monoText">NativeAmerican</span>; otherwise <span class="monoText">Object</span>.</p>
					<p>What this means then is that if we included another <span class="monoText">toString()</span> method definition in a parent class (while keeping the <span class="monoText">toString()</span> method inside the subclass, Java will not go any further to execute the <span class="monoText">toString()</span> method in the parent class. Java stops and runs either (a) the method's definition in the instance's class itself, or (b) the nearest ancestor defining the method. In other words, it stops the moment it encounters a <span class="monoText">toString()</span> method it can use.</p>
					<p>On the other hand, this also means that a parent class cannot access variables in its child classes. Suppose for example we had the following:</p>
					<pre class="language-java"><code>
						public class bar {
							public static void main(String[] args) {
								NativeAmerican geronimo = new NativeAmerican();
								geronimo.name = "Geronimo";
								System.out.println(geronimo.bisonHunting);
							}
						}
						class NativeAmerican {}
						class SouthwestNative extends NativeAmerican {
							public String name;
						}
						class Apache extends SouthwestNative {
							public boolean bisonHunting = true;
							public String toString() {
								return name + " is an Apache.";
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						bar.java:4: error: cannot find symbol
											geronimo.name = "Geronimo";
														^
						symbol:   variable name
						location: variable geronimo of type NativeAmerican
						bar.java:5: error: cannot find symbol
											System.out.println(geronimo.bisonHunting);
																				^
						symbol:   variable bisonHunting
						location: variable geronimo of type NativeAmerican
						2 errors
					</code></pre>
					<p>We see two compilation errors: (1) Java cannot find the variable <span class="monoText">name</span>; (2) Java cannot find the variable <span class="monoText">bisonHunting</span>. This is because <span class="monoText">geronimo</span> is an instance of <span class="monoText">NativeAmerican</span>, but the variables <span class="monoText">name</span> and <span class="monoText">bisonHunting</span> are part of the <span class="monoText">Apache</span> class. If we wanted to see these variables, then we must use the <span class="monoText">Apache</span> class:</p>
					<pre class="language-java"><code>
						public class bar {
							public static void main(String[] args) {
								Apache geronimo = new Apache();
								geronimo.name = "Geronimo";
								System.out.println(geronimo.bisonHunting);
							}
						}
						class NativeAmerican {}
						class SouthwestNative extends NativeAmerican {
							public String name;
						}
						class Apache extends SouthwestNative {
							public boolean bisonHunting = true;
							public String toString() {
								return name + " is an Apache.";
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						true
					</code></pre>
					<p>We learn a key less from these examples and principles: If we have more instance variables at the top of the inheritance tree, then we have more subclasses in the hierarchy. If we have more instance variables at the bottom of the inheritance tree, then we must provide more specific behaviors (methods) for the subclasses.</p>

					<p><span class="topic">The <span class="monoText">super</span> Keyword.</span> Subclasses can access a constructor inside their parent class. This is done by using the <span class="monoText">super</span> keyword:</p>

					<pre class="language-java"><code>
						public class bar {
							public static void main(String[] args) {
								Gas argon = new Gas("argon");
								System.out.println(argon.name);
							}
						}
						
						class Inorganic {
							protected String type;
							Inorganic(String setType) {
								type = setType;
							}
						}
						class Gas extends Inorganic {
							public String name;
							Gas(String setName) {
								super("Gas");
								name = setName;
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						argon
					</code></pre>

					<p>In the code above, we called the constructor defined in <span class="monoText">Inorganic</span>, the superclass of <span class="monoText">Gas</span>. When we use the symbol <span class="monoText">super</span>, it <span class="underlineText">must</span> be the first thing we do.</p>

					<p><span class="topic">Polymorphism.</span> <span class="italicsText">Polymorphism</span> is the provision of a single interface to entities of different types. In others, polymorphism is the phenomenon where a single entity of one type, such as an object, can act as if it were an entity of another, or multiple other, types. We see this all the time. A pet tiger may be loving and caring, acting truly like a domesticated animal in one moment, but then turning to their wild side and slaughtering their owner the next. Some ethnicities are the majority population in one area, while being a minority in another. A person is a student by day and a bartender by night.</p>
					<p><span class="topic">Subtype Polymorphism.</span> Necessarily, in order to be a member of two different types, the entity must actually <span class="italicsText">be</span> a member of two different types. In Java, every object (except for <span class="monoText">Object</span>) is an instance of at least two types: (1) whatever class we have defined the object to be in; and (2) an object of <span class="monoText">Object</span> (the <span class="monoText">Java Object</span>). Of course, a particular object can be more than that if it is part of an <span class="italicsText">class tree</span>. For example:</p>

					<pre class="language-java"><code>
						class Animal {
							public void drinkWater() {
								System.out.println("gulp gulp gulp")
							}
						}
						class Reptile extends Animal {
							public void layEgg() {
								System.out.println("bloop bloop")
							}
						}

						/* 

						We can think of the above as: 
							Reptile extends Animal extends Object

						Thus:
							Reptile behaves like an Animal, and
							Reptile also behaves like an Object 

						*/
					</code></pre>

					<p>Every object of type <span class="monoText">reptile</span> is an instance of three different types: (1) the class <span class="monoText">Object</span>; (2) the class <span class="monoText">Animal</span>; and the class <span class="monoText">Reptile</span>. Given an object of type <span class="monoText">Reptile</span>, it has a method called <span class="monoText">layEgg()</span>. As an <span class="monoText">Animal</span>, it has a method called <span class="monoText">drinkWater()</span>. As an <span class="monoText">Object</span>, it has a method called <span class="monoText">toString()</span>.</p>

					<p><span class="topic">Upcasting.</span> Because objects can be a member of multiple classes, Java provides the ability to <span class="term">upcast</span> &mdash; automatically allowing an object to behave like an object of an ancestor type:</p>
					<pre class="language-java"><code>
						class Animal {}
						class Reptile extends Animal {
							public String toString() {
								return "Reptilian";
							}
						}
						public class bar {
							public static void main(String[] args) {
								Reptile gator = new Reptile();
								Animal dragon = new Animal();
								bar.printAnything(gator);
								bar.printAnything(dragon);
							}
							public static void printAnything(Object toPrint) {
								System.out.println(toPrint.toString());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Reptilian
						Animal@6b95977
					</code></pre>

					<p>Pay close attention to the output. Those are the outputs from the statements <span class="monoText">bar.printAnything(gator)</span> and <span class="monoText">bar.printAnythng(dragon)</span>. We passed as arguments into those methods the objects <span class="monoText">gator</span> and <span class="monoText">dragon</span>. What is the method <span class="monoText">printAnything()</span>? It is the method defined inside the class <span class="monoText">bar</span>. And in that definition, we pass it one argument: an object <span class="monoText">toPrint</span> of type <span class="monoText">Object</span>. Let's focus first on <span class="monoText">gator</span>.</p>
					<p>The object <span class="monoText">gator</span> is an instance of <span class="monoText">Reptile</span>, but here it is being used as an object of type <span class="monoText">Object</span>. Nevertheless, it is also an object of type <span class="monoText">Reptile</span>. Inside the class definition for <span class="monoText">Reptile</span>, we overrode the <span class="monoText">toString()</span> method: Rather than follow <span class="monoText">Object</span>'s default definition, return the string <span class="monoText">"Reptilian"</span>. So, when we pass in <span class="monoText">gator</span> into the <span class="monoText">printAnything()</span> method, we really wrote <span class="monoText">gator.toString()</span>. This is why we see the output <span class="monoText">Reptilian</span>.</p>

					<p>Now, let's look at <span class="monoText">dragon</span>. When we pass in <span class="monoText">dragon</span> as an argument, we really wrote <span class="monoText">dragon.toString()</span>. The object <span class="monoText">dragon</span> is an object of type <span class="monoText">Object</span>. But, it is also an object of type <span class="monoText">Animal</span>. The class <span class="monoText">Animal</span> provides no override of the <span class="monoText">toString()</span> method. So, Java moves up the class tree, and goes to <span class="monoText">Object</span>. There, it applies the <span class="monoText">toString()</span> method as defined there, and we get back <span class="monoText">Animal@6b95977</span>. This is the default definition of <span class="monoText">toString()</span> &mdash; it tells us that there is an instance of <span class="monoText">Animal</span> at the memory reference <span class="monoText">6b95977</span>.</p>

					<p>Notice that we wrote <span class="monoText">bar.printAnything()</span> to call the method <span class="monoText">printAnything()</span>. Why? Because <span class="monoText">printAnything()</span> is a method defined in the class <span class="monoText">bar</span>. This is all evidence of <span class="italicsText">polymorhpism</span>.</p>
					<p>As an aside, we might ask, how is the <span class="monoText">printAnything()</span> method called when it is below the <span class="monoText">main()</span> method? This is a perfectly fair question, particularly for those coming from a Python background. In Python, a program structured in this manner is almost certain to return an error. This is because Python's evaluation model interprets then executes code line-by-line, top to bottom. In languages like Java, however, the code is first compiled then executed. Thus, the positioning of methods and classes alone will not prohibit execution. (Note that compiling is not necessarily what allows Java to avoid relative positioning; C, for example, requires the use of prototypes for <span class="monoText">struct</span>s defined at the bottom of a source code file).</p>

					<p><span class="topic">Downcasting.</span> Where <span class="italicsText">upcasting</span> allows an object to behave as if it were an object of an ancestor type, <span class="term">downcasting</span> allows an object to behave as if it were an object of a descendent type. <span class="underlineText">But</span> only if the instance is actually the appropriate subtype. If the instance is not an appropriate subtype, then Java will return a runtime error.</p>
					<pre class="language-java"><code>
						class Animal {}
						class Reptile extends Animal {
							public String toString() {
								return "Reptilian";
							}
						}
						public class bar {
							public static void main(String[] args) {
								Object gator = new Reptile();
								bar.printAnything(gator);
								Animal gatorAsAnimal = (Animal) gator;
								bar.printAnything(gatorAsAnimal);
							}
							public static void printAnything(Object toPrint) {
								System.out.println(toPrint.toString());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						Reptilian
						Reptilian
					</code></pre>
					<p>Here, we created an object named <span class="monoText">gator</span> of type <span class="monoText">Reptile</span> (whenever we are unsure of what type an object is, we always look to the right of the symbol <span class="monoText">new</span>). Notice, however, that we declared the variable <span class="monoText">gator</span> to be of type <span class="monoText">Object</span>. What is going on here?</p>
					<p>This is an example of performing an immediate upcast. We create an instance of <span class="monoText">Reptile()</span>, but we save it in a variable of type <span class="monoText">Object</span>. This is perfectly valid because it is an upcast &mdash; every instance <span class="monoText">Reptile</span> is an instance of <span class="monoText">Object</span>.</p>
					<p>The more interesting point is our creation of <span class="monoText">gatorAsAnimal</span>. That variable is of type <span class="monoText">Animal</span>. We assign to that variable the object <span class="monoText">gator</span>, but we prepend it with <span class="monoText">(Animal)</span>. This is a downcast. Why are we allowed to do this? Because <span class="monoText">gator</span> is an instance of <span class="monoText">Object</span>. And since it is an instance of <span class="monoText">Object</span>, an ancestor of <span class="monoText">Animal</span>, we can cast <span class="monoText">gator</span> downwards as an instance of <span class="monoText">Animal</span>.</p>
					<p>The tool: If we upcast an object, we can always downcast the object back to where we started. But, we can only cast an object that the casted object is related to. We cannot cast a <span class="monoText">String</span> object into an <span class="monoText">Animal</span> or <span class="monoText">Reptile</span> object, because <span class="monoText">Animal</span> and <span class="monoText">Reptile</span> are unrelated to <span class="monoText">String</span>.</p>
					<p><span class="topic">Verifying an Instance's Class.</span> A useful operator provided by Java is the <span class="monoText">instanceOf</span> operator, which returns a Boolean value to the question: Is this particular instance an instance of this particular class? Thus:</p>
					<pre class="language-java"><code>
						class Animal {}
						class Reptile extends Animal {
							public String toString() {
								return "Reptilian";
							}
						}
						public class bar {
							public static void main(String[] args) {
								Reptile gator = new Reptile();
								Animal dragon = new Animal(); 
								System.out.println(gator instanceof Animal);
								System.out.println(gator instanceof Reptile);
								System.out.println(dragon instanceof Reptile);
								System.out.println(dragon instanceof Animal);
							}
							public static void printAnything(Object toPrint) {
								System.out.println(toPrint.toString());
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						true
						true
						false
						true
					</code></pre>
					<p><span class="topic">Inheritance and Methods.</span> Consider the following:</p>
					<pre class="language-java"><code>
						class Animal {}
						class Lion extends Animal {
							public void roar() {
								System.out.println("roar");
							}
						}
						class Cobra extends Animal {
							public void hiss() {
								System.out.println("hiss");
							}
						}

						public class bar {
							public static void main(String[] args) {
								Animal bubu = new Animal();
								Lion lulu = new Lion();
								Cobra momo = new Cobra();
							}
						}
					</code></pre>
					<p>In the code above, we have two methods called <span class="monoText">roar()</span> and <span class="monoText">hiss()</span>. The <span class="monoText">roar()</span> method is defined in the subclass <span class="monoText">Lion</span>, and the <span class="monoText">hiss()</span> method is defined in the subclass <span class="monoText">Cobra</span>. Both <span class="monoText">Cobra</span> and <span class="monoText">Lion</span> are subclasses of <span class="monoText">Animal</span>. Of the instances we created, <span class="monoText">bubu</span> cannot call these methods. Why? Because <span class="monoText">bubu</span> is of class <span class="monoText">Animal</span>, and <span class="monoText">Animal</span> has no methods <span class="monoText">roar()</span> and <span class="monoText">hiss()</span>. But what if we want <span class="monoText">momo</span> to be an instace of <span class="monoText">Lion</span>, but at the same time, we want to keep the variable containing <span class="monoText">momo</span> to remain <span class="monoText">Animal</span>? Well, we can use a conditional:</p>
					<pre class="language-java"><code>
						class Animal {
							public void speak() {
								if (this instanceof Lion) {
									Lion me = (Lion) this;
									me.roar();
								} else if (this instanceof Cobra) {
									Cobra me = (Cobra) this;
									me.hiss();
								}
							}
						}
						class Lion extends Animal {
							public void roar() {
								System.out.println("roar");
							}
						}
						class Cobra extends Animal {
							public void hiss() {
								System.out.println("hiss");
							}
						}
						
						public class bar {
							public static void main(String[] args) {
								Animal bubu = new Lion();
								bubu.speak();
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						roar
					</code></pre>
					<p>In the code above, we created a new method called <span class="monoText">speak()</span>. That method behaves differently depending on what object is passed into it as an argument. That object, however, is an instance of <span class="monoText">Animal</span>. This means that the symbol <span class="monoText">this</span> refers to an instance of <span class="monoText">Animal</span>, so to call the <span class="monoText">roar()</span> and <span class="monoText">hiss()</span> methods, we must <span class="italicsText">downcast</span> the object argument. This is why we create a new variable (and by convention, naming the variable <span class="monoText">me</span>).</p>
 				</section>

				<section id="object_references" class="grid-item">
					<h3>Object References</h3>
					<p>The idea of a <span class="italicsText">reference</span> is not unique to Java. It occurs across many programming languages. References are also a useful way to clarify any vagueness in polymorphism.</p>
					<p>Consider the following code and its output:</p>
					<pre class="language-java"><code>
						class PhysConst {
							public String name;
							public double val;
							PhysConst(String setName, double setValue) {
								name = setName;
								val = setValue;
							}
							public String toString() {
								return name;
							}
						}
						
						public class bar {
							public static void main(String[] args) {
								// block (a)
								int first = 0;
								int second = first;
								second = 8;
								System.out.println(first + " " + second);
						
								// block (b)
								PhysConst otherConst = new PhysConst("Gas Constant", 8.31);
								PhysConst gasConst = otherConst;
								gasConst.name = "Molar Gas Constant";
								System.out.println(otherConst + " " + gasConst);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						0 8
						Molar Gas Constant Molar Gas Constant
					</code></pre>
					<p>How does this code work? In <span class="monoText">block (a)</span>, we declare a variable called <span class="monoText">first</span>, of type <span class="monoText">int</span>. Then, we assign to that variable the integer value <span class="monoText">0</span>. Next, we declare a variable called <span class="monoText">second</span>, also of type <span class="monoText">int</span>, and we initialize it to the value <span class="monoText">first</span>, which is itself initialized to <span class="monoText">0</span>. Then, we changed the value bound to <span class="monoText">second</span> now it is <span class="monoText">8</span>. As expected, when we print the values, we see <span class="monoText">0</span> and <span class="monoText">8</span>. This is in line with what we know about assignment.</p>
					<p>But it seems that <span class="monoText">block (b)</span> works differently, even though it looks similar. We declared a variable of type <span class="monoText">PhysConst</span>, then assigned to it the object created by calling the <span class="monoText">PhysConst()</span> constructor. Then, on the next line, we declared a variable called <span class="monoText">gasConst</span>, of type <span class="monoText">PhysConst</span>, and assigned to <span class="monoText">otherConst</span>. Then, we initializd the <span class="monoText">name</span> instance variable of <span class="monoText">gasConst</span> to <span class="monoText">"Molar Gas Constant"</span>. After all of this, when print <span class="monoText">otherConst</span> and <span class="monoText">gasConst</span>, it looks like they have the same name &mdash; <span class="monoText">Molar Gas Const</span>. Why? It seems that in <span class="monoText">block (b)</span>, the change made to <span class="monoText">gasConst</span>, which was assigned <span class="monoText">otherConst</span>, had an effect on <span class="monoText">otherConst</span>. This is evidence of a <span class="italicsText">reference</span> at work.</p>
					<p><span class="topic">About Variables.</span> When we discussed variables, we repeatedly said that a variable &#8220;stores&#8221; a value. This is incorrect when it comes to <span class="italicsText">objects</span> in Java. When we assign an object to a variable, the variable does not actually &#8220;store&#8221; the object. Instead, that variable stores a <span class="term">reference</span> to that object. We call such a variable a <span class="italicsText">reference variable</span>.</p>
					<p>A reference is a value representing a particular piece of data's location in the computer's memory. That reference <span class="italicsText">refers</span> to the data, and accessing the data is called <span class="italicsText">dereferencing</span> the reference. References are what allow a program to <span class="underlineText">indirectly</span> access a particular piece of data (e.g., an object). We emphasize &#8220;indirectly&#8221; because references are <span class="underlineText">not</span> <span class="italicsText">pointers</span>. Pointers provide direct access to the referenced data; a reference does not.</p>
					<p>There is a difference between a <span class="italicsText">reference</span> and the actual object the reference refers to. For example, a social security number. That number <span class="italicsText">refers</span> to a particular person, but the number itself is different from the object. Another example: A street address. The address is a reference to a physical location, say, an unlocked building filled with gold. If one person gains access to that address, they can go to that address and steal the boot. If another person knows that address, they can go and watch the looting or participate themselves. The thieves all make changes to the physical location, but the address nevertheless remains the same.</p>
					<p>This same phenomenon occurs with reference variables: Make an object <span class="monoText">x</span>. Assign <span class="monoText">x</span> to a reference variable called <span class="monoText">y</span>. We can make changes to <span class="monoText">x</span> by using the reference <span class="monoText">y</span>. If we make changes to <span class="monoText">y</span>, then those changes are reflected in <span class="monoText">x</span>, and are visible to every entity that has access to <span class="monoText">y</span> or <span class="monoText">x</span>.</p>
					<pre class="language-java"><code>
						class Fish { }

						// bass refers to an object of type Fish
						// but, bass currently refers to nothing
						
						Fish bass;

						// initializing an instance to null tells Java: 
							// this instance refers to nothing

						Fish trout = null;

						// now bass refers to a new Fish object

						Fish bass = new Fish();

						// now bass and trout refer to same Fish object

						trout = bass;             

						// returns true; bass and trout refer to the same Fish object 

						trout == bass;

						// now trout refers to new Fish object

						trout = new Fish(); 

						// false; bass and trout store refer to different Fish objects

						trout == bass;                 
					</code></pre>
					<p>When you assign an object to a reference variable in Java, you do not copy the object. You are copying the reference. If you do not see <span class="monoText">new</span>, you are not creating a new object. If we deleted everything after <span class="monoText">trout = bass</span>, we can make changes to the object <span class="monoText">bass</span> refers to by using <span class="monoText">trout</span>.</p>
					<p>The first <span class="monoText">trout == bass</span> returns <span class="monoText">true</span> because the two objects <span class="monoText">trout</span> and <span class="monoText">bass</span> refer to the same object. This is why we cannot use the <span class="monoText">==</span> operator to test whether two variables, both storing a string with the same exact characters, are equivalent. We cannot do so because the the two variables are <span class="italicsText">reference variables</span> &mdash; they refer to different objects, even if they appear the same.</p>
					<p>Another example:</p>
					<pre class="language-java"><code>
						class Seafood {
							public int quantity;
						}
						public class bar {
							public static void main(String[] args) {
								Seafood prawn;
								prawn = new Seafood();
								Seafood shrimp = prawn; 
								prawn.quantity = 100;
								System.out.println(shrimp.quantity);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						100
					</code></pre>
					<p>Both <span class="monoText">prawn</span> and <span class="monoText">shrimp</span> are referring to the same object, so when we made a change with <span class="monoText">prawn</span>, we can see the changes with <span class="monoText">shrimp</span>.</p>

					<p><span class="topic">Swapping References.</span> Suppose the following code:</p>
					<pre class="language-java"><code>
						class Chemical {
							public String name;
							Chemical(String setName) {
								name = setName;
							}
						}
						public class bar {
							public static void main(String[] args) {
								Chemical Na = new Chemical("iron");
								Chemical Fe = new Chemical("sodium");
							}
						}
					</code></pre>
					<p>We want to switch the objects the reference variables are referring to in the code above. In making this switch, we <span class="underlineText">must</span> be careful. This is because the moment we lose a reference, the moment that object is lost. And once it is lost, it effectively no longer exists (Java's garbage collector spares no one).</p>
					<p>To ensure the reference is never lost, we need a temporary reference variable, in this case a variable named <span class="monoText">tmp</span>:</p>
					<pre class="language-java"><code>
						class Chemical {
							public String name;
							Chemical(String setName) {
								name = setName;
							}
						}
						public class bar {
							public static void main(String[] args) {
								Chemical Na = new Chemical("iron");
								Chemical Fe = new Chemical("sodium");
								Chemical tmp = Na;
								Na = Fe;
								Fe = tmp;
							}
						}
					</code></pre>

					<p><span class="topic">Pass By Reference.</span> Why do we use references in the first place? Why don't we just store the objects themselves in the variables? One of the reasons is because of the way methods work in Java. When we pass an object into a method, the method receives a <span class="italicsText">copy of the reference</span> to the object argument. This in turn allows the method to modify the referenced object.</p>
					<pre class="language-java"><code>
						class Grain {
							public String name;
							public int amount;
							Grain(String setName, int setAmount) {
								name = setName;
								amount = setAmount;
							}
						}
						
						public class bar {
							public static void main(String[], args) {
								Grain wheat = new Grain("wheat", 10);
								System.out.println("amount before: " + wheat.amount);
								newShipment(wheat);
								System.out.println("amount after: " + wheat.amount);
							}
							public static int newShipment(Grain toIncrease) {
								toIncrease.amount++;
								return toIncrease.amount;
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						amount before: 10
						amount after: 11
					</code></pre>
					<p>In the code above, the function <span class="monoText">newShipment()</span> receives a copy of the reference to the object created in the line <span class="monoText">Grain wheat = new Grain("wheat", 10)</span>. Thus, that reference is used by <span class="monoText">newShipment()</span> to modify the object.</p>

					<p><span class="topic">Another Look: Arrays.</span> Arrays in Java store object references. Thus, when we copy an array, we are only copying th object references, not the objects themselves.</p>
					<pre class="language-java"><code>
						class Weapon {
							public int amount;
							Weapon(int setAmount) {
								amount = setAmount;
							}
						}
						public class bar {
							public static void main(String[] unused) {

								// array can hold 4 references
								Weapon[] guns = new Weapon[4];
								for (int i=0; i < guns.length; i++) {
									guns[i] = new Weapon(10+i);
								}
						
								// another array holding 4 references to the same objects
								Weapon[] sameGuns = new Weapon[4];
								for (int i=0; i < guns.length; i++) {
									sameGuns[i] = guns[i]; 
								}

								// increment each referenced object in first array
								for (int i = 0; i < guns.length; i++) {
									guns[i].amount++;
								}
						
								// print each referenced object in second array
								for (int i = 0; i < sameGuns.length; i++) {
									System.out.println(sameGuns[i].amount);
								}
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						11
						12
						13
						14
					</code></pre>
				</section>

				<section id="references_and_polymorphism" class="grid-item">
					<h3>References and Polymorphism</h3>
					<p>Recall that every object in Java is a part of the <span class="italicsText">Java inheritance tree</span> &mdash; every object has a parent class, all the way up to the only object without a class, the <span class="monoText">Object</span>. Thus, every object in Java inherits the methods defined by <span class="monoText">Object</span>. These methods, however, are rarely useful, so we often override them.</p>
					<p>Additionally, recall that when we use a particular method or variable associated with a class, Java first looks at the object's class, and if it is not there, then it looks at the object's parent class. Java will continue until it reaches <span class="monoText">Object</span>, and if it isn't there, then it returns an error.</p>
					<p><span class="italicsText">Subtype polymorphism</span> tells us that every object can be referred to as at least two types: the class defining it, and the type <span class="monoText">Object</span>. The object, of course, can morph into its ancestors, if any. Consider the following:</p>
					<pre class="language-java"><code>
						class Fruit { }
						class Berry extends Fruit {
							public String toString() {
								return "this is a berry!";
							}
						}

						public class bar {
							public static void main(String[] args) {
								Fruit banana = new Fruit();
								Berry blueberry = new Berry();
								bar.printIsType(banana);
								bar.printIsType(blueberry);
							}
							public static void printIsType(Object target) {
								System.out.println(target.toString());
							}  
						}
					</code></pre>
					<pre class="language-bash"><code>
						Fruit@6b95977
						this is a berry!
					</code></pre>
					<p>The first output line is the name of the class followed by a hashcode. This is the default definition for the <span class="monoText">toString()</span> method provided by <span class="monoText">Java.lang.Object</span>. Why do we see this output? Because we created an instance of <span class="monoText">Fruit</span>, and <span class="monoText">banana</span> stores a reference to that instance. The class <span class="monoText">Fruit</span>, however, does not define <span class="monoText">toString()</span>, so Java looks to <span class="monoText">Java.lang.Object</span>, <span class="monoText">Fruit</span>'s parent class, for a definition. Java found that definition, so it applied it accordingly.</p>
					<p>In contrast, with <span class="monoText">blueberry</span>, we created an instance of <span class="monoText">Berry</span>, and stored the reference to that instance in <span class="monoText">blueberry</span>. We overrode <span class="monoText">Java.lang.Object</span>'s definition of <span class="monoText">toString()</span> inside the class <span class="monoText">Berry</span>, so when we called that method, Java went and looked for a definition in <span class="monoText">Berry</span>. It found such a definition and applied it accordingly.</p>
					<p>Now, consider the following alteration:</p>
					<pre class="language-java"><code>
						class Fruit { }
						class Berry extends Fruit {
							public String toString() {
								return "this is a berry!";
							}
						}

						public class bar {
							public static void main(String[] args) {
								Fruit banana = new Berry();
								Berry blueberry = new Berry();
								bar.printIsType(banana);
								bar.printIsType(blueberry);
							}
							public static void printIsType(Object target) {
								System.out.println(target.toString());
							}  
						}
					</code></pre>
					<pre class="language-bash"><code>
						this is a berry!
						this is a berry!
					</code></pre>
					<p>Notice the change made: The reference variable <span class="monoText">banana</span> remains as a variable of type <span class="monoText">Fruit</span>, but it now holds a reference to an instance of <span class="monoText">Berry</span>. Thus, when we passed <span class="monoText">banana</span> to the <span class="monoText">printIsType()</span> method, Java went and looked at the class <span class="monoText">Berry</span>, rather than <span class="monoText">Fruit</span> (after all, the referrent is an instance of type <span class="monoText">Berry</span>). Java found a definition for <span class="monoText">toString()</span>, and evaluated accordingly. This example evidences the relationship between polymorphism &mdash; an object morphing, or behaving, as if it were a member of another class &mdash; and references. We can store a reference to an instance of <span class="monoText">Berry</span> to a reference variable of type <span class="monoText">Fruit</span>. Why? Because <span class="monoText">Berry</span> extends <span class="monoText">Fruit</span>. Any <span class="monoText">Berry</span> can behave like a <span class="monoText">Fruit</span> &mdash; but, not all <span class="monoText">Fruit</span> can behave like a <span class="monoText">Berry</span>. The general rule for polymorphism: An object can morph into an object of its superclasses, but it cannot morph into an object of its subclasses. If we want to <span class="italicsText">downcast</span>, we must do so explicitly:</p>
					<pre class="language-java"><code>
						class Fruit { }
						class Berry extends Fruit {
							public String toString() {
								return "this is a berry!";
							}
						}

						public class bar {
							public static void main(String[] args) {
								Object acai = new Berry();

								System.out.println(acai);

								Fruit acaiFruit = (Fruit) acai;

								System.out.println(acaiFruit);

								Berry acaiBerry = (Berry) acai;

								System.out.println(acaiBerry);

							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						this is a berry!
						this is a berry!
						this is a berry!
					</code></pre>
					<p><span class="topic">How to Copy an Object.</span> Suppose we want to create a copy of an object, <span class="italicsText">not</span> a copy of the reference to that object. We have several options to accomplish this. The <span class="monoText">Java.lang.Object</span> class provides a method called <span class="monoText">clone</span>. But, we should not use this method to create copies of an object. It does not exactly work in the way we expect (more on this later).</p>
					<p>A better way is to implement a <span class="italicsText">copy constructor</span>:</p>
					<pre class="language-java"><code>
						class Employee {
							public int age;
							Employee(int setAge) {
								age = setAge;
							}
							Employee(Employee other) {
								age = other.age;
							}
						}
					</code></pre>
					<p>Here, we have class called <span class="monoText">Employee</span> with a single field called <span class="monoText">age</span>. Then, we have two constructors. The first constructor allows us to create a new instance of <span class="monoText">Employee</span> and set their <span class="monoText">age</span>. Then we have a second constructor: It takes as an argument a reference to another instance of <span class="monoText">Employee</span>, referred to with the dummy variable <span class="monoText">other</span>. In doing so, we copy all of the fields of <span class="monoText">other</span> (we can limit the copy) into the new instance of <span class="monoText">Employee</span>. Thus, what we get back is a copy.</p>
					<p><span class="topic">Instance v. Reference Types.</span> When we create an object and assign its reference to a variable, there are effectively two types: (1) the instance type, and (2) the reference type. The instance type is what is to the right of the symbol <span class="monoText">new</span>. The reference type is to the right of the reference variable name. It will store a reference to any instance that can behave like the reference variable's type.</p>
					<pre class="language-java"><code>
						class Court { }
						class FederalCourt extends Court { }
						class AppellateCourt extends FederalCourt { }
						class CircuitCourt extends FederalCourt { }

						public class bar {
							public static void main(String[] unused) {
								Court NDCal = new Court();
								Object NDIll = new FederalCourt();
								FederalCourt NinthCir = new AppellateCourt();
							}
						}
					</code></pre>
					<p>In the example above, the reference variable <span class="monoText">NDCal</span> can store a reference to any object that behaves like a <span class="monoText">Court</span>. Thus, it can store a reference to <span class="monoText">new FederalCourt()</span>, <span class="monoText">new AppellateCourt()</span>, or <span class="monoText">new CircuitCourt()</span>. Similarly, <span class="monoText">NDIll</span> can store a reference to any object that behaves like a <span class="monoText">Java.lang.Object</span>.</p>
					<p>In Java, the reference type is what determines whether an instance can access particular methods or variables.</p>
					<pre class="language-java"><code>
						class GovEntity {}
						class Executive extends GovEntity {
							public void act() {
								System.out.println('I refused a law');
							}
						} 
						class Legislative extends GovEntity {} 
						class Judicial extends GovEntity {} 

						public class bar {
							public static void main(String[] args) {
								Executive potus = new Executive();
								potus.act(); // works
								Object potusAsObj = potus;
								potus.act(); // doesn't work
								Object stringObj = new String("I am a string");
								stringObject.act(); // doesn't work
								System.out.println(stringObject.toString()); // works
							}
						} 

					</code></pre>
					<p>This is an absolutely critical point to understand. It is not the class of the instance that determines what methods or variables that instance may access, it is the reference variable's class that determines what methods or variables that instance may access.</p>
					<pre class="language-java"><code>
						class GovEntity {}
						class Executive extends GovEntity {
							public void act() {
								System.out.println("I refused a law");
							}
						} 
						class Legislative extends GovEntity {
							public void legislate() {
								System.out.println("I made a law");
							}
						} 
						class Judicial extends GovEntity {
							public void judge() {
								System.out.println("I struck down a law");
							}
						} 

						public class bar {
							public static void main(String[] args) {
								Executive potus = new Executive();
								potus.act(); // works
								Legislative congress = new Legislative();
								congress.legislate(); // works
								Judicial scotus = new Judicial();
								scotus.judge(); // works
								GovEntity scotusGov = scotus;
								scotusGov.judge(); // doesn't work
								GovEntity potusGov = potus;
								potusGov.act(); // doesn't work
								GovEntity congressGov = congress;
								congressGov.legislate(); // doesn't work

								GovEntity whiteHouse = new Executive();
								whiteHouse.act(); // doesn't work -- reference type controls
							}
						} 
					</code></pre>
					<p>Why doesn't the last line work? Didn't we create an instance of <span class="monoText">Executive</span>? It doesn't work because the reference type is <span class="monoText">GovEntity</span>, and <span class="monoText">GovEntity</span> can store any one of three types: <span class="monoText">Executive</span>, <span class="monoText">Legislative</span>, and <span class="monoText">Judicial</span>.</p>

					<p>This is a characteristic of Java that separates it from other object-oriented languages. Java enforces this rule because not every <span class="monoText">GovEntity</span> has a method called <span class="monoText">act()</span>. In languages like Python, the rule is <span class="italicsText">duck typing</span> &mdash; if it walks like an <span class="monoText">Executive</span>, quacks like an <span class="monoText">Executive</span>, then it is an <span class="monoText">Executive</span>.</p>

					<p><span class="topic">Why Polymorphism?</span> A fair question regarding all this complexity is <span class="italicsText">why</span>? Why organize things in a hierarchy? Why create so many rules implicating inheritance? These questions directly strike the heart of Java's type system. Java's motivations are reasonable: First, by focusing on class extension (inheritance), descendant classes can implement or override ancestor behavior while keeping desirable ancestor properties. This is a natural result of implementing hierarchy in the first place &mdash; if we follow strict hierarchy, there is no possibility of refusing methods and variables inherited from an ancestor. Indeed, Java does not allow such actions; if an object does not want <span class="monoText">toString()</span>, we must override.</p>

					<p>Second, by focusing on hierarchy relationships (polymorphism), we can write method that work for <span class="italicsText">any</span> descendant class &mdash; even those that we may not have explicitly defined within the particular descendant class. This is a powerful way to <span class="italicsText">generalize</span> &mdash; we can create elaborate methods without actually knowing anything about the objects they might operate on. This provides fertile ground for large, complex data structures as well as extensive libraries.</p>

					<p><span class="topic"><span class="monoText">final</span> and Classes.</span> As a brief aside, appending the symbol <span class="monoText">final</span> to a class tells Java that the class <span class="underlineText">cannot</span> be extended.</p>
					<pre class="language-java"><code>
						public class Crustacean { }
						public final class Crab { }
						public class MangroveCrab extends Crab { } // this shall not pass
					</code></pre>
					<p><span class="topic"><span class="monoText">abstract</span> and Classes.</span> When we append the symbol <span class="monoText">abstract</span> to a class, we tell Java the class can only be extended <span class="underlineText">but not instantiated</span> (make an instance of).</p>
					<pre class="language-java"><code>
						public abstract Bird { }
						public class Penguin extends Bird { } 
						Bird winglet = new Bird(); // this doesn't work
						Penguin penguini = new Penguin(); // this works
					</code></pre>
					<p><span class="topic"><span class="monoText">private</span> and Classes.</span> We cannot use the symbol <span class="monoText">private</span> with classes. If a class were <span class="monoText">private</span>, we would not be able to use it at all. But, there are situations where we might want to limit a class. To do so, we use <span class="italicsText">inner classes</span>:</p>
					<pre class="language-java"><code>
						public class Organ {
							class Heart {
								public String toString() {
									return "This is part of the heart"
								}
								private Heart foo;
								Organ() {
									foo = new Heart();
								}
							}
						}
					</code></pre>
					<p>Inside the <span class="monoText">Organ</span> class, we have a definition for the <span class="monoText">Heart</span> class. Inside the <span class="monoText">Organ</span> class, we can use the <span class="monoText">Heart</span> class.</p>
					<p><span class="topic">Generality v. Capability.</span> But, polymorphism has its tradeoffs. The higher a class is on the object hierarchy, the more general, and the more general, the fewer its capabilities. On the other hand, the lower a class is on the object hierarchy, the more specific it is, and the more specific, the more capabilities. The problem: The more specific a class is, the narrower its use cases. Narrow use cases are prone to abuse. Polymorphism, as we have seen, can easily become enormously complex, and any good programmer will tell you that large, deeply nested classes can lead to <span class="italicsText">inheritance hell</span> &mdash; adding further classes only makes the program look more like <span class="italicsText">Dante's Inferno</span>.</p>
				</section>

				<section id="interfaces" class="grid-item">
					<h3>Interfaces</h3>
					<p>Suppose we create program that peels potatoes. We write the following:</p>
					<pre class="language-java"><code>
						class Peeler {
							Potato peelPotato(Potato p) {
								return p.removeSkin();
							}
						}
					</code></pre>
					<p>The program works well, until we're thrown an apple to peel. Well, it's just an apple, so maybe we can write another method:</p>
					<pre class="language-java"><code>
						class Peeler {
							Potato peelPotato(Potato p) {
								return p.removeSkin();
							}
							Apple peelApple(Apple a) {
								return a.removeSkin();
							}
						}
					</code></pre>
					<p>We keep peeling, and suddenly we're thrown a kiwi. Now we're starting to think about all the other things that might come our way: yams, oranges, tomatoes, taro, rambutan &mdash; we cannot possibly write all these classes. We could write a separate parent class, called <span class="monoText">Peelable</span>, under which all these foods inherit a method called <span class="monoText">peel()</span>. But maybe there are situations where a <span class="monoText">Potato</span> should not be peeled. Furthermore, there are foods that would be odd to come up with <span class="monoText">peel()</span> methods &mdash; kale, broccoli, rice, popcorn, etc. Ok, so maybe we create a class called <span class="monoText">Peelable</span> and <span class="monoText">NonPeelable</span>, and write separate food classes for each of them. But that's even worse! Now we would have two <span class="monoText">Potato</span> classes to write &mdash; <span class="monoText">PotatoPeelable</span> and <span class="monoText">PotatoNonPeelable</span>.</p>
					<p>Fortunately, there is a solution &mdash; an <span class="italicsText">interface</span>. With an interface, we write:</p>
					<pre class="language-java"><code>
						public interface Peel {
							Food peel(Food f);
						}
						public class Peelable implements Peel {
							public Food peel(Food f) {
								return removeSkin(f);
							}
						}
					</code></pre>
					<p>With the interface <span class="monoText">Peel</span>, the method <span class="monoText">peel()</span> can work for any <span class="monoText">Food</span> object without having to know what specific class the object is an instance of. Interfaces exist because some part ${x}$ of the program needs some entity ${y}$ to do something specific, but ${x}$ doesn't care how ${y}$ does it &mdash; as long as ${y}$ gets it done. This is most often the case when we have many different classes all using the same methods and variables. In such situations, we want to use interfaces or abstract classes so we do not have to declare the same methods over and over again.</p>
					<p>An <span class="italicsText">interface</span> is a point, or place, where separate components of a computer system meet and exchange information. It is effectively a shared boundary betweeen two different entities. What are these two entities? Anything really: library and our source code; software and software; software and hardware; computer and user; etc. A screen, for example, is an interface. A printer's driver is an interface. The keyboard is an interface.</p>
					<p>Because interfaces are what enable different parts of a system to interact with one another, it is imperative that we design interfaces carefully. We can only do so if we have an understanding of interfaces, which is what this section concerns. A designing an interface is like drafting a contract to exchange information under particular terms. To construct that contract, we have to define what the two entities know about each other. What does my entity need to know about your entity, and what does your entity need to know about my entity? The end-game of well-designed interface is to ensure that only the most absolutely necessary things are shared &mdash; everything else is hidden.</p>
					<p>Interfaces are not unique to Java, but Java gives interfaces special treatment. The word <span class="monoText">interface</span> is a keyword in Java. In other languages like Python and JavaScript, interfaces are treated with special conventions.</p>
					<p>Every class in Java has an interface. The interface of a Java class is the set of methods it provides. Because every Java class has an interface, every Java object has interface (since every Java object inherits the methods of <span class="monoText">Java.lang.Object</span>).</p>
					<p><span class="topic">Java Interfaces.</span> Here is an example of a Java interface:</p>
					<pre class="language-java"><code>
						public interface Add {
							int add(int first, int second);
						}
					</code></pre>
					<p>This looks very much like a method declaration, but there is no body. Java interfaces look like empty objects, all we see is a method signature. Interfaces can declare both methods and variables, just like a class, but with a catch &mdash; interface variables <span class="underlineText">must</span> be <span class="monoText">public static final</span>; they are only useful for declaring constants.</p>
					<p>The interface above has only been declared; it has not be implemented. To actually implement the interface, we write the following:</p>
					<pre class="language-java"><code>
						public interface Add {
							int add(int first, int second);
						}
						public class Adder implements Add {
							public int add(int first, int second) {
								return first + second;
							}
						}
					</code></pre>
					<p>As we can see in the code above, the class <span class="monoText">Adder</span> is what implements the interface <span class="monoText">Add</span>. This is done by using the <span class="monoText">implement</span> symbol. Furthermore, to implement the interface, we must implement <span class="italicsText">all</span> of the methods the interface declares. Finally, when we implement an interface, we should have documentation explaining what the interface is supposed to do. The class implementing the interface should try to follow that.</p>
					<p>If we try to use an interface without implementing it, we will see an error:</p>
					<pre class="language-java"><code>
						interface Add {
							int add(int first, int second);
						}
						class Adder { }
						public class bar {
							public static void main(String[] unused) {
								Add add = new Adder();
								System.out.println(add.add(10, 12));
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						bar.java:7: error: incompatible types: Adder cannot be converted to Add
											Add add = new Adder();
														^
						1 error
					</code></pre>
					<p>Once we implement, then it works:</p>
					<pre class="language-java"><code>
						interface Add {
							int add(int first, int second);
						}
						class Adder implements Add {
							/** 
							 * Return the sum of first and second
							 *
							*/
							public int add(int first, int second) {
								return first + second;
							}
						}
						public class bar {
							public static void main(String[] unused) {
								Add add = new Adder();
								System.out.println(add.add(10, 12));
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						22
					</code></pre>
					<p>Notice that the interface is documented. Whenever we write interfaces, we <span class="underlineText">must</span> include documentation. If we have an interface containing multiple methods, then <span class="underlineText">all</span> of those methods must be implemented:</p>
					<pre class="language-java"><code>
						interface Logic {
							boolean nand(boolean p, boolean q);
							boolean neitherNor(boolean p, boolean q);
						}
						class LogicOperator implements Logic {
							public boolean nand(boolean p, boolean q) {
								return !(p && q); 
							}
						}
						public class bar {
							public static void main(String[] unused) {
								Logic isSweetAndSpicy = new LogicOperator(); 
								System.out.println(isSweetAndSpicy.nand(true, true));
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						bar.java:5: error: LogicOperator is not abstract and does not override abstract method neitherNor(boolean,boolean) in Logic
						class LogicOperator implements Logic {
						^
						1 error
					</code></pre>
					<p>Above, we neglected to define the method <span class="monoText">neitherNor()</span>. Once we do so, the source code compiles:</p>
					<pre class="language-java"><code>
						interface Logic {
							boolean nand(boolean p, boolean q);
							boolean neitherNor(boolean p, boolean q);
						}
						class LogicOperator implements Logic {
							public boolean nand(boolean p, boolean q) {
								return !(p && q); 
							}
							public boolean neitherNor(boolean p, boolean q) {
								return !(p || q);
							}
						}
						public class bar {
							public static void main(String[] unused) {
								Logic isSweetAndSpicy = new LogicOperator(); 
								System.out.println(isSweetAndSpicy.nand(true, true));
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						false
					</code></pre>
					<p>For every change we make to the interface, the implementing class must keep up and be updated accordingly.</p>
					<p>Notice that when we called an interface method, we created an instance of class, then assigned the reference to that instance to a reference variable of the type <span class="monoText">interface name</span>. We saw this with classes and reference variables in general. The same exact idea applies with interfaces.</p>
					<p><span class="topic">Interface v. Inheritance.</span> One question we might ask is why use an interface instead of a parent class from which other classes inherit the methods? The answer is partly because of the distinction between the two concepts. Establishing inheritance describes an <span class="italicsText">is-a</span> relationship. Implementing an interface describes a <span class="italicsText">can-do</span> relationship. With inheritance, all an ancestor class's implementations are inherited by its descendant classes. The more methods we include in the ancestor class, the more likely it is that we must override those methods by modifying them in the descendant classes. With enough descendants, we start seeing the method have so many exceptions and modifications that we enter inheritance hell, losing track of how a method operates for a particular descendant class instance.</p>
					<p>Really, interfaces are very similar to <span class="term">abstract methods</span> &mdash; methods defined by <span class="italicsText">abstract classes</span>:</p>
					<pre class="language-java"><code>
						abstract class Proposition {
							public abstract boolean nxor(boolean p, boolean q);
						}
						class BooleanExpression extends Proposition {
							public boolean nxor(boolean p, boolean q) {
								return !((p && !q) || (!p && q));
							}
						}
						
						public class bar {
							public static void main(String[] unused) {
								Proposition isSweetAndSour = new BooleanExpression();
								boolean is_not_sweet_and_not_sour = isSweetAndSour.nxor(false, false);
								boolean is_sweet_but_not_sour = isSweetAndSour.nxor(true, false);
						
								System.out.println(is_not_sweet_and_not_sour);
								System.out.println(is_sweet_but_not_sour);
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						true
						false
					</code></pre>
					<p><span class="topic">Multiple Inheritance.</span> Classes can implement multiple inferfaces:</p>
					<pre class="language-java"><code>
						interface Add {
							int add(int first, int second);
						}
						interface Subtract {
							int subtract(int first, int second); 
						}
						interface MathOp implements Add, Subtract {
							public int add(int first, int second) {
								return first + second;
							}
							public int subtract(int first, int second) {
								return first - second;
							}
						}
					</code></pre>
					<p><span class="topic">Well-designed Interfaces.</span> A well-designed interface is akin to an ambassador. (We are deliberately avoiding the common analogy of a contract; contracts are an abstract concept with a very specific legal meaning, carrying numerous connotations among lay persons.). Like a good ambassador, a well-designed interface serves as the shared contact between the two entities, ensuring and allow both entities to work together, while also keeping everything in check &mdash; only the most relevant information is passed between the two; the two entites follow the relationship's underlying assumptions; all for the end goal of ensuring that both entities are kept entirely separate and independent, while working together.</p>
					<p>One heavily used interface is <span class="monoText">comparable</span>. If we implement the <span class="monoText">comparable</span> interface, then we imply that there is an ordering for our class.</p>
					<pre class="language-java"><code>
						/**
						 * Compares this object with the specified object for order
						 *
						 * Returns a negative integer, zero, or a positive integer as
						 * this object is less than, equal to, or greater than 
						 * the specified object
						 */
						 public interface Comparable {
							 int CompareTo(Object otherObject);
						 }
					</code></pre>
					<p>The value of <span class="monoText">Comparable</span> tells us what order <span class="monoText">Object</span> and <span class="monoText">otherObject</span> are relative to each other. Why would we want to use the <span class="monoText">Comparable</span> interface? Because by committing to using the <span class="monoText">Comparable</span> interface, we in turn commit to ordering our classes. And if we commit to ordering our classes, we can do certain things: sorting arrays containing instances of our class; we can find the maximum or minimum value of multiple instances of the class; we can organize class instances into a binary tree.</p>

					<p>The <span class="monoText">Comparable</span> interface allows us to compare instances. And if we can compare instances, then we can <span class="italicsText">sort</span> instances. And if we can sort instances, we can <span class="italicsText">search</span> for a particular instance.</p>

					<p>Here is an implementation of <span class="monoText">Comparable</span>:</p>
					
					<pre class="language-java"><code>
						interface Comparable {
							int compareTo(Object other);
						}
						class StringLength implements Comparable {
							private String string;
							StringLength(String setString) {
								string = setString;
							}
							public int compareTo(Object other) {
								if (other == null || !(other instanceof StringLength)) {
									return -1;
								}
								StringLength otherStringLength = (StringLength) other;
								if (string.length() < otherStringLength.string.length()) {
									return 1;
								} else if (string.length() > otherStringLength.string.length()) {
									return -1;
								} else {
									return 0;
								}
							}
						}
						public class bar {
							public static void main(String[] unused) {
								StringLength first = new StringLength("test"); 
								StringLength second = new StringLength("examination");
								System.out.println(first.compareTo(second));
							}
						}
					</code></pre>
					<pre class="language-bash"><code>
						-1
					</code></pre>

					<p><span class="topic"><span class="monoText">.equals()</span> v. <span class="monoText">.compareTo()</span></span>. The <span class="monoText">Comparable</span> interface is provided because we cannot accomplish sorting with <span class="monoText">.equals()</span>. The <span class="monoText">.equals()</span> method is a binary method: Either one is equal or not equal to the other. The <span class="monoText">.compareTo()</span> method is a ternary method: One object goes before the other, one object goes after the other, or both object's are equal.</p>

					<p><span class="topic">Interface Casting.</span> We can cast interfaces just as we would cast class instances:</p>

					<pre class="language-java"><code>
						interface add {
							int add(int first, int second);
						}
						class Adder implements Add {
							public int add(int first, int second) {
								return first + second;
							}
							public int multiply(int first, int second) {
								return first * second;
							}
						}
						public class bar {
							public static void main(String[] unused) {
								Add add = new Adder();
								System.out.println(add.add(10, 20)); // works
								System.out.println(add.multiply(10, 20)) // does not work
							}
						}
					</code></pre>

					<p>The last line does not work because <span class="monoText">multiply</span> is not a part of the <span class="monoText">Add</span> interface, and we are storing the reference to <span class="monoText">Adder</span> inside an <span class="italicsText">interface variable</span>.</p>

					<p><span class="topic">Why interfaces?</span> Interfaces should be used when we want to implement a method that should be accessible to objects regardless of their positions in the inheritance tree.</p>
				</section>

				<section id="algorithms" class="grid-item">
					<h3>Algorithms in Java</h3>
					<p>An algorithm is a sequence of instructions towards completing a particular objective. It is an answer to a <span class="italicsText">how-to</span> question. This is contrast to a mathematical proof, which is an answer to a <span class="italicsText">what-is</span> question. However, like mathematcial proofs, some algorithms are <span class="italicsText">elegant</span> or <span class="italicsText">efficient</span>. We use the word <span class="italicsText">or</span> because an elegant algorithm need not be efficient, nor does an efficient one need be elegant.</p>
					<p>Here, our primary concern is with <span class="term">efficiency</span>. Some algorithms are far more efficient than others. How do we measure efficiency? Usually, by how many <span class="italicsText">steps</span> the algorithm takes (although, time is a perfectly fine measurement, all things equal). In these next few sections, we will assume the unit of measurement is by step.</p>
					<p>When we analyze an algorithm, we do so in the context of a <span class="term">general case</span>, rather than for a specific set of inputs. Because we assess efficiency in general, efficiency can be thought of in three terms: (1) The best case; (2) the on-average case; and (3) the worst case. These cases correspond to the different answers to this question: How does the algorithm respond to its inputs? This question encapsulates several other questions into a single statement: What happens when the inputs are very large? What happens when the inputs are very small? What happens for a typical input?</p>
					<p><span class="topic">Big-O Notation.</span> The way we measure efficiency in computer science is with <span class="term">Big-O Notation</span> &mdash; a mathematical notation describing a function's limiting behavior when its argument tends towards either (a) zero, (b) some non-zero value, or (b) towards infinity. We refer to the efficiency measurement as <span class="term">runtime</span>.</p>
					<p>Runtimes generally fall into a few categories:</p>
					<ol>
						<li>${O(1)}$ &#8220;Big-O of 1.&#8221;</li>
						<li>${O(\log n)}$ &#8220;Big-O of ${\log n.}$&#8221;</li>
						<li>${O(n)}$ &#8220;Big-O of ${n.}$&#8221;</li>
						<li>${O(n \log n)}$ &#8220;Big-O of ${n \log n.}$&#8221;</li>
						<li>${O(n^2)}$ &#8220;Big-O of ${n^2.}$&#8221;</li>
						<li>${O(2^n)}$ &#8220;Big-O of ${2^n.}$&#8221;</li>
						<li>${O(n!)}$ &#8220;Big-O of ${n}$ factorial.&#8221;</li>
					</ol>
					<p>The graphs for these runtimes:</p>
					<figure><img src="images/big_o_comparison.svg" alt="compare big-o" loading="lazy" class="seventy-p"></figure>
					<p>Why are these runtimes so important? Because a slow algorithm makes a hard problem harder. From the graph above, we can see that there is little to no difference when ${x=1;}$ i.e., when the inputs are very, very small. However, as we pass larger and larger inputs, the differences are stark. In particular, a Big-O of ${n!}$ indicates the algorithm takes a shocking amount of computational steps to reach its output.</p>
				</section>

				<section id="data_structures" class="grid-item">
					<h3>Data Structures</h3>
					<p>A <span class="term">data structure</span> is a collection of data, the relationships between such data, and the functions or operations that can be applied to such data. Particulary in Java, data structures are created with <span class="italicsText">primitive types</span> and <span class="italicsText">objects</span>, so as to store and organize data. The simplest data structure we have seen is the array. We will now see a variety of other data structures.</p>
					<p><span class="topic">Lists.</span> After arrays, the next simplest data structure is a <span class="term">list</span>.</p>
				</section>
			</article>
		</main>
		<!-- Scripts -->
			<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
			<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js " integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
			<script>
				document.addEventListener("DOMContentLoaded", function () {
					renderMathInElement(document.body, {
						// customised options
						//  auto-render specific keys, e.g.:
						delimiters: [
							{ left: "$$", right: "$$", display: true },
							{ left: "$", right: "$", display: false },
							{ left: "\\(", right: "\\)", display: false },
							{ left: "\\[", right: "\\]", display: true },
						],
						//  rendering keys, e.g.:
						throwOnError: false,
					});
				});
			</script>
			<!-- <script src="https://unpkg.com/function-plot@1.22.2/dist/function-plot.js"></script> -->
			<script src="js/csfoundations.js"></script>
			<script src="js/prism.js"></script>
	</body>
</html>
