<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Introduction to Computer Science with JavaScript</title>
		<!-- <base href="http://127.0.0.1:5500/csfoundations/" /> -->
		<link rel="stylesheet" href="css/csfoundations.css" />
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous" />
		
	</head>

	<body>
		<header>
			<h1>Computer Science Fundamentals</h1>
		</header>

		<main>
		<!-- C Programming -->
			<article id="c_language" class="grid" data-colcade="columns: .grid-col, items: .grid-item">
			<!-- Grid Columns -->
				<div class="grid-col grid-col--1"></div>
				<div class="grid-col grid-col--2"></div>
				<div class="grid-col grid-col--3"></div>
				<div class="grid-col grid-col--4"></div>
			<!-- ยง Functions, Loops -->

				<section class="grid-item">
					<h2>Our First Language: C</h2>
				</section>

				<section id="c_intro" class="grid-item">
					<p>C is an extremely <span class="italicsText">low-level language</span>, in that it operates very closely with hardware. Because of how "on the ground" C is, it requires a programmer to get their hands dirty&mdash;managing memory, watching processes, and being generally cognizant of how a program is interacting with hardware. Because of this feature, C provides a great introduction to theory and application in computer science.</p>
					<p>Here is a sample C program, written in a file called <span class="monoText">hello.c</span>:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;

						int main()
						{
							int i;
							for (i = 0; i < 10; i++)
							{
								puts("Hello, world!\n");
							}
							return 0;
						}
					</code></pre>
					<pre class="language-bash"><code>
						gcc hello.c
						./a.out

						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
						Hello, world!
					</code></pre>
					<p>The <span class="monoText">a.out</span> file is a machine language file. When we wrote <span class="monoText">gcc hello.c</span>, we <span class="italicsText">compiled</span> the <span class="italicsText">source code</span> into <span class="italicsText">machine code</span> &mdash; the code actually understood by the computer.</p>
					<p>The symbol <span class="monoText">gcc</span> is a call to the <span class="monoText">gcc</span> <span class="italicsText">compiler</span>, a special program that translates source code into machine code. We use compilers because every computer speaks a different machine language (i.e., it only understands its own version of machine code). The compiler truly is the translator; the middle man between us, and the processor &mdash; the computer's brain.</p>
					<p>What is inside that <span class="monoText">a.out</span> file? Well, let's see:</p>
					<pre class="language-bash"><code>
						objdump -D a.out | grep -A20 main.:
						0000000100003f40 &lt;_main&gt;:
							100003f40: 55                           pushq   %rbp
							100003f41: 48 89 e5                     movq    %rsp, %rbp
							100003f44: 48 83 ec 10                  subq    $16, %rsp
							100003f48: c7 45 fc 00 00 00 00         movl    $0, -4(%rbp)
							100003f4f: c7 45 f8 00 00 00 00         movl    $0, -8(%rbp)
							100003f56: 83 7d f8 0a                  cmpl    $10, -8(%rbp)
							100003f5a: 0f 8d 1a 00 00 00            jge     0x100003f7a &lt;_main+0x3a&gt;
							100003f60: 48 8d 3d 3b 00 00 00         leaq    59(%rip), %rdi  # 100003fa2 &lt;dyld_stub_binder+0x100003fa2&gt;
							100003f67: e8 16 00 00 00               callq   0x100003f82 &lt;dyld_stub_binder+0x100003f82&gt;
							100003f6c: 8b 45 f8                     movl    -8(%rbp), %eax
							100003f6f: 83 c0 01                     addl    $1, %eax
							100003f72: 89 45 f8                     movl    %eax, -8(%rbp)
							100003f75: e9 dc ff ff ff               jmp     0x100003f56 &lt;_main+0x16&gt;
							100003f7a: 31 c0                        xorl    %eax, %eax
							100003f7c: 48 83 c4 10                  addq    $16, %rsp
							100003f80: 5d                           popq    %rbp
							100003f81: c3                           retq
							
							Disassembly of section __TEXT,__stubs:
					</code></pre>
					<p>What did we just type? We used a program called <span class="monoText">objdump</span>, which translates compiled binaries into a more readable format. Then, we piped the output translations into a <span class="monoText">grep</span>, with the command line option to only display 20 lines after the regular expression <span class="monoText">main.:</span>.</p>
					<p>The numbers we see above like <span class="monoText">0x10202</span> are <span class="italicsText">bytes</span> represented in <span class="italicsText">hexadecimal</span>. More specifically, the numbers on the leftmost column are <span class="italicsText">memory addresses</span>. Every bit we use must be stored somewhere in <span class="italicsText">memory</span> &mdash; a collection of bytes of temporary storage space, numbered with the addresses above.</p>
					<p>Each of the addresses above contain machine language instructions. And for our program to execute, the computer's CPU (Central Processing Unit) turns to these addresses, retrieves the instructions, and executes them.</p>
					<p>How many addresses there are is determined by the CPU. A 32-bit processor has ${2^{32}}$ (4,294,967,296) possible addresses. 64-bit processors have ${2^{64}}$ (roughly ${1.8 \times 10^{19}}$) possible addresses.</p>
					<p>The numbers in the middle column are hexadecimal bytes for the machine language instructions. These bytes, at the machine language level, look like <span class="monoText">10001001001</span> &mdash; cumbersome to read. It is because of that cumbersomeness that we represent them in hexadecimal. However, even hexadecimal is cumbersome to read and write, so we have <span class="italicsText">assembly language</span> &mdash; the English-resembling terms to the right of the hexadecimal numbers (e.g., <span class="monoText">push</span>, <span class="monoText">mov</span>, <span class="monoText">sub</span>, etc.). Those terms are translations of instructions like <span class="monoText">0xd5</span>. Furthermore, because they are direct translations of machine code, every processor has its own version of assembly. They do, however, fall into two main types: AT&T syntax and Intel syntax. The assembly above is AT&T syntax. The most obvious indicator of AT&T syntax is the extensive use of special symbols &mdash; <span class="monoText">$</span> and <span class="monoText">%</span>.</p>
					<p>Because Assembly is unique to machines, we have a problem: Everyone uses a different machine. We get around that problem with languages like C &mdash; one language that compiles into machine code, as long as the machine has the relevant compiler.</p>
					<p>Despite the fact that C is a beautiful, efficient, and innovative language, many find C too cumbersome to read and write, so we have languages like Java. Then, many find Java too cumbersome to read and write, so we have languages Python and JavaScript. Then, many find Python not cumbersome, but too limited and slow, so we have languages like Julia. Others find JavaScript too dangerous, so we have languages like TypeScript. The motif: Humans fundamentally want <span class="italicsText">comfort</span> and <span class="italicsText">freedom</span> &mdash; we want to make things as easy as possible, but at the same time, ensure things work as expected. That is precisely what computer science and the art of programming intends to accomplish.</p>
				</section>

				<section id="programming_conventions" class="grid-item">
					<h3>Writing Programs <span class="italicsText">Well</span></h3>
					<p>
						Programming involves writing statements in a language. Because these statements are written, they inevitably are read, whether by others or our future selves. And where there are statements to be read, there are distinctions between
						<span class="italicsText">well-written programs</span> and <span class="italicsText">poorly-written programs</span>.
					</p>
					<p>Generally, a program's writing quality depends on a few factors:</p>
					<ol>
						<li><span class="boldItalics">Correctness</span>. Does the program work as intended?</li>
						<li><span class="boldItalics">Clarity</span>. Is the program clearly written? I.e., can an unfamiliar reader read and understand the program?</li>
						<li><span class="boldItalics">Conciseness</span>. Is the program concise? I.e., does it accomplish its intent with the minimum amount of statements necessary, without sacrificing clarity?</li>
						<li><span class="boldItalics">Style</span>. Does the program follow the prevailing conventions for writing statements? I.e., capitalization, punctuation, proper use of words, etc.</li>
					</ol>
					<p>Considering these factors, computer science is perhaps the ultimate embodiment of mathematics, science, engineering, linguistics, and philosophy. We approach problems like mathematicians, design our solutions like engineers, test hypotheses and evaluate results like scientists, all while bearing in mind that what we write is meant to be conveyed and understood by both humans and non-humans, a highly linguistic issue. Later in these materials, when we discuss how programming languages are made and how our programs affect others, we quickly discover that philosophy plays an enormous role as well.</p>
				</section>

				<section id="first_c_program" class="grid-item">
					<h3>A Sample C Program</h3>
					<p>
						Here is an example C program, in a file named
						<span class="monoText">helloworld.c</span>. (C programs can be identified by the file extension <span class="monoText">.c</span>).
					</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;
						int main(void)
						{
							printf("hello, world");
						}
					</code></pre>
					<p>
						The statements written above is called
						<span class="boldItalics">source code</span>. The computer itself does <span class="underlineText">not</span> understand what these statements mean&mdash;they must be translated into 1s and 0s. To do so, the computer takes the <span class="italicsText">source code</span> as an input, and <span class="boldItalics">compiles</span> it, the process of turning <span class="italicsText">source code</span> into <span class="boldItalics">machine code</span>, the 0s and 1s that the computer understands.
					</p>
					<p>
						The act of compiling source code is done by a
						<span class="boldItalics">compiler</span>. Put simply, a compiler is a program that turns source code into machine code. When the above code is compiled, we get the following output:
					</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;
						int main(void)
						{
							printf("hello, world");
						}	
						// Output: hello, world
					</code></pre>
					<p>
						The statement
						<span class="monoText">int main(void){}</span> is a quirk of the C language (to be covered in more detail later). All of our program's statements must be included inside the curly braces of <span class="monoText">int main(void){}</span>.
					</p>
				</section>

				<section id="functions_in_c" class="grid-item">
					<h3>Functions in C</h3>
					<p>A <span class="boldItalics">function</span>, in the simplest terms, is a mini program. Some functions take <span class="boldItalics">arguments</span> ("inputs"), and give back outputs. In this sense, they are like mini black boxes inside a bigger black box.</p>
					<p>
						In the example above, we see a function in C:
						<span class="monoText">printf()</span>. In between the parentheses, we place our inputs, or <span class="italicsText">arguments</span>. Here, the input we are passing is data called a <span class="italicsText">string</span>, and C requires us to place that data inside quotes <span class="monoText">""</span>.
					</p>
					<p>Furthermore, for C to understand what we're writing, we must include a semicolon <span class="monoText">;</span>, to indicate to C where the statement ends, much like how complete English sentences require a period.</p>
					<p>
						Given that functions are really just mini programs, they are, in fact,
						<span class="italicsText">implementations</span> of an algorithm.
					</p>
					<figure>
						<img src="images/function_diagram.svg" alt="" loading="lazy"/>
					</figure>
				</section>

				<section id="the_output_of_function" class="grid-item">
					<h5>The Output of a Function</h5>
					<p>
						Functions take inputs, and they give back outputs. But what are those outputs? It depends on how we write and use a function. A function can output text to a screen, as is the case with the
						<span class="monoText">printf</span> function in C.
					</p>
					<p>
						A function can also output a
						<span class="boldItalics">return value</span>, which we can store in a <span class="boldItalics">variable</span>. That value could be anything: a number, a word, a sentence, an emoji, it all depends on how we write and use a function. A variable can be thought of as a <span class="monoText">box</span> where we can place that value. Once we store that value, we can then reuse it elsewhere in our program.
					</p>
					<p>
						How then do we write a function to output a return value? There are many ways to do so in C, none of which are particularly easy. What we can do, however, is to use a
						<span class="boldItalics">library</span>&mdash;code that someone else has written. Here, we have a function, <span class="monoText">get_string()</span>, from a C library, that returns a string value.
					</p>
					<pre class="language-c"><code>
									#include &lt;stdio.h&gt;
									int main(void)
									{
									string response = get_string("What's your name?");
									}
								</code></pre>
					<p>
						In the code above, the value returned from the
						<span class="monoText">get_string()</span> function is stored in the variable <span class="monoText">response</span>. Furthermore, we need to tell C what type of variable we're using. In this case, a variable of type <span class="monoText">string</span>.
					</p>
					<p>With a return value stored inside a variable, we can then use that return value in another function, by passing through the variable as an argument:</p>
					<pre class="language-c"><code>
								printf("hello, %s", response);
							</code></pre>
					<p>The characters <span class="monoText">%s</span> are what we call <span class="boldItalics">format code</span> (the "f" in <span class="monoText">printf()</span> stands for "format"). By writing these characters, we tell C, print this string containing this variable. We then passed in to the parentheses the variable <span class="monoText">response</span>, which is the variable that C will use to stand for the <span class="monoText">%s</span>.</p>
					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
							string answer = get_string("What's your name?");
							printf("Hello, %s");
							}
						</code></pre>
					<p>
						Note that in the above, we included the statement
						<span class="monoText">#include &lt;cs50.h&gt;</span>. This is how we include a <span class="italicsText">library</span> in C. When we compile the code, we get the following:
					</p>
					<pre class="language-c"><code>
						#include &lt;cs50.h&gt;
						#include &lt;stdio.h&gt;
						int main(void)
						{
						string answer = get_string("What's your name?");
						printf("Hello, %s");
						// Output: What's your name?
						}
					</code></pre>
					<p>The output indicates that we should enter our name. When we enter our name, we get the following:</p>
					<pre class="language-bash"><code>
						hello, myName
					</code></pre>
				</section>

				<section id="header_files_in_c" class="grid-item">
					<h4>Header Files</h4>
					<p>
						In the code above, there are two other statements:
						<span class="monoText">&lt;stdio.h&gt;</span> and <span class="monoText">&lt;cs50.h&gt;</span>. These what we call <span class="boldItalics">header files</span>. In C, header files are indicated by the extension <span class="monoText">.h</span>.
					</p>
					<p>
						The "stdio" in the header file
						<span class="monoText">#include &lt;stdio.h&gt;</span>
						stands for "standard input output" (in computer science, IO or I/O is a common acronym for "input output"). The file
						<span class="monoText">&lt;stdio.h&gt;</span> is a popular file in the C programming community for getting inputs and outputs from a user. These header files contain functions that are not built-in to C. We can think of these as add-ons, or extensions, to the language, much like how you would have add-ons when ordering a pizza or purchasing a new phone.
					</p>
				</section>

				<section id="errors_in_c" class="grid-item">
					<h4>Error Returns are Good</h4>
					<p>Error returns often strike fear in the novice programmer. This fear is worsened by the fact that error messages are often cryptic and filled incomprehensible (at first glance) symbols. Unfortunately, many languages were written by academics and research-oriented computer scientists, who prized efficiency and precision over user experience. Nevertheless, rather than with contempt, error messages should be viewed as a helping hand from C. For example, let's omit the header file statements in the program above:</p>
					<pre class="language-c"><code>
							int main(void)
							{
								string answer = get_string("What's your name?");
								printf("hello, %s", answer);
							}
						</code></pre>
					<p>When we attempt to compile the code above, we get the following:</p>
					<pre class="language-bash"><code>
							clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow    hello.c  -lcrypt -lcs50 -lm -o hello
							hello.c:3:5: <span class="redText">error</span>: use of undeclared identifier 'string'
								string answer = get_string("What's your name?");
								^
							hello.c:4:5: <span class="redText">error</span>: implicitly declaring library function 'printf' with type 'int (const char *, ...)' [-Werror,-Wimplicit-function-declaration]
								printf("hello, %s", answer);
								^
							hello.c:4:5: note: include the header &lt;stdio.h&gt; or explicitly provide a declaration for 'printf'
							hello.c:4:25: <span class="redText">error</span>: use of undeclared identifier 'answer'
								printf("hello, %s", answer);
													^
							3 errors generated.
							make: *** [&lt;builtin&gt;: hello] Error 1
						</code></pre>
					<p>
						By removing the header files, C does not know what the function
						<span class="monoText">printf()</span> is.
					</p>
					<p>While the error messages look convoluted, there are several we can gather:</p>
					<ol>
						<li>
							First, we see the name of the file,
							<span class="monoText">hello.c</span>. That name is followed by a number: <span class="monoText">hello.c:3</span>. That number, <span class="monoText">3</span>, tells us that there's an error on line 3. The 5 in <span class="monoText">hello.c:3:5</span> tells us that the error is in column 5 (this is generally only useful when the program is written in a certain way).
						</li>
						<li>Following the <span class="monoText">hello.c:3:5</span>, we get the error's description.</li>
					</ol>
				</section>

				<section id="comments_in_c" class="grid-item">
					<h4>Comments in C and in General</h4>
					<p>
						In programming, a
						<span class="boldItalics">comment</span> is a statement ignored by the compiler. Because they're ignored by the compiler, we can use them to annotate our code. Comments are valuable in programming. They tell readers what a particular statement means or does. But, they also take up space and too many comments can clutter a program, making it unreadable.
					</p>
					<p>Comments should be concise and descriptive. They should not be simply identical to the actual code (since that would simply be a waste of space).</p>
					<p>This is a good comment:</p>
					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
							string answer = get_string("What's your name?");
							// Print hello user
							printf("Hello, %s");
							}
						</code></pre>
					<p>This is a bad comment:</p>
					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
							string answer = get_string("What's your name?");
							// Greet user
							printf("Hello, %s");
							}							
						</code></pre>
				</section>

				<section id="variables_and_types" class="grid-item">
					<h3>Data Types</h3>
					<p>
						Data comes in many forms. The "Call me Ishmael" and "WARNING" are textual data. The number of users visiting this page is numeric data. These datum all take a different form, and there are things we can and cannot do with them. We can add 4 and 7, but we cannot divided "love" by "children." Because of this fact, C (and many other programming languages) classify data by
						<span class="boldItalics">type</span>.
					</p>
					<p>
						While a program runs, and while a file is open, it is stored in a hardware component called the
						<span class="boldItalics">RAM</span> ("Random Access Memory"). When you install programs and save files (and they are not running or open), they are stored in a different hardware component, the <span class="monoText">hard drive</span> (or <span class="italicsText">hard disk</span> or <span class="italicsText">solid state disk</span>; or a CD; or a USB; devices that store data, other than RAM). Devices like hard drives do not require electricity to store data. RAM, however, does. It is much faster than a hard drive, because it is a purely electronic device&mdash;unlike hard drives, there are no moving parts. With RAM, we have the ability to very quickly open files and execute programs, because everything is electric. This is why we lose data when our computer suddenly dies midway through writing a Word Document or a C program. The data is stored in RAM, and without electricity coming from the computer's power source, everything is lost.
					</p>
					<p>At a very high level overview, the RAM can be understood as:</p>
					<figure>
						<img src="images/ram_allocation.svg" alt="diagram of ram" loading="lazy"/>
					</figure>

					<h4>Type <span class="monoText">int</span></h4>
					<p>The type <span class="monoText">int</span> represents numeric data. More specifically, it represents integers (as such, it does not take floating point values). The <span class="monoText">int</span> type is limited to 32 bits. Thus, it can only represents integers between roughly -2 billion and 2 billion.</p>

					<h5><span class="monoText">unsigned int</span></h5>
					<p>In C, the word <span class="monoText">unsigned</span> is a <span class="boldItalics">qualifier</span>, that can be applied to certain data types (one of which is <span class="monoText">int</span>). By including the qualifier <span class="monoText">unsigned</span>, the type's positive range is doubled by disallowing all negative values. By disallowing the use of negative values, <span class="monoText">unsigned int</span> allows <span class="monoText">int</span> to represent integers up to $2^{32} - 1$.</p>

					<h4>Type <span class="monoText">char</span></h4>
					<p>The type <span class="monoText">char</span> represents single character data. The type <span class="monoText">char</span> will always take just 1 byte of memory (8 bits). Thus, the range of values that a variable of type <span class="monoText">char</span> can store is very limited. Because <span class="monoText">char</span> can only store up to 8 bits, the numbers they can store range from -127 to 127. These numbers, -127 to 127, are assigned to characters through ASCII (e.g., the character 0 is represented by the number 48).</p>

					<h4>Type <span class="monoText">float</span></h4>
					<p>The type <span class="monoText">float</span> represents floating-point values, or <span class="monoText">real numbers</span>. The type <span class="monoText">float</span> always takes up 4 bytes of memory (32 bits). The range of a float depends on the real number being stored. The key point: <span class="monoText">float</span> type values are only precise up to 32 bits of precision. The bigger the integer part of the real number, the less bits there are to store the fractional digits. This has the effect of limiting precision.</p>

					<h4>Type <span class="monoText">double</span></h4>
					<p>The type <span class="monoText">double</span> remedies the precision problems of <span class="monoText">float</span> for most purposes. Like <span class="monoText">float</span>, the type <span class="monoText">double</span> represents real numbers, with the difference that <span class="monoText">double</span> takes up 8 bytes of memory (64 bits). With this increased allotment, <span class="monoText">double</span> has an additional 32 bits of precision.</p>

					<h4><span class="monoText">void</span></h4>
					<p>The word <span class="monoText">void</span> is not a data type, but it is a <span class="italicsText">type</span>. We cannot create variables of type <span class="monoText">void</span> and assign a value to it. Functions, however, can have a <span class="monoText">void</span> return type. If a function has a <span class="monoText">void</span> return type, it does not return a value. One such function is <span class="monoText">printf()</span>&mdash;it does not actually return a value, it simply prints something to the screen.</p>
					<p>
						From this definition, we can see that
						<span class="monoText">int main(void)</span> is a function. Notice that <span class="monoText">void</span> is inside the parentheses (the <span class="italicsText">parameter list</span>) of the function. This means that the main function does not take any parameters (i.e., there are no arguments to be passed into the function <span class="monoText">main</span>). At the moment, we can think of <span class="monoText">void</span> as a placeholder for "nothing." This will be explored in further detail later on in the course.
					</p>

					<h4>Type <span class="monoText">bool</span></h4>
					<p>The type <span class="monoText">bool</span> is not a type that comes inherently with C. This is a type that provided in a library. The type <span class="monoText">bool</span> can only store one of two values: <span class="monoText">true</span> and <span class="monoText">false</span>.</p>

					<h4>Type <span class="monoText">string</span></h4>
					<p>The type <span class="monoText">string</span> is another type that does not come inherently with C. It must be included from a library. The type <span class="monoText">string</span> represents series of characters data (i.e., textual data&mdash;words, sentences, paragraphs, etc.).</p>
				</section>

				<section id="creating_variables" class="grid-item">
					<h3>Creating Variables</h3>
					<p>
						Creating variables in C is a straightforward process. We simply include the type before the variable's
						<span class="boldItalics">identifier</span> (the variable's name). E.g.:
					</p>
					<pre class="language-c"><code>
							int num;
							char letter;
							string sentence;
							</code></pre>
					<p>If we want to create multiple variables, we only need to specify the type once:</p>
					<pre class="language-c"><code>
							int height, width;
							float sqrt2, sqrt3, pi;
						</code></pre>
					<p>Note, however, that it's best to only declare variables when needed.</p>
				</section>

				<section id="redeclaring_variables" class="grid-item">
					<h4>Redeclaring Variables</h4>
					<p>Once a variable has been declared, it is no longer necessary to specify that variable's type. In fact, it's generally advised not to do so, because that may have unintended consequences.</p>
				</section>

				<section id="initialization" class="grid-item">
					<h4>Initialization</h4>
					<p>This is perfectly valid code in C:</p>
					<pre class="language-c"><code>
							int num;
							num = 2
						</code></pre>
					<p>
						In the code above, we declared a variable, then assigned it a value in the next line. Rather than doing this, however, we can simply combine the two steps through
						<span class="boldItalics">initialization</span>&mdash;declaring and assigning a variable at the same time.
					</p>
					<pre class="language-c"><code>
								int num = 2;
							</code></pre>
				</section>

				<section id="functions_for_data_types" class="grid-item">
					<h3>Functions for the Data Types</h3>
					<p>The library we use, <span class="monoText">cs50.h</span>, includes several functions for the data types:</p>
					<ul>
						<li><span class="monoText">get_string</span>&mdash;get a string</li>
						<li><span class="monoText">get_char</span>&mdash;get a single character</li>
						<li><span class="monoText">get_double</span>&mdash;get a float</li>
						<li><span class="monoText">get_int</span>&mdash;get an int</li>
						<li><span class="monoText">get_long</span>&mdash;get a long</li>
					</ul>
					<p><span class="monoText">printf()</span> also takes several placeholders:</p>
					<ul>
						<li><span class="monoText">%c</span>&mdash;placeholder for a variable storing a <span class="monoText">char</span> type value</li>
						<li><span class="monoText">%f</span>&mdash;placeholder for a variable storing a <span class="monoText">float</span> type value</li>
						<li><span class="monoText">%i</span>&mdash;placeholder for a variable storing an <span class="monoText">int</span> type value</li>
						<li><span class="monoText">%li</span>&mdash;placeholder for a variable of <span class="monoText">long</span> type value</li>
						<li><span class="monoText">%s</span>&mdash;placeholder for a variable of <span class="monoText">string</span> type value</li>
					</ul>
				</section>

				<section id="numeric_operators" class="grid-item">
					<h3>Numeric Operators</h3>
					<p>We can manipulate numeric type values in C with basic math operators:</p>
					<figure id="c_operators_table">
						<table>
							<thead>
								<th>Operator</th>
								<th>Math Operation</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">+</span></td>
									<td>addition</td>
								</tr>
								<tr>
									<td><span class="monoText">-</span></td>
									<td>subtraction</td>
								</tr>
								<tr>
									<td><span class="monoText">*</span></td>
									<td>multiplication</td>
								</tr>
								<tr>
									<td><span class="monoText">/</span></td>
									<td>division</td>
								</tr>
								<tr>
									<td>%</td>
									<td>modulus / remainder operator</td>
								</tr>
							</tbody>
						</table>
					</figure>
					<p>Here is a simple program that computes a sum:</p>
					<pre class="language-c"><code>
							#include &lt;cst50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
								int x = get_int("x: "); // ask user to enter first number
								int y = get_int("y: "); // ask user to enter second number
								int z = x + y;
								printf("%i\n", z); // display result in new line
							}
						</code></pre>
					<pre class="language-bash"><code>
						make addition
						./addition
						x: 5
						y: 12
						17
					</code></pre>
					<p>What if we passed a large number, say, 5,000,000,000?</p>
					<pre class="language-bash"><code>
							x: 5000000000
							x: 
							# C does not like this, it asks again for an input
							x: 4000000000
							x:
							# again, C asks for an input
							x: 3000000000
							x:
							# again, no good
							x: 2000000000
							y:
							# now C accepts it
						</code></pre>
					<p>
						In the above example, C does not seem to accept numbers above 2,000,000,000. Why is this? Because data types only take a certain number of bits. In this case,
						<span class="monoText">int</span> only takes 32 bits. This means that the type <span class="monoText">int</span> can only count to about 4,000,000,000. Then why isn't C accepting 4,000,000,000? Because the <span class="monoText">get_int</span> function accommodates for both positive and negative numbers. This means that the number of bits available is divided in two. 16 bits for the positive numbers (allowing C to count up to 2,000,000,000), and 16 bits for the negative numbers (allowing C to count down to -2,000,000,000).
					</p>
					<p>
						So, if we wanted to allow inputs of greater than 2,000,000, we need to use a different data type. Namely,
						<span class="monoText">long</span>:
					</p>
					<pre class="language-c"><code>
							#include &lt;cst50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
								long x = get_long("x: "); // ask user to enter first number
								long y = get_long("y: "); // ask user to enter second number
								long z = x + y;
								printf("%li\n", z); // change format code to li
							}
						</code></pre>
					<pre class="language-bash"><code>
						make addition
						./addition
						x: 5000000000
						y: 7000000000
						12000000000
					</code></pre>
					<p>The fact that data types are only given a certain amount of bits extends to the return value from those data types. Consider the following code.</p>
					<pre class="language-c"><code>
						#include &lt;cst50.h&gt;
						#include &lt;stdio.h&gt;
						int main(void)
						{
							int x = get_int("x: "); // ask user to enter first number
							int y = get_int("y: "); // ask user to enter second number
							int z = x + y;
							printf("%i\n", z); // display result in new line
						}
					</code></pre>
					<pre class="language-bash"><code>
						make addition
						./addition
						x: 2000000000
						y: 2000000000
						-294967296
					</code></pre>
					<p>
						In the above code, we entered 2,000,000,000 and 2,000,000,000. Adding these numbers together, we get a negative number. Why is this? Because we're storing the result in a variable of type
						<span class="monoText">int</span>&mdash;a data type only given a certain number of bits. Consider the code below.
					</p>
					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
								// Get numbers from user
								int x = get_int("dividend: ");
								int y = get_int("divisor: ");

								// Divide x by y
								float z = x / y;
								printf("quotient: %f\n", z);
							}
					</code></pre>
					<pre class="language-bash"><code>
						make truncation
						./truncation
						dividend: 1
						divisor: 2
						0.000000
						./truncation
						dividend: 2
						divisor: 3
						quotient: 0.000000
						./truncation
						dividend: 4
						divisor: 3
						quotient: 1.000000						
					</code></pre>
					<p>
						What is causing this? Like most programming languages, C is taking our assignments of the variables
						<span class="monoText">x</span> and <span class="monoText">y</span> literally. A value of type <span class="monoText">int</span> divided by a value of type <span class="monoText">int</span> will return an <span class="monoText">int</span>. Why? Because you cannot fit decimal points into an <span class="monoText">int</span>. C does this by <span class="boldItalics">truncating</span> the result. Thus, the number 1, of value type <span class="monoText">int</span>, divided 2, of value type <span class="monoText">int</span>, will be 0 (C correctly calculates 0.5, but it truncates that value to 0). It is irrelevant that we're saving the result to a variable with value type <span class="monoText">float</span>. C has already computed the result (the math has already been done on the right hand side of the assignment).
					</p>
				</section>

				<section id="casting" class="grid-item">
					<h4>Casting</h4>
					<p>How do we fix the above problem? One way is to go back and change all of the value types:</p>
					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									// Get numbers from user
									float x = get_float("dividend: ");
									float y = get_float("divisor: ");

									// Divide x by y
									float z = x / y;
									printf("quotient: %f\n", z);
								}
							</code></pre>
					<p>
						The problem with this solution is that it is extremely heavy handed. It might be easy to do with a text editor like vim, but even then, there might be valid reason for declaring the variables with
						<span class="monoText">int</span>. Instead of changing all of these data values, we can instead <span class="boldItalics">cast</span> the values. When we <span class="italicsText">cast</span> a value, we convert the value to a different data type.
					</p>
					<pre class="language-c"><code>
									#include &lt;cs50.h&gt;
									#include &lt;stdio.h&gt;
									int main(void)
									{
										// Get numbers from user
										int x = get_int("dividend: ");
										int y = get_int("divisor: ");

										// Divide x by y
										float z = (float) x / (float) y;
										printf("quotient: %f\n", z);
									}
									// Execute the code:
									/*
									make truncation
									./truncation
									dividend: 1
									divisor: 2
									0.500000
									*/
								</code></pre>
					<p>
						We can type cast in C by simply putting in the data type we want in
						<span class="monoText">()</span> next to the variable storing the data, but only if it makes mathematical sense to convert the values.
					</p>
				</section>

				<section id="inherent_values" class="grid-item">
					<h3>Inherent Values in C</h3>
					<p>In C, every non-zero value is equivalent to true, and the value zero equivalent to false. This is a useful point to be aware of; we do not <span class="italicsText">always</span> have to use Boolean expressions.</p>
				</section>

				<section id="variables" class="grid-item">
					<h3>Variables and Syntactic Sugar</h3>
					<h4>Counter</h4>
					<p>
						For the rest of the following materials on C, we will use a
						<span class="boldItalics">counter variable</span>. This variable appears as:
					</p>

					<pre class="language-c"><code>
								int counter = 0;
							</code></pre>

					<p>To increment the counter, we can write:</p>

					<pre class="language-c"><code>
								int counter = 0;
								counter = counter + 1;
							</code></pre>

					<p>Incrementing a counter is so common in C&mdash;as well as many other programming languages&mdash;that there's a much a shorter way of writing the same code above:</p>

					<pre class="language-c"><code>
								int counter = 0;
								counter += 1;
							</code></pre>

					<p>
						The shorter syntax above is an example of
						<span class="boldItalics">syntactic sugar</span>&mdash;a shorter way of writing a statement, providing for easier and less reading. But, there's even more syntactic sugar for the increment statement:
					</p>

					<pre class="language-c"><code>
								int counter = 0;
								counter++;
							</code></pre>

					<p><span class="monoText">counter++</span> is the shortest way to write "increment by 1."</p>
				</section>

				<section id="conditions_introduction" class="grid-item">
					<h3>Conditions</h3>
					<p>
						Recall that
						<span class="boldItalics">conditions</span> are statements that instruct a computer to execute code only if another statement is true or false.
					</p>
				</section>

				<section id="boolean_expressions" class="grid-item">
					<h3>Boolean Expressions</h3>
					<p>Conditions consist of Boolean expressions&mdash;statements that can only evaluate to true or false. There are two kinds Boolean expressions: (1) logical operators, and (2) relational operators. The relational operators consist of the following:</p>
					<figure>
						<table>
							<thead>
								<th>Relational Operator</th>
								<th>Mathematical Notation</th>
							</thead>
							<tbody>
								<tr>
									<td><code class="language-c">x < y</code></td>
									<td>$x < y$</td>
								</tr>
								<tr>
									<td><code class="language-c">x <= y</code></td>
									<td>$x \leq y$</td>
								</tr>
								<tr>
									<td><code class="language-c">x > y</code></td>
									<td>$x > y$</td>
								</tr>
								<tr>
									<td><code class="language-c">x >= y</code></td>
									<td>$x \geq y$</td>
								</tr>
								<tr>
									<td><code class="language-c">z == y</code></td>
									<td>Equality; $x = y$</td>
								</tr>
								<tr>
									<td><code class="language-c">x != y</code></td>
									<td>Inequality; $x \neq y$</td>
								</tr>
							</tbody>
						</table>
					</figure>
				</section>

				<section id="the_if_statement" class="grid-item">
					<h4>The <span class="monoText">if</span> Statement</h4>
					<p>
						The most basic conditional statement in C is the
						<span class="monoText">if</span> statement. The <span class="monoText">if</span> statement will execute the block of code inside its body if, and only if, its Boolean expression is true. The <span class="monoText">if</span> statement takes the following form:
					</p>

					<pre class="language-c"><code>
								if (<span class="code-annotation">Boolean-expression</span>)
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>
						In the above example, the term
						<span class="italicsText">Boolean-expression</span> is a statement that can only be one of two values: <span class="monoText">true</span> or <span class="monoText">false</span>. The term <span class="italicsText">statements</span> refers to the code that C should execute, only if the provided <span class="italicsText">boolean expression</span> is true. For example:
					</p>

					<pre class="language-c"><code>
								if (x < y)
								{
									printf("x is less than y\n");
								}
							</code></pre>

					<p>
						Above, C will only print "x is less than y" only if
						<span class="monoText">x < y</span> is true.
					</p>
				</section>

				<section id="the_else_statement" class="grid-item">
					<h4>The <span class="monoText">else</span> Statement</h4>
					<p>
						Boolean expressions only have one or two values&mdash;true or false. The
						<span class="monoText">if</span> statement will execute code only if its Boolean expression is true. Often times, however, we need to specify what the program should <span class="italicsText">if</span> the expression is false. To provide for what happens when the expression is false, we use an <span class="monoText">else</span> statement. It takes the following form:
					</p>

					<pre class="language-c"><code>
								if (<span class="code-annotation">Boolean-expression</span>)
								{
									<span class="code-annotation">statements</span>;
								}
								else
								{
									<span class="code-annotation">statements</span>
								}
							</code></pre>

					<p>The <span class="monoText">else</span> statement is <span class="underlineText">always</span> accompanied by an <span class="monoText">if</span> statement, and <span class="underlineText">always</span> comes after the <span class="monoText">if</span> statement. Illustrating the <span class="monoText">else</span> statement's form:</p>

					<pre class="language-c"><code>
								if (x < y)
								{
									printf("x is less than y\n");
								}
								else
								{
									printf("x is not less than y\n");
								}
							</code></pre>

					<p>The <span class="monoText">if</span> and <span class="monoText">else</span> statements are what we use when there are only two possibilities&mdash;on or off; yes or no; black or white; true or false. What if there are multiple possibilities?</p>
				</section>

				<section id="the_else_if_statement" class="grid-item">
					<h4>The <span class="monoText">else if</span> Statement</h4>
					<p>
						If there are multiple possibilities, then we have multiple conditions to test for. For these situations, we indicate the multiple conditions with the
						<span class="monoText">else if</span> statement:
					</p>

					<pre class="language-c"><code>
								if (<span class="code-annotation">Boolean-expression-A</span>)
								{
									<span class="code-annotation">statements</span>;
								}
								else if (<span class="code-annotation">Boolean-expression-B</span>)
								{
									<span class="code-annotation">statements</span>;
								}
								else
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>
						In the above syntax, C will test for the first condition,
						<span class="italicsText">Boolean-expression-A</span>. If that expression is false, it goes down and tests the next condition, <span class="italicsText">Boolean-expression-B</span>. If that expression is false, it executes the statements in the <span class="monoText">else</span> statement. Illustrating this syntax:
					</p>

					<pre class="language-c"><code>
								if (x < y)
								{
									printf("x is less than y\n");
								}
								else if (x > y) 
								{
									printf("x is greater than y\n");
								}
								else if (x == y)
								{
									printf("x is equal to y\n");
								}
							</code></pre>

					<p>Note the use of <span class="monoText">==</span>. This is the <span class="boldItalics">equality operator</span>&mdash;it tests for equality. This should clear up any confusion we have about assignment. <span class="monoText">=</span> is assignment, and <span class="monoText">==</span> is equality.</p>
					<p>Note that in the above code, we are comparing numbers. Logically, there are only three possibilities: $x < y$, $x > y$, and $x = y$. Because there are only three possibilities, we can instead write the code above as:</p>

					<pre class="language-c"><code>
								if (x < y)
								{
									printf("x is less than y\n");
								}
								else if (x > y) 
								{
									printf("x is greater than y\n");
								}
								else
								{
									printf("x is equal to y\n");
								}
							</code></pre>

					<p>When the <span class="monoText">if</span>, <span class="monoText">else if</span>, and <span class="monoText">else</span> statements are used together, we can think of them working together as such:</p>
					<ul>
						<li>The <span class="monoText">if</span> statement tests for the first condition.</li>
						<li>The <span class="monoText">else if</span> statement tests for another condition.</li>
						<li>The <span class="monoText">else</span> statement sets the default statements to execute&mdash;what C should do when all of the conditions are false.</li>
					</ul>
				</section>

				<section id="multiple_if_statements" class="grid-item">
					<h4>Mutual Exclusivity in <span class="monoText">if</span> and <span class="monoText">else</span> Statements</h4>
					<p>
						In some situations, we might want to write multiple
						<span class="monoText">if</span> statements, followed by an <span class="monoText">else</span> statement. For example:
					</p>

					<pre class="language-c"><code>
								if (<span class="code-annotation">BooleanExpression1</span>)
								{
									<span class="code-annotation">statements</span>;
								}
								if (<span class="code-annotation">BooleanExpression2</span>)
								{
									<span class="code-annotation">statements</span>;
								}
								if (<span class="code-annotation">BooleanExpression3</span>)
								{
									<span class="code-annotation">statements</span>;
								}
								else
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>In the code above, the the first two Boolean expressions are entirely separate <span class="monoText">if</span> statements that can be satisfied on their own. Only when we get to the get to the last <span class="monoText">if</span> statement are we concerned with the <span class="monoText">else</span> statement. In C, an <span class="monoText">else</span> statement only binds to the nearest <span class="monoText">if</span> statement.</p>
				</section>

				<section id="ternary_operator" class="grid-item">
					<h3>The Ternary Operator <span class="monoText">? :</span></h3>
					<p>If we only have one condition to test for as an "exception" to the default code block to execute (i.e., "If this, do this, otherwise do this"), we might write the following:</p>

					<pre class="language-c"><code>
								int x;
								if (<span class="code-annotation">BooleanExpression</span>)
								{
									x = 5;
								}
								else
								{
									x = 6;
								}
							</code></pre>

					<p>But, since there are only two test cases, we can shorten the above code by using a <span class="boldItalics">ternary operator</span>:</p>

					<pre class="language-c"><code>
								int x = (<span class="code-annotation">BooleanExpression</span>) ? 5 : 6;
							</code></pre>

					<p>The code above essentially says, "If the Boolean expression evaluates to true, assign to <span class="monoText">x</span> the value <span class="monoText">5</span>; otherwise, assign to <span class="monoText">x</span> the value <span class="monoText">6</span>.</p>
				</section>

				<section id="the_switch_statement" class="grid-item">
					<h3>The <span class="monoText">switch</span> Statement</h3>
					<p>The <span class="monoText">switch</span> statement allows us to specify distinct cases. It is a conditional statement that enumerates discrete, or unique, cases. This feature allows us to test for cases rather than relying on Boolean expressions. To use the <span class="monoText">switch</span> statement, the keyword <span class="monoText">break</span> generally be included, in order to prevent C from continuing to execute the code (i.e., stop testing and executing code blocks once a case is met). Of course, if we wanted C to test every single case, we can simply omit the <span class="monoText">break</span> keyword.</p>

					<pre class="language-c"><code>
								int x = get_int();
								switch(x)
								{
									case 1:
										printf("One!\n");
									case 2:
										printf("Two!\n");
									case 3:
										printf("Three!\n");
									default:
										printf("Sorry!\n");
								}
							</code></pre>

					<p>
						In the example above, we used the keyword
						<span class="monoText">default</span>. This is the "default case"&mdash;if none of the cases are met, execute the code under the default case.
					</p>
				</section>

				<section id="combining_boolean_expressions" class="grid-item">
					<h3>Combining Boolean Expressions</h3>
					<p>
						In the previous examples, we had simple Boolean expressions. Boolean expressions, however, are not always composed of just one condition. Instead, they usually take the form "If A
						<span class="italicsText">and</span> B, then C." Or, "If P <span class="italicsText">or</span> Q, then R. Consider, for example, the code below, that prints out "Voted yes" or "Voted no", depending on whether the user inputs the characters "y" or "n":
					</p>

					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
								char c = get_char("Do you vote yes or no? ");
								if (c = "y")
								{
									printf("You voted yes.\n");
								}
								else if (c = "n")
								{
									printf("You voted no.\n");
								}
							}	
							</code></pre>

					<p>There are several problems with the program above:</p>
					<ol>
						<li>
							The assignment operator
							<span class="monoText">=</span> was used instead of equality <span class="monoText">==</span>.
						</li>
						<li>
							Double quotes were used for the characters. In C, the type
							<span class="monoText">char</span> must be be indicated with single quotes <span class="monoText">''</span>.
						</li>
						<li>
							The program does not consider the possibility of the user entering
							<span class="monoText">Y</span> or <span class="monoText">N</span>. Remember, every unique character has a different encoding&mdash;<span class="monoText">y</span>, <span class="monoText">Y</span>, <span class="monoText">n</span>, and <span class="monoText">N</span> are all different characters to C.
						</li>
					</ol>
					<p>Problems 1 and 2 are easy and straightforward to change. Problem 3, however, has multiple solutions. One way is to simply test for each of the characters.</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									char c = get_char("Do you vote yes or no? ");
									if (c == 'y')
									{
										printf("You voted yes.\n");
									}
									else if (c == 'Y')
									{
										printf("You voted yes.\n");
									}
									else if (c == 'n')
									{
										printf("You voted no.\n");
									}
									else if (c == 'N')
									{
										printf("You voted no.\n");
									}
								}	
								</code></pre>

					<p>
						A better way, however, is to use the
						<span class="monoText">||</span> operator, which stands for the logical <span class="italicsText">or</span>.
					</p>
				</section>

				<section id="the_logical_or" class="grid-item">
					<h4>Logical OR: <span class="monoText">||</span></h4>
					<p>The <span class="monoText">||</span> operator tests whether <span class="underlineText">at least one</span> of a set of Boolean expressions is true. If just one of the expressions is true, the entire condition is true. The <span class="monoText">||</span> operator is written as:</p>

					<pre class="language-c"><code>
								<span class="code-annotation">Boolean-expression1</span> || <span class="code-annotation">Boolean-expression2</span>
							</code></pre>

					<p>With the <span class="monoText">||</span> operator, we can shorten the preceding program:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									char c = get_char("Do you vote yes or no? ");
									if (c == 'y' || c == 'Y')
									{
										printf("You voted yes.\n");
									}
									else if (c == 'n' || c == 'N')
									{
										printf("You voted no.\n");
									}
								}	
								</code></pre>
				</section>

				<section id="the_logical_and" class="grid-item">
					<h4>Logical AND: <span class="monoText">&&</span></h4>
					<p>
						Similarly, we can combine Boolean expressions with the
						<span class="monoText">&&</span> operator, which tests if <span class="underlineText">all</span> of the Boolean expressions in a condition are true. If <span class="underlineText">just one</span> of the expressions is false, then the entire condition is false. The <span class="monoText">&&</span> operator takes the form:
					</p>

					<pre class="language-c"><code>
								<span class="code-annotation">Boolean-expression1</span> && <span class="code-annotation">Boolean-expression2</span>
							</code></pre>
				</section>

				<section id="loops" class="grid-item">
					<h3>Loops in C</h3>
					<p>There are many algorithms we use that require repetitions of the same step over and over. An assembly line of workers, for example, might require one worker to solder one component, then pass the board to the next worker, who solders on another component. While these tasks can take their tolls on humans workers, they are comfortably handled by computers (to the extent of its processing power) through <span class="boldItalics">loops</span>. A <span class="italicsText">loop</span> is a statement that tells a computer to execute a particular line or block of code over and over again, either forever, for a set amount of iterations, or until a condition is false. These possibilities of looping are accounted for by different types of loops.</p>
				</section>

				<section id="while_loop" class="grid-item">
					<h4>The <span class="monoText">while</span> Loop</h4>
					<p>The <span class="monoText">while</span> loop is a loop that says, "Execute this code as long as this condition is true." The <span class="monoText">while</span> loop takes the form:</p>

					<pre class="language-c"><code>
								while (<span class="code-annotation">Boolean-expression</span>)
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>As with the <span class="monoText">if</span>, <span class="monoText">else if</span>, and <span class="monoText">else</span> statements, the Boolean expression we pass in between the parentheses is an expression that can only evaluate to either <span class="monoText">true</span> or <span class="monoText">false</span>.</p>
					<p>
						As long as the Boolean expression is true, C will continue executing the statements inside the
						<span class="monoText">while</span> loop's body. This is a critical point to always keep in mind. If the Boolean expression never returns false, C will always stay where it is&mdash;inside the <span class="monoText">while</span> loop, executing the statements over and over again.
					</p>
					<p>
						If, for some reason, we want a loop to
						<span class="underlineText">always</span> run (an <span class="boldItalics">infinite loop</span>), we write:
					</p>

					<pre class="language-c"><code>
								while (true)
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>
				</section>

				<section id="finite_loops_with_while_loops" class="grid-item">
					<h5>
						Looping a Finite Amount of Times with a
						<span class="monoText">while</span> Loop
					</h5>
					<p>If we wanted to execute statements an $x$ amount of times, we can use a <span class="monoText">while</span> loop with a counter (counting how many times C should <span class="boldItalics">iterate</span>, or go through the loop). In programming as a whole, a counter is usually declared with the identifier <span class="monoText">i</span>. Thus:</p>

					<pre class="language-c"><code>
								int i = 0;
								while (i < 50)
								{
									<span class="code-annotation">statements</span>;
									i++;
								}
							</code></pre>

					<p>
						In the code above, we declared the variable
						<span class="monoText">i</span>, and assigned it the value 0 of type <span class="monoText">int</span>. We are effectively saying the counter (<span class="monoText">i</span>) starts at 0. Then, in the <span class="monoText">while</span> loop, we provide the condition that, as long as <span class="monoText">i</span> (the counter) is less than <span class="monoText">50</span>, execute the <span class="italicsText">statements</span>. Inside the <span class="monoText">while</span> loop's body, we have the <span class="italicsText">statements</span>. After each execution of the <span class="italicsText">statements</span>, we increment <span class="monoText">i</span> (the counter) by <span class="monoText">1</span>. Once C has incremented, it goes back and checks the condition. If it's true, it continues. This goes on over and over until <span class="monoText">i</span> is incremented to <span class="monoText">50</span>, in which case the Boolean expression
						<span class="monoText">(i < 50)</span> is no longer true, and C exits the loop. This means that the last execution of the code was <span class="monoText">i = 49</span>, and since we started at <span class="monoText">i = 0</span>, there was a grand total of 50 iterations.
					</p>

					<p>
						Alternatively, we can start the counter at
						<span class="monoText">i = 1</span>. In which case, since we want C to iterate 50 times, we need C to continue an execution past <span class="monoText">i = 49</span>; <span class="monoText">i = 50</span>. Thus, we would write:
					</p>

					<pre class="language-c"><code>
								int i = 1;
								while (i <= 50)
								{
									<span class="code-annotation">statements</span>;
									i++;
								}
							</code></pre>

					<p>
						While the above is logically correct, it is generally not well-received in the computer science community. In computer science, we always start counting at 0. Moreover, there is one less character when beginning with
						<span class="monoText">i = 0</span>.
					</p>

					<p>If, for whatever reason, we wanted the counter to resemble a countdown, we can write the loop as:</p>

					<pre class="language-c"><code>
								int i = 50;
								while (i > 0)
								{
									<span class="code-annotation">statements</span>;
									i--;
								}
							</code></pre>

					<p>Like the previous example, this too is unconventional, and owing to its uncommon usage, is generally not advised unless there is a valid reason for writing the loop as such.</p>

					<p>
						But, there's a more concise way to write a finite loop using a different loop syntax&mdash;the
						<span class="monoText">for</span> loop.
					</p>
				</section>

				<section id="the_for_loop" class="grid-item">
					<h4>The <span class="monoText">for</span> Loop</h4>
					<p>The <span class="monoText">for</span> loop is very similar to the <span class="monoText">while</span> loop, and has the following syntax;</p>

					<pre class="language-c"><code>
								for (<span class="code-annotation">statements</span>)
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>
						Notice in the above syntax that inside the parentheses, we have
						<span class="italicsText">statements</span> instead of <span class="italicsText">Boolean-expression</span>. This is because the <span class="monoText">for</span> loop is not limited to Boolean expressions; we can initialize variables, write Boolean expressions, as well as change values assigned to variables inside the parentheses. Using the <span class="monoText">for</span> loop to write a finite loop:
					</p>

					<pre class="language-c"><code>
								for (int counter = 0; i < 50; i++)
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>
						The above is the most conventional way to write a finite loop in C, as well as other programming languages. Although it looks different from a
						<span class="monoText">while</span> loop syntactically, the process is the same: Start the counter at 0 (<span class="monoText">i = 0</span>). Is <span class="monoText">i < 50</span> true? Yes, <span class="monoText">i = 0</span>. Execute the <span class="italicsText">statements</span>, and increment (<span class="monoText">i++</span>). <span class="monoText">i</span> is now <span class="monoText">1.</span> Is <span class="monoText">i < 50</span>? Yes, <span class="monoText">i = 1</span>. Execute the <span class="italicsText">statements</span>, and increment (<span class="monoText">i++</span>). This is done over and over again until C reaches <span class="monoText">i = 50</span>, where <span class="monoText">i < 50</span> is false.
					</p>
				</section>

				<section id="why_loops_are_useful" class="grid-item">
					<h5>Using a Loop</h5>
					<p>Loops are gateways to better-designed code. Suppose we were to write a program that prints "Woof" three times. We might write the program as such:</p>

					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							int main(void)
							{
								printf("woof\n");
								printf("woof\n");
								printf("woof\n");
							}	
							</code></pre>

					<p>
						What's the problem with the above code? While it is logically correct, it is
						<span class="italicsText">poorly designed</span>. We simply copy and pasted <span class="monoText">printf("Woof\n");</span> three times. The rule of thumb in programming is, if you find yourself copying and pasting lines of code in your program multiple times, chances are, it's poorly designed.
					</p>
					<p>
						Instead of copying and pasting the statement above, we can simply write it in a
						<span class="monoText">for</span> loop:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									for (int i = 0; i < 3; i++)
									{
										printf("woof\n");
									}
								}	
								</code></pre>
				</section>

				<section id="use_cases_for_loops" class="grid-item">
					<h4>When to Use Each of the Loops</h4>
					<p>The table below presents the general uses cases for each of the loops.</p>
					<figure>
						<table>
							<thead>
								<th>Loop</th>
								<th>Use Case</th>
							</thead>
							<tbody>
								<tr>
									<td><span class="monoText">while</span></td>
									<td>Use when we want a loop to repeat an unknown amount of times, or possibility not at all.</td>
								</tr>
								<tr>
									<td><span class="monoText">do while</span></td>
									<td>Use when we want a loop to repeat an unknown amount of times, but at least once.</td>
								</tr>
								<tr>
									<td><span class="monoText">for</span></td>
									<td>Use when we want a loop to repeat a discrete number of times, but we may not know the number at the moment the program is compiled.</td>
								</tr>
							</tbody>
						</table>
					</figure>
				</section>

				<section id="functions" class="grid-item">
					<h3>Functions in C</h3>
					<p>When we write code, there are often many blocks of code that need to be reused over and over again. Not only is rewriting these blocks meticulous, it can lead to readability issues. It is because of these issues that we have functions. Functions allow us to "reuse" code. Having this ability allows us to achieve the following:</p>
					<ol>
						<li>Organization. Functions break down a complicated problem into smaller, more manageable parts.</li>
						<li>Simplification. Smaller components make programs easier to design, implement, and debug.</li>
						<li>Reusability. Functions can be reused; we only need to write them once to use them anywhere else in a program.</li>
					</ol>

					<h4>Function Declaration</h4>
					<p>
						The first step to creating a function is to
						<span class="boldItalics">declare</span> it. Declaring a function essentially tells the compiler, "This is a function." In C, function declarations always appear at the top of the code, before writing anything else in <span class="monoText">main()</span>. Function declarations follow the syntactical format:
					</p>

					<pre class="language-c"><code>
								returnType functionName(argument, argument);
							</code></pre>

					<p>The <span class="monoText">returnType</span> is the data type of the variable the function will output. The <span class="monoText">functionName</span> is the function's identifier; what we will call the function. Function names should be short, concise, and indicative of what the function does. Abiding by this principle will save time on trying to recall what a particular function does. The <span class="monoText">arguments</span>, or <span class="italicsText">parameters</span>, is a comma separated list (if more than one input) of the inputs the function will take, each of which must be given a type and a name.</p>

					<h5>Function Parameters</h5>
					<p>
						Functions can take inputs. For example, the statement
						<span class="monoText">func(a, b, c)</span> is a function named <span class="monoText">func</span>, taking three inputs (called the <span class="boldItalics">parameters</span>). When these inputs are passed, they are called <span class="boldItalics">parameters</span>. Once we pass the inputs <span class="monoText">a</span>, <span class="monoText">b</span>, and <span class="monoText">c</span>, the function <span class="monoText">func</span> processes those inputs in some way, and gives back an output.
					</p>
					<p>
						Note that we need to be careful about the data types for each of the variables. If a function takes two
						<span class="monoText">int</span> type inputs, we can expect it to output an <span class="monoText">int</span> type output, unless we <span class="italicsText">cast</span> the output.
					</p>

					<h4>Function Definition</h4>
					<p>
						Once we have declared a function, the second step is to
						<span class="boldItalics">define</span> it. To define a function, we use the following syntax:
					</p>

					<pre class="language-c"><code>
								returnType functionName(argument, argument)
								{
									code generating output;
									return output;
								}
							</code></pre>

					<h4>Calling a Function</h4>
					<p>With the function declared and defined, we can call it anywhere we would like in our program. All we need to do is pass arguments to the function when we use it. For example:</p>

					<pre class="language-c"><code>
								// Declare the function
								int sum_two_ints(int a, int b);
								int main(void)
								{
									// ask user for input
									printf("First integer: ");
									int x = get_int();
									printf("Second integer: ");
									int y = get_int();

									// add the two numbers by calling the function:
									int z = sum_two_ints(x, y);

									// Output the result:
									printf("%i + %i = %i", x, y, z);
								}

								// The function definition
								int sum_two_ints(int a, int b)
								{
									int sum = a + b;
									return sum;
								}
							</code></pre>

					<p>Returning to the <span class="monoText">woof</span> program, instead of writing <span class="monoText">printf("Woof\n");</span> inside the <span class="monoText">for</span> loop, a better way would be to store the code <span class="monoText">printf("Woof\n");</span> in a <span class="boldItalics">function</span>&mdash;code that can be reused.</p>
					<p>To do so, we write the following:</p>

					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							void woof(void)
							{
								printf("woof\n");
							}
							int main(void)
							{
								for (int i = 0; i < 3; i++)
								{
									woof();
								}
							}	
							</code></pre>

					<p>
						In the above example, we stored the code
						<span class="monoText">printf("woof\n");</span> in a function, and we <span class="boldItalics">called</span> it (told C to execute the function) in the <span class="monoText">for</span> loop. This is a much better designed program.
					</p>
					<p>As an aside, the term "functions" is synonymous with "procedures," "methods," and "subroutines" in other languages.</p>
					<p class="subheading-1">Style Point</p>
					<p>By convention, we place functions at the bottom of the program. This is because when humans read text, they generally read it top to bottom. Much like how we look at call numbers for footnotes, a program makes more sense when its primary content is presented first, with extraneous material placed last. So, the above program would be <span class="italicsText">better styled</span> by writing:</p>

					<pre class="language-c"><code>
							#include &lt;cs50.h&gt;
							#include &lt;stdio.h&gt;
							void woof(void);

							int main(void)
							{
								for (int i = 0; i < 3; i++)
								{
									woof();
								}
							}	
							
							void woof(void)
							{
								printf("woof\n");
							}
							</code></pre>

					<p>
						Notice that at the very top of the code above, we included the code
						<span class="monoText">void woof(void);</span>. This is because C can only read programs top to bottom. If we did not include <span class="monoText">void woof(void);</span> before the <span class="monoText">for</span> loop, C would reach the <span class="monoText">for</span> loop, encounter <span class="monoText">woof();</span>, and have no idea what we're talking about, because the function comes <span class="italicsText">after</span> the call. That statement at the very top, <span class="monoText">void woof(void);</span> is called a <span class="boldItalics">prototype</span>&mdash;a statement that simply tells C, "There will be a function called "woof()", but you're going to see it later.
					</p>

					<h4>Passing an Argument into the Function</h4>
					<p>
						Now suppose that we do not want to keep writing a
						<span class="monoText">for</span> loop over and over again. Instead, we want to just pass a number into parentheses in <span class="monoText">woof();</span> and have it print <span class="monoText">woof</span> that many times. E.g., <span class="monoText">woof(3);</span> will print <span class="monoText">woof</span> three times.
					</p>
					<p>
						First, note that the
						<span class="monoText">void</span> keyword refers to the <span class="boldItalics">return value</span>, or <span class="italicsText">output</span>, of the function. At the moment, the <span class="monoText">woof()</span> function has no return value. But, it does have an input&mdash;<span class="monoText">void meow()</span>&mdash;things can be passed into the parentheses. In C, to indicate we want an input for the function, we simply put in the <span class="monoText">type</span> we want, and its identifier:
					</p>

					<pre class="language-c"><code>
								void woof(int n)
								{
									for (int i = 0; i < n; i++)
									{
										printf("woof\n"); 
									}
								}
							</code></pre>

					<p>
						When we require a function to take inputs, or
						<span class="boldItalics">arguments</span>, we say that the function has <span class="boldItalics">parameters</span>.
					</p>
				</section>

				<section id="do_while_loop" class="grid-item">
					<h3>The <span class="monoText">do while</span> Loop</h3>
					<p>The <span class="monoText">do while</span> loop is a loop that executes specified code <span class="underlineText">before</span> checking if a condition is met. This effectively ensures that a particular line of code is always run before a condition is checked.</p>
					<p>
						For example, suppose we wanted the user to input a positive integer into the
						<span class="monoText">woof()</span> function, so that when function is executed, a certain number of "woof" is printed. How do we go about getting a positive integer from the user?
					</p>
					<p>
						First, we have a way of getting inputs from the user, the
						<span class="monoText">get_int()</span> function. No problem there. Next problem: How do we ensure that the input from the user is a positive integer? Well, think about the set of positive integers. What property do they all have in common? They are all greater than 0. This is a perfect use case for the <span class="monoText">do while</span> loop. We want to get a user's input, then check (with a <span class="monoText">while</span> loop), if the user's input is less than 1. If the user's input is less than 1, then the input is not a positive integer, so we again ask for the user's input. We do this over and over again, as long as the user's input is less than 1. Once the user inputs a number greater than or equal to 1, we <span class="monoText">return</span> that number as an output of the function Putting it all together:
					</p>

					<pre class="language-c"><code>
								int get_positive_int(void)
								{
									int n;
									do
									{
										n = get_int("Positive integer: ");
									}
									while (n < 1);
									return n;
								}
							</code></pre>
				</section>

				<section id="brief_point_scope" class="grid-item">
					<h4>Scope</h4>
					<p>
						Question: Why did we declare the variable
						<span class="monoText">n</span> outside the <span class="monoText">do while</span> loop? Why didn't we write instead:
					</p>

					<pre class="language-c"><code>
								int get_positive_int(void)
								{
									do
									{
										int n = get_int("Positive integer: ");
									}
								}
							</code></pre>

					<p>
						We did not write the program this way because of the issue of
						<span class="monoText">scope</span>. The scope of a variable consists of the lines of code where the variable can be used, or, anthropomorphically, where C can "see" the variable. If the variable <span class="monoText">n</span> where declared inside the curly braces <span class="monoText">{}</span>, then it <span class="underlineText">only</span> exists inside the curly braces. Once we exit the curly braces, the variable no longer exists. The work around is to declare the variable before the function, so that it exists before the lines of code.
					</p>

					<h5>Types of Scope</h5>
					<p>
						There are two types of scope:
						<span class="boldItalics">global scope</span> and <span class="boldItalics">local scope</span>. A <span class="boldItalics">local variable</span> is a variable declared in the local scope. These are variables that can only be accessed within the functions where they are created. A <span class="boldItalics">global variable</span> is a variable declared in the global scope. A global variable is one that can be accessed by any function in the program. Global variables can be accessed by anything anywhere in our program because they are not limited to a particular function.
					</p>
					<p>For example, here is a global variable:</p>

					<pre class="language-c"><code>
								float global_variable = 3.14;
								int main void()
								{
									<span class="code-annotation">global_var can be used here</span>
								}
								void function(void)
								{
									<span class="code-annotation">global_var can also be used here</span>
								}
							</code></pre>

					<p>Another example of a global variables:</p>

					<pre class="language-c"><code>
								float global = 0.5050;
								int main(void)
								{
									triple();
									printf("%f\n", global);
								}
								void triple (void)
								{
									global *= 3;
								}
							</code></pre>

					<p>
						In the code above, the variable
						<span class="monoText">global</span> is a <span class="boldText">global</span> variable. The functions <span class="monoText">main()</span> and <span class="monoText">triple()</span> can see and use <span class="monoText">global</span>.
					</p>
					<p>Here is a local variable:</p>

					<pre class="language-c"><code>
								int main(void)
								{
									local_var = 4;
									local_var = sqrt(local_variable);
									<span class="code-annotation">local_var has been changed but change remains inside the function</span>
								}							
							</code></pre>

					<p>Here is another example of a local variable:</p>

					<pre class="language-c"><code>
								int main(void)
								{
									int result = triple(5);
								}
								
								int triple(int x)
								{
									return x * 3;
								}
							</code></pre>

					<p>In the code above, the variable <span class="monoText">x</span> is <span class="boldText">local</span> to the function <span class="monoText">triple()</span>. No other function (e.g., <span class="monoText">main()</span>) can see and use <span class="monoText">x</span>.</p>
					<p>Similarly, variable <span class="monoText">result</span> is <span class="boldText">local</span> to the function <span class="monoText">main()</span>. The function <span class="monoText">triple()</span> cannot see and use <span class="monoText">result</span>.</p>

					<h5>Global vs. Local Variables</h5>
					<p>We need to be careful with global variables. While they can be extremely useful, since every function has access to the variable, we can easily have a situation where a one function changes the value assigned to the variable, which in turn affects all of the other functions depending on it.</p>
					<p>
						In C, local variables are referred to as
						<span class="boldItalics">passed by value</span> in function calls. This means that when the variable is used by the <span class="boldItalics">callee</span> (the function using the variable), the callee does not actually use the variable. It uses instead a <span class="underlineText">copy</span> of the variable. This further means that the variable in the <span class="boldItalics">caller</span>&mdash;the function calling the function that uses the function&mdash;is unchanged. This is the crucial difference between local variables and global variables. Because the callee does not actually use the variable, any changes it makes to the variable remain inside it&mdash;they do not pass through to the other functions, the way global variables do.
					</p>
					<p>For example:</p>

					<pre class="language-c"><code>
								int main(void)
								{
									int foo = 4;
									triple(foo);
								}
								int triple(int x)
								{
									return x *= 3;
								}
							</code></pre>

					<p>The variable <span class="monoText">foo</span> in the code above is <span class="underlineText">not</span> changed at all. This is because <span class="monoText">foo</span> is local to <span class="monoText">main()</span>. If, however, we wrote:</p>

					<pre class="language-c"><code>
								int main(void)
								{
									int foo = 4;
									foo = triple(foo);
								}

								int triple(int x)
								{
									return x *= 3;
								}
							</code></pre>

					<p>then the value of <span class="monoText">foo</span> changes. Why? Because it has now been overwritten by <span class="monoText">main()</span>&mdash;we wrote <span class="monoText">foo = triple(foo)</span>.</p>
					<p>
						Variable scope is generally not a problem if we give
						<span class="italicsText">unique names</span> to our variables. It can quickly become problematic when we have different variables with the same name.
					</p>
				</section>

				<section id="the_return_statement" class="grid-item">
					<h3>The <span class="monoText">return</span> Statement</h3>
					<p>
						Notice that in the above code example, we used the word
						<span class="monoText">return</span>. This is a keyword that tells C to <span class="italicsText">return</span>, or output, a value. In the code below, <span class="monoText">return</span> value, stored in a variable called <span class="monoText">n</span>, can be used and stored anywhere in our program. Because it can be used and stored elsewhere, we can now use it as a counter for our loop. Thus:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								int get_positive_int(void); // The function's prototype
								
								int main(void)
								{
									int i = get_positive_int();
									
								}

								int get_positive_int(void)
								{
									int n;
									do
									{
										n = get_int("Positive integer: ");
									}
									while (n < 1);
									return n;
								}
							</code></pre>
				</section>

				<section id="limitations_of_computers" class="grid-item">
					<h3>Limitations of Computers</h3>
					<p>
						There are limitations to computers. In modern computers (a desktop, laptop, phone, tablet, mp3 player, etc.) there is a piece of hardware called the
						<span class="boldItalics">RAM</span> ("Random Access Memory"). Whenever you execute a program, that program is stored in the RAM. The RAM, however, has a finite amount of memory. This means that the computer can only handle so many programs, or programs that require so much memory. When we look at the way C handles computing a quotient with multiple decimal places.
					</p>

					<pre class="language-c"><code>
								int main(void)
								{
									float x = get_float("x: ");
									float y = get_float("y: ");
									printf("%.10f\n", x / y);
								}
								// Running the code above:
					</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
						x: 1	
						y: 10
						0.1000000015
						# Running it again:
						x: 1
						y: 10
						0.1000000149011611938476562500	
					</code></pre>

					<p>These are certainly not right. $\frac{1}{10}$ is 0.1&mdash;it does not include any of those additional digits. Why is this happening? Recall that computers can only store data with a finite number of bits. This means that computers can only count to so many places, and can only compute data to only so much precision. Once a number exceeds the numbers of bits afforded to it, the computer must begin approximating. This is not a huge problem for most day-to-day tasks and projects, but it can be significant problem for those working in number-sensitive fields&mdash;mathematics and scientific experiments, military, finance, etc.</p>
					<p>This finite memory problem was apparent in the year 2000 (Y2K). At the time, computers were representing years in two digits (e.g., 1995 to 95, 1996 to 96, etc). The concern was that when the clock hit midnight and the year 2000 came along, the computers would not be able to represent the year, since 2000 would be represented as 00 (representing the year 1900). While the bug may have been overblown by the media, it did cause significant problems for many computer users. This is going to happen again on January 19, 2038. This is because computer scientists decided that computers would use 32 bits to represent numbers, and as such, 32 bits to represent the number of seconds from the date January 1, 1970. The problem? 32 bits only allow us to count up to about 4 billion. That number is expected to hit in January 19, 2038.</p>
				</section>
			
			<!-- ยง Compiling -->

				<section id="compiling" class="grid-item">
					<h3>Compiling in C</h3>
					<p>
						In the previous sections, we wrote a simple
						<span class="monoText">helloWorld</span> program:
					</p>

					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;
							int main(void)
							{
								printf("hello, world\n");
							}
						</code></pre>

					<p>
						But, in order to actually execute the code, we had to
						<span class="boldItalics">compile</span> the code&mdash;translating the code into 0s and 1s that the computer can understand. And to do so, we had to write the following:
					</p>
					<pre class="command-line language-bash" data-output=""><code>
							make helloWorld
							./helloWorld
						</code></pre>
					<p>The command <span class="monoText">make</span> is actually automating a series of steps. When we run the <span class="monoText">make</span> command, we see the following output:</p>

					<pre class="language-c"><code>
							/*
							clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow    hello.c  -lcrypt -lcs50 -lm -o hello	
							*/
						</code></pre>
					<p>Let's explore what some of the words above mean.</p>
				</section>

				<section id="clang" class="grid-item">
					<h3><span class="monoText">clang</span></h3>
					<p>
						The presence of the word
						<span class="monoText">clang</span> indicates that the command <span class="monoText">make</span> is automating a command called <span class="monoText">clang</span>. <span class="monoText">clang</span> is a special program&mdash;the compiler. And as we know, the compiler converts source code into machine code. What if we used <span class="monoText">clang</span> instead of make to compile the program?
					</p>

					<pre class="language-c"><code>
							clang helloWorld.c
						</code></pre>

					<p>If we execute the command above, nothing happens. But, in our directory:</p>

					<pre class="command-line language-bash" data-output="2"><code>
								ls
								a.out*  helloWorld.c
							</code></pre>

					<p>There's a new file, <span class="monoText">a.out*</span>. What is this file? Historically (when computers just started growing popular in use), every program would output a file, and its name was <span class="monoText">a.out</span> ("assembly output"). This file itself is not very useful. We can, however, obtain a more useful result by modifying <span class="monoText">clang</span>. And indeed, we can modify <span class="monoText">clang</span> by including <span class="boldItalics">command line arguments</span>:</p>

					<pre class="command-line language-bash" data-output=""><code>
								clang -o helloWorld helloWorld.c
							</code></pre>

					<p>
						In the above statement, we passed the argument
						<span class="monoText">-o</span>, and the argument <span class="monoText">hello</span>. The argument <span class="monoText">-o</span> stands for "output" (i.e., "please output the following"). What do we want to output? <span class="monoText">hello</span>. This entire command essentially says, "Execute <span class="monoText">clang</span>, output (<span class="monoText">-o</span>) a file named <span class="monoText">hello</span>, using the input <span class="monoText">hello.c</span>.
					</p>
					<p>If we execute the command above, nothing happens (a good sign) and when we run <span class="monoText">ls</span> in the terminal:</p>

					<pre class="command-line language-bash" data-output=""><code>
								ls
								hello* hello.c
							</code></pre>

					<p>Now suppose we had the following code:</p>

					<pre class="language-c"><code>
								#include &lt;cs50&gt;
								#include &lt;stdio.h&gt;	
								int main(void)
								{
									string name = get_string("What's your name? ");
									printf("hello, %s\n", name);
								}
							</code></pre>

					<p>If we execute the following:</p>

					<pre class="command-line language-bash" data-output=""><code>
								clang -o hello hello.c
							</code></pre>

					<p>we get this output:</p>

					<pre class="language-c"><code>
								/*
								/usr/bin/ld: /tmp/hello-20893c.o: in function `main':
								hello.c:(.text+0x19): undefined reference to `get_string'
								clang-10: error: linker command failed with exit code 1 (use -v to see invocation)						
								*/
							</code></pre>

					<p>
						What's happening here? Looking at the code, we can see that something's gone wrong with
						<span class="monoText">get_string</span>. This is happening because sometimes it is not enough to simply include the header file, in this case <span class="monoText">cs50.h</span>, at the top the program&mdash;we need to actually tell the computer where to find the 0s and 1s that implement the function <span class="monoText">get_string</span>. This is why we see the error <span class="monoText">undefined reference to `get_string'</span>. When simply write <span class="monoText">#include &lt;cs50&gt;</span> at the top of our program, all that tells the compiler is that the function exists. It doesn't tell the compiler <span class="italicsText">where</span> the function is.
					</p>
					<p>
						To tell the compiler where the function is, we need to actually write that statement &mdash;
						<span class="monoText">clang</span> needs an additional argument:
					</p>

					<pre class="command-line language-bash" data-output=""><code>
								clang -o hello hello.c -lcs50
							</code></pre>

					<p>
						The additional argument,
						<span class="monoText">-lcs50</span> states, "Link in cs50 library." This tells <span class="monoText">clang</span>, "When you compile <span class="monoText">hello.c</span>, make sure you include all of the machine code from the <span class="monoText">cs50</span> library. Once we include that final argument, everything works:
					</p>

					<pre class="command-line language-bash" data-output="3,5,6"><code>
								clang -o hello hello.c -lcs50
								ls
								hello* hello.c
								./hello
								What's your name? David
								hello, David
							</code></pre>

					<p>As we can see, the command above is too long to repetitively type. As is usual among computer scientists and programmers, the entire command is shortened to simply <span class="monoText">make</span>.</p>
					<p>When we <span class="italicsText">compile</span> code, we are actually referring to 4 distinct steps:</p>
					<ol>
						<li>Preprocessing</li>
						<li>Compiling</li>
						<li>Assembling</li>
						<li>Linking</li>
					</ol>
				</section>

				<section id="preprocessing" class="grid-item">
					<h3>Preprocessing</h3>
					<p>
						Once we enter a command starting a compile, the program
						<span class="italicsText">preprocesses</span> the code, top to bottom, left to right. It looks for any line that starts with a hash symbol (<span class="monoText">#</span>). For example, <span class="monoText">#include &lt;library&gt;</span>. This is essentially a find and replace. The preprocessor sees the <span class="monoText">#</span> sign, and copies the contents of that file into the source code. The contents of the header files are <span class="italicsText">prototypes</span>&mdash;hints that a function is going to be defined. This done so that all of the functions we use from that library are defined. Without doing so, the functions used in the program (from the included libraries) would go undefined.
					</p>
					<p>Thus, the header files we have been including in the programs contain all of the <span class="italicsText">prototypes</span>, or "hints", for all of the functions that will be used in the program. The preprocessor effectively saves us the trouble of having to write all of the prototypes for those functions.</p>
				</section>

				<section id="compiling" class="grid-item">
					<h3>Compiling</h3>
					<p>
						Once the source code has been preprocessed, it is then
						<span class="italicsText">compiled</span>&mdash;translating the source code into <span class="boldItalics">assembly code</span>. Assembly code is essentially the code that the computer's CPU ("Central Processing Unit") understands.
					</p>
				</section>

				<section id="assembling" class="grid-item">
					<h3>Assembling</h3>
					<p>
						Once the source code has been completely translated into
						<span class="italicsText">assembly code</span>, it is finally translated to <span class="boldItalics">machine code</span>&mdash;0s and 1s.
					</p>
				</section>

				<section id="linking" class="grid-item">
					<h3>Linking</h3>
					<p>The final step is <span class="boldItalics">linking</span>. We used statements using a programming language, C, and we used functions and operators built into that language. Those statements only work because of a library, <span class="monoText">&lt;stdio.c&gt;</span>. Additionally, we wrote statements that included functions from another library, <span class="monoText">&lt;cs50.h&gt;</span>. All of these libraries, and their contents, consists of code, which in turn consists of 0s and 1s. These 0s and 1s need to be combined with our program, in order for our program to execute. The process of combining all of these 0s and 1s is called <span class="italicsText">linking</span>.</p>
				</section>

				<section id="debugging" class="grid-item">
					<h3>Debugging</h3>
					<p>A <span class="boldItalics">bug</span> is a mistake or error in written code. Correcting that mistake, or eliminating that bug, is called <span class="boldItalics">debugging</span> (a term of art referencing famous computer scientist Grace Hopper's discovery of a moth inside a Harvard computer when she was asked to fix the machine).</p>
					<p>
						One of the most useful tools for debugging in C is the function
						<span class="monoText">printf()</span>. Displaying an output in the terminal is the quickest and most straightforward way to check an output. In fact, this is such a common way to debug that every major programming language has some form of it: <span class="monoText">println()</span> in Java, and <span class="monoText">console.log()</span> in JavaScript.
					</p>
					<p>In addition to <span class="monoText">printf()</span>, many languages include a <span class="boldItalics">debugger</span>&mdash;a tool that aids debugging code step by step.</p>
					<h3>Rubber Duck Debugging</h3>
					<p><span class="boldItalics">Rubber duck debugging</span> is a debugging technique where we explain our code to a rubber duck. Explain what your code is supposed to do to the rubber duck, and very often, you'll find problems in our logic&mdash;bugs. This technique isn't limited to programming. Recall that programming involves writing algorithms. And as we've previously stated, algorithms are just a sequence of steps leading to an outcome. Many of our day-to-day problems, computer science-related or otherwise, can be solved by simply speaking to a Rubber duck.</p>

					<h3>A Bug Example</h3>
					<p>Suppose we wrote the following in C:</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int score1 = 72;
									int score2 = 73;
									int score3 = 33;

									printf("Average: %f\n", (score1 + score2 + score3) / 3);
								}
							</code></pre>

					<p>
						The code above returns an error. Why? Because
						<span class="monoText">score1</span>, <span class="monoText">score2</span>, <span class="monoText">score3</span>, and our divisor, <span class="monoText">3</span>, are all <span class="monoText">int</span> type values. But our return is going to be a <span class="monoText">float</span> type value. You cannot return a <span class="monoText">float</span> type value from a computation involving only <span class="monoText">int</span> type values. So how do we fix this?
					</p>
					<p>One way is to <span class="italicsText">cast</span> the values. As long as we cast at least one of the values as a <span class="monoText">float</span>, the program will compile. This is because in C, as long as there is one <span class="monoText">float</span> type value in a computation, C will use <span class="monoText">float</span> as the data type for the returned value.</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int score1 = 72;
									int score2 = 73;
									int score3 = 33;

									printf("Average: %f\n", (score1 + score2 + score3) / (float) 3);
								}
							</code></pre>

					<p>A simpler solution of course, is to just ensure that there's at least one floating point value in the computation:</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int score1 = 72;
									int score2 = 73;
									int score3 = 33;

									printf("Average: %f\n", (score1 + score2 + score3) / 3.0);
								}
							</code></pre>
					Changing <span class="monoText">3</span> to
					<span class="monoText">3.0</span>

					<p>
						But, even if we did fix this bug, the code still
						<span class="italicsText">smells</span>. It's poorly designed for a number of reasons:
					</p>
					<ol>
						<li>
							We do not have to initialize all the variables,
							<span class="monoText">score1</span>, <span class="monoText">score2</span>, and <span class="monoText">score3</span>, separately. Instead, we can simply add them all in a single variable:
						</li>

						<pre class="language-c"><code>
									int scoreTotal = 72 + 73 + 33;
								</code></pre>

						<li>
							The variable's are poorly named. Sure,
							<span class="monoText">score1</span> is indicative of a score, but who's score is it? Where does it end?
						</li>
					</ol>
					<p>
						The second problem is a great use case for an
						<span class="boldItalics">array</span>.
					</p>
				</section>

				<section id="arrays" class="grid-item">
					<h3>Arrays</h3>
					<p>
						In C, and in other languages, an
						<span class="italicsText">array</span> is a sequence of values, stored in memory, one after another. In a sense, it's an <span class="u nderlineText">ordered</span> list of values. They are a way for us to hold values of the <span class="italicsText">same type</span> at contiguous (adjoining) memory locations. We can think of an array as a bank, containing an ordered arrangement of safety deposit boxes. The safety deposit boxes are to the bank what <span class="boldItalics">elements</span> are to an array. Each <span class="italicsText">element</span> is an identically-sized block of space that can only store a certain amount of data, just like how safety deposit boxes at a bank can only store particular sizes of valuables (e.g., you can store a letter, but certainly not an SUV). Moreover, the elements of an array can only store data of the same type, just as the safety deposit boxes in a bank can only store particular things (e.g., you can store non-perishable things, not
						food). Finally, we can access each element in the array by referring to their index (their place in the array), just like how we can access a safety deposit box by telling the bank our safety deposit box's number.
					</p>
					<p>
						In C, the elements of an array are always indexed starting from
						<span class="monoText">0</span>. In fact, most programming languages start array indexes from <span class="monoText">0</span>. Thus, if an array contains $n$ elements, the first element is located at index <span class="monoText">0</span>, and the last element is located at $n - 1$. Note, however, that C, as compared to other languages like Java, is a very lenient language&mdash;it will not stop you from attempting to call a non-existent element. I.e., if we had an array of 5 elements, and called a non-existent element of index [9], C will not tell us that we're calling a non-existent element.
					</p>
					<h3>How to Declare an Array</h3>
					<p>To declare an array, we follow the syntax:</p>

					<p>
						<span class="monoText">type name[size]</span>
					</p>

					<p>The array's <span class="monoText">type</span> is the data type for each of the values. Remember, we can have only <span class="underlineText">one</span> data type. The array's <span class="monoText">name</span> is what we will call our array. The array's <span class="monoText">size</span> is the number of elements the array will contain. For example,</p>

					<pre class="language-c"><code>
								double stock_prices[8];
							</code></pre>

					<p>creates an array called <span class="monoText">stock_prices</span>, which contains 8 values of type <span class="monoText">double</span>.</p>
					<p>The above syntax <span class="italicsText">declares</span> an array. There are two ways to assign values to an array: (1) with <span class="boldItalics">instantiation syntax</span>, or (2) with <span class="boldItalics">individual element syntax</span>.</p>
					<h4>Individual Element Syntax</h4>
					<p>
						To initialize an array with
						<span class="italicsText">individual element syntax</span>, we write:
					</p>

					<pre class="language-c"><code>
								type arrayName[size];
								arrayName[0] = value1;
								arrayName[1] = value2;
								arrayName[2] = value3;
								...
							</code></pre>

					<h4>Instantiation Syntax</h4>
					<p>
						To initialize an array with
						<span class="italicsText">instantiation syntax</span>, we write:
					</p>

					<pre class="language-c"><code>
								type arrayName[] = { value1, value2, value3 };
							</code></pre>

					<p>Notice that with instantiation, we do not need to indicate the array's size. This is because the compiler is smart enough to determine how large the array is, based on the number of elements (separated by commas) we inserted into the array.</p>
					<h4>Multidimensional Arrays</h4>
					<p>
						Arrays are not limited to just one dimension; i.e., a single list of the ordered values. We can have arrays of arrays, or arrays of arrays of arrays. Suppose we have an array called
						<span class="monoText">students</span>, containing eight arrays. The sixth element of <span class="monoText">students</span> contains an array of five values. To target <span class="monoText">student</span>'s sixth element's array's third value, we would write:
					</p>

					<pre class="language-c"><code>
							string students[5][2]; 
							</code></pre>

					<p>A helpful way to think about Multidimensional arrays is that they're much like axes on a plane. An array of 10 arrays containing 10 values forms a $10 \times 10$ grid. This is a helpful abstraction for when we need visualize grids.</p>

					<h4>Arrays and Variables</h4>
					<p>In C, we can treat individual elements of arrays as variables. But, we <span class="underlineText">cannot</span> treat entire arrays as though they were variables. For instance, we cannot assign one array to another using the assignment operator. We also cannot simply "add" arrays with the addition operator. Instead, we need to use a loop to copy over the elements one at a time. For example, this will not do:</p>

					<pre class="language-c"><code>
								int foo[5] = { 1, 2, 3, 4, 5 }
								int bar[5]; 

								bar = foo;
							</code></pre>

					<p>This, however, will:</p>

					<pre class="language-c"><code>
								for (int j = 0; j < 5; j++)
								{
									bar[j] = foo[j];
								}
							</code></pre>

					<h4>Arrays and Scope</h4>
					<p>
						Recall: Most variables in C are
						<span class="italicsText">passed by value</span> in function calls&mdash;the callee function does not receive the variable itself, it receives a copy of the variable.
					</p>
					<p>Arrays <span class="underlineText">do not follow this rule</span>. Instead, they are <span class="italicsText">passed by reference</span>. The callee function receives an actual array, not a copy of it. This special property is given to arrays because arrays can get very large very quickly. If arrays were passed by value, it would take significant time and resources to make copies of the array.</p>
					<p>Let's see an application of these ideas. In the previous bug example, we have three scores, <span class="monoText">score1</span>, <span class="monoText">score2</span>, <span class="monoText">score3</span>. We can place those scores into an array in C:</p>

					<pre class="language-c"><code>
								int scores[3];
							</code></pre>

					<p>
						The number inside the brackets
						<span class="monoText">[]</span> represents the number of scores that we want to store; the number of values to be placed inside the array. To store those values, we write the following:
					</p>

					<pre class="language-c"><code>
								int scores[3];
								scores[0] = 72;
								scores[1] = 73;
								scores[2] = 33;
							</code></pre>

					<p>
						Each value inside an array has an
						<span class="boldItalics">index</span>&mdash;its place in the array. <span class="monoText">[0]</span> indicates the first value, <span class="monoText">[1]</span> indicates the third value, and <span class="monoText">[2]</span> indicates the third value. Remember, we start counting from 0 in computer science. If we fail to include <span class="monoText">[0]</span>, we end up wasting valuable memory. So, fixing our buggy code from before:
					</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int scores[3];
									scores[0] = 72;
									scores[1] = 73;
									scores[2] = 33;
									printf("Average: %f\n", (scores[0] + scores[1] + scores[2]) / 3.0);
								}
							</code></pre>

					<p>
						We can clean the code up even more by using a
						<span class="boldItalics">loop</span>.
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int scores[3];
									scores[0] = get_int("Score: ");
									scores[1] = get_int("Score: ");
									scores[2] = get_int("Score: ");
									printf("Average: %f\n", (score[0] + score[1] + score[2]) / 3.0);
								}
							</code></pre>

					<p>
						This code still smells. We're writing
						<span class="monoText">get_int</span> over and over again. A better design would be to use a <span class="monoText">const</span> and a <span class="monoText">for</span> loop. In C, <span class="monoText">const</span> stands for <span class="italicsText">constant</span>. When we write:
					</p>

					<pre class="language-c"><code>
								const float PI = 3.14;
							</code></pre>

					<p>
						we tell C that there is a variable called
						<span class="monoText">PI</span>, with a <span class="monoText">float</span> type value of <span class="monoText">3.14</span>, and that variable's assigned value can <span class="underlineText">never</span> change. Once it is set, it can never change. Notice that named the variable in all capital letters. This is a style convention in C to indicate that the variable is special; it's a constant.
					</p>
					<p>
						Additionally, a better design would write an average function separately, using the array's
						<span class="boldItalics">length</span>. Every array has a <span class="italicsText">length</span>, or many values are inside of it. We might write the function as:
					</p>

					<pre class="language-c"><code>
								float average(int length, int array[])
								{
									int sum = 0;
									for (int i = 0; i < length; i++)
									{
										sum += array[i];
									}
									return sum / length;
								}
							</code></pre>

					<p>In the above code, we passed an array's length as an argument. We did so by passing <span class="monoText">int length</span>, and <span class="monoText">int array[]</span>. Notice that we did not have to include the number of values in the array inside the brackets <span class="monoText">[]</span>. This is because the function will take any array, and as such, any length. A crucial difference between C and other popular languages, like Java, is that the array's length is not built into the array. You <span class="underlineText">must</span> explicitly state, in the function's parameters, that the array's length will be used. Thus, we can then pass that function as an argument to the function <span class="monoText">printf()</span>:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								const int TOTAL = 3;
								average();

								int main(void)
								{
									int total = get_int("Total number of scores: ");
									int scores[TOTAL];
									for (int i = 0; i < TOTAL; i++)
									{
										scores[i] = get_int("Score: ");
									}
									printf("Average: %f\n", average(TOTAL, scores);
								}

								float average(int length, int array[])
								{
									int sum = 0;
									for (int i = 0; i < length; i++)
									{
										sum += array[i];
									}
									return sum / (float) length; // be careful! sum is an int, you need a float
								}
							</code></pre>

					<p>A well designed program should not require us to go back and change many lines of code to accommodate for an expected change.</p>
				</section>

				<section id="ascii_codes" class="grid-item">
					<h3>Type <span class="monoText">char</span></h3>
					<p>
						As we know, ASCII characters have the type
						<span class="monoText">char</span>. We can see the number assigned to a character by writing the following in C:
					</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									char c = '#'; // a single character, #
									printf("%i\n", (int) c); // cast c as an int
								}
								// Output: 35
							</code></pre>

					<p>We can see that the character <span class="monoText">#</span> has the ASCIi key of <span class="monoText">35</span>. More importantly, this shows that in C, we can cast from one data type to another. Here, we casted a <span class="monoText">char</span> type value to an <span class="monoText">int</span> type value, purely from context.</p>
					<p>Question: How is a single character stored in RAM? Recall that each of the "squares" in the RAM's grid represents a single byte. Because a single value of type <span class="monoText">char</span> takes 1 byte, a single character takes up one of the squares (more accurately, the number <span class="monoText">35</span> is what's being stored in the square).</p>
					<p>Now let's suppose we wrote the following:</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;

								int main(void)
								{
									char c1 = 'H';
									char c2 = 'I';
									char c3 = '!';
									
									printf("%c%c%c\n", c1, c2, c3);
								}
								// Output: HI!
							</code></pre>

					<p>
						The code above gives us an output:
						<span class="monoText">HI!</span>. Of course, the above code is poorly written. We wrote <span class="monoText">%c</span> several times, and had to write the variable names as separate arguments for the <span class="monoText">printf()</span> function. Before we fix it, let's quickly look at what happens when we cast the characters:
					</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								
								int main(void)
								{
									char c1 = 'H';
									char c2 = 'I';
									char c3 = '!';

									printf("%i %i %i\n", c1, c2, c3);
								}
								// Output: 72 73 33
							</code></pre>

					<p>
						Casting each of the character values, we get
						<span class="monoText">32</span>, <span class="monoText">73</span>, <span class="monoText">33</span>. On the RAM's grid, this looks like the following:
					</p>
					<figure>
						<img src="images/ramAllocateChar.svg" alt="allocating char" class="forty-p" loading="lazy" />
					</figure>
					<p>
						What if, instead, we used a string? Note that
						<span class="boldItalics">string</span> is a term of art&mdash;every programming language has strings, even if they do not have a <span class="monoText">type string</span>. C is one such language. It does not inherently have a data type called <span class="monoText">string</span>, but there are libraries that include the type.
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(void)
								{
									string s = "HI!";
									printf("%s\n", s);
								}
								// Output: HI!
							</code></pre>

					<p>Running the code above, we get the string "HI!", as expected. On the computer's RAM, this data is stored as such:</p>
					<figure>
						<img src="images/stringS.svg" alt="allocation of the string" class="forty-p" loading="lazy"/>
					</figure>
					<p>
						This looks very familiar. Strings are simply an array of
						<span class="monoText">char</span> values. However, a string does not simply take $n$ bytes, where $n$ is the number of <span class="monoText">char</span> values. Instead, the string takes $n+1$ bytes. Why is it taking an additional byte? Because there's one more <span class="monoText">char</span> value taken up by the string:
					</p>
					<figure>
						<img src="images/stringAllocate.svg" alt="allocating strings" class="forty-p" loading="lazy" />
					</figure>
					<p>The character <span class="monoText">\0</span> represents is called the <span class="boldItalics">null</span> character. It indicates the end of a string, and it is represented in ASCII by the number <span class="monoText">0</span> (or, more specifically, eight <span class="monoText">0</span> bits inside the square. In fact, we can confirm this by writing the following:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(void)
								{
									string s = "HI!";
									
									printf("%i %i %i %i\n", s[0], s[1], s[2], s[3]);
								}
								// Output: 72 73 33 0
							</code></pre>

					<p>We can see that the array actually contains four values ($n+1$), even though the string contains three characters ($n$). This example shows what can be a very dangerous situation in C. Suppose we wrote and compiled the following:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(void)
								{
									string s = "HI!";
									
									printf("%i %i %i %i\n", s[0], s[1], s[2], s[3], s[4]);
								}
								// Output: 72 73 33 0 37
							</code></pre>

					<p>Where is that <span class="monoText">37</span> coming from? In ASCII, the number <span class="monoText">37</span> is the percent sign, <span class="monoText">%</span>. This is occurring because we're poking around the computer's memory. Let's change the <span class="monoText">s[4]</span> to <span class="monoText">s[25]</span>.</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(void)
								{
									string s = "HI!";
									
									printf("%i %i %i %i\n", s[0], s[1], s[2], s[3], s[25]);
								}
								// Output: 72 73 33 0 0
							</code></pre>

					<p>Now we're getting <span class="monoText">0</span>. What this behavior shows us is that we can look at and change any area of memory we want. This means we can make changes even to memory that doesn't belong to our program. This is a powerful and dangerous tool. If we use it without care, we can crash not only our programs, but other programs running on the computer.</p>
				</section>

				<section id="string_length" class="grid-item">
					<h3>A String's Length</h3>
					<p>
						Because strings are arrays, they have a
						<span class="monoText">length</span> property. We can see that length with the following:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(void)
								{
									string s = get_string("Input: ");
									printf("Output: ");
									for (int i = 0; s[i] != '\0'; i++)
									{
										printf("%c", s[i]);
									}
									printf("\n");
								}
							</code></pre>

					<p>
						Note that in the above code, we wrote our
						<span class="monoText">for</span> loop in a different way. Specifically, we used the following syntax:
					</p>

					<pre class="language-c"><code>
								for (int i = 0; s[i] != '\0'; i++) 
								{
									<span class="code-annotation">statements</span>;
								}
							</code></pre>

					<p>Remember that a <span class="monoText">for</span> loop's condition just has to be a Boolean expression. In the <span class="monoText">for</span> loop above, we used the Boolean expression <span class="monoText">s[i] != '\0'</span>. What this says is, starting at index <span class="monoText">0</span>, keep looping until you reach the index of <span class="monoText">\0</span> (which, as we know, is the end of a string).</p>
					<p>
						Although the above code works&mdash;and illuminates what strings actually are&mdash;there are C libraries that include a function for returning a string's length:
						<span class="monoText">strlen()</span>. Here, that library is in the file &lt;string.h&gt;. Thus, we can rewrite the same loop as:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string s = get_string("Input: ");
									printf("Output: ");
									for (int i = 0; i < strlen(s); i++)
									{
										printf("%c", s[i]);
									}
									printf("\n");
								}
							</code></pre>

					<p>
						How does this function work? It's very likely that they used the same structure as the previous
						<span class="monoText">for</span> loop. I.e., checking for <span class="monoText">\0</span>. There is, however, a problem with this code.
					</p>
					<p>
						In the code above, we're using the return value of
						<span class="monoText">strlen(s)</span> as the operand of the Boolean expression. This means that every time C passes through an iteration, it asks "What is the length of the string?" over and over again. In other words, every time C goes through the loop, it has to execute the function <span class="monoText">strlen()</span>. This is not optimal. How then should we write this? A better design would be to have C execute the function <span class="underlineText">once</span>, store the return value in a variable, and use that variable as an operand of the Boolean expression:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string s = get_string("Input: ");
									printf("Output: ");
									n = strlen(s);
									for (int i = 0; i < n; i++)
									{
										printf("%c", s[i]);
									}
									printf("\n");
								}
							</code></pre>

					<p>
						We can this more cleanly by placing
						<span class="monoText">n = strlen(s)</span> directly inside the <span class="monoText">for</span> loop:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string s = get_string("Input: ");
									printf("Output: ");
									for (int i = 0, n = strlen(s); i < n; i++)
									{
										printf("%c", s[i]);
									}
									printf("\n");
								}
							</code></pre>
				</section>

				<section id="strings_arrays" class="grid-item">
					<h3>Strings Containing Arrays</h3>
					<p>Arrays are an ordered list of values. So, since strings are values, we can place them inside an array:</p>

					<pre class="language-c"><code>
								string words[2];
								words[0] = "Hi!";
								words[1] = "Bye";
							</code></pre>

					<p>Because a string is an array of characters, what we really have is an array of arrays of characters. And since we can access the values of an array, it follows that we can access the individual characters of each of the words:</p>

					<pre class="language-c"><code>
								words[0][0] // "H"
								words[0][1] // "i" 
								words[0][2] // "!" 

								words[1][0] // "B"
								words[1][1] // "y"
								words[1][2] // "e"
							</code></pre>

					<p>Using these principles, we can write a function that takes a word from a user, and converts it into all upper case:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string s = get_string("Before: ");
									printf("After: ");

									for (int = 0, n = strlen(s); i < n; i++)
									{
										if (s[i] >= 'a' && s[i] <= 'z')
										{
											printf("%c", s[i] - 32);
										}
										else
										{
											printf("%c", s[i]);
										}
									}
								}
							</code></pre>

					<p>
						Most of the code above should be familiar to us. But, there is something different. In the
						<span class="monoText">if</span> statement's condition, we wrote <span class="monoText">s[i] >= 'a' && s[i] <= 'z'</span>. On the ASCII table, the lower case letters 'a' to 'z' are in order, with their assigned numbers running from 97 to 122. Thus, this condition just says, "If the character is any character greater than or equal to <span class="monoText">'a'</span> (<span class="monoText">97</span>) and less than or equal to <span class="monoText">'z'</span> (<span class="monoText">112</span>), execute this code block.
					</p>
					<p>But then how do we convert the lowercase characters to uppercase characters? To do so, we need to reference the ASCII table:</p>

					<pre class="language-c"><code>
								/*
								Dec  Chr   | Dec  Chr   | Dec  Chr
								----------------------------------
								32   Space | 64   @     | 96   `
								33   !     | 65   A     | 97   a
								34   "     | 66   B     | 98   b
								35   #     | 67   C     | 99   c
								36   $     | 68   D     | 100  d
								37   %     | 69   E     | 101  e
								38   &     | 70   F     | 102  f
								39   '     | 71   G     | 103  g
								40   (     | 72   H     | 104  h
								41   )     | 73   I     | 105  i
								42   *     | 74   J     | 106  j
								43   +     | 75   K     | 107  k
								44   ,     | 76   L     | 108  l
								45   -     | 77   M     | 109  m
								46   .     | 78   N     | 110  n
								47   /     | 79   O     | 111  o
								48   0     | 80   P     | 112  p
								49   1     | 81   Q     | 113  q
								50   2     | 82   R     | 114  r
								51   3     | 83   S     | 115  s
								52   4     | 84   T     | 116  t
								53   5     | 85   U     | 117  u
								54   6     | 86   V     | 118  v
								55   7     | 87   W     | 119  w
								56   8     | 88   X     | 120  x
								57   9     | 89   Y     | 121  y
								58   :     | 90   Z     | 122  z
								59   ;     | 91   [     | 123  {
								60   <     | 92   \     | 124  |
								61   =     | 93   ]     | 125  }
								62   >     | 94   ^     | 126  ~
								63   ?     | 95   _     | 127  DEL
								*/
							</code></pre>

					<p>
						Notice that the upper case letters are all 32 units less than the lower case letters. Thus, we wrote, in our
						<span class="monoText">if</span> statement's body: <span class="monoText">s[i] - 32</span>.
					</p>
					<p>
						As always, however, we can do better. There are libraries that already contain this function. As an aside, this is part of why languages grow popular&mdash;the language performs its objectives well and efficiently, the community behind that language is robust, the same community has actively solved many problems, or shortcomings, of the language, and it has been willing to share the code behind those solutions (e.g., through libraries). In this case, there's a library we can use called
						<span class="monoText">&lt;ctype.h&gt;</span>. More specifically, we want to use the functions <span class="monoText">islower()</span> and <span class="monoText">toupper()</span>:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;ctype.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string s = get_string("Before: ");
									printf("After: ");

									for (int i = 0; n = strlens(s); i < n; i++)
									{
										if (islower(s[i]))
										{
											printf("%c", toupper(s[i]));
										}
										else
										{
											printif("%c", s[i]);
										}
									}
								}
							</code></pre>

					<p>The function <span class="monoText">islower()</span> simply tests whether a character is a lower case character. The <span class="monoText">toupper()</span> function converts a lower case character into an upper case character. Even better, however, is that the function <span class="monoText">toupper()</span> can convert a lower case character without even needing to test for whether the character is a lower case character (i.e., if the character is a character that can be turned into an upper case character, it converts, otherwise, it leaves it as is):</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;ctype.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string s = get_string("Before: ");
									printf("After: ");

									for (int i = 0; n = strlens(s); i < n; i++)
									{
										printf("%c", toupper(s[i]));
									}
								}
							</code></pre>
				</section>

				<section id="command_line_arguments" class="grid-item">
					<h3>Command Line Arguments</h3>
					<p>Suppose we had the file named <span class="monoText">argv.c</span>. So far, we have been writing:</p>

					<pre class="language-c"><code>
								int main(void)
								{
									<span class="italicsText">statements</span>;
								}
							</code></pre>

					<p>Now recall that <span class="monoText">main()</span> is a function. We have been passing into it the word <span class="monoText">void</span>, but now we're going to pass into it something new:</p>

					<pre class="language-c"><code>
								int main(int argc, string argv) { }
							</code></pre>

					<p>
						The code above says that we are passing into
						<span class="monoText">main()</span> as inputs: (1) an <span class="monoText">int</span> (<span class="monoText">int argc</span>), and (2) an array of strings (<span class="monoText">string argv[]</span>). The word <span class="monoText">argc</span> is short for "argument count." The variable <span class="monoText">argc</span> contains an <span class="monoText">int</span> type value that represents the number of words that the user will type at the prompt. The string array name <span class="monoText">argv</span> is short for "argument vector." Vector (for the purposes of C) is just another word for "list." <span class="monoText">argv</span> will store, in an array, <span class="underlineText">all</span> of the strings that the user types at the prompt, after the program's name.
					</p>
					<p>
						Passing these arguments into
						<span class="monoText">main()</span> allows us to utilize the command line. Let's say that we want the user to type their own name at the command prompt, without having to use functions like <span class="monoText">get_string()</span> or prompt the user. We want the user to run the program <span class="italicsText">and</span> give us their name all at once (i.e., just as if they were running commands like <span class="monoText">rm</span>, <span class="monoText">cd</span>, <span class="monoText">mkdir</span>, etc.). So, let's write the code as:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(int argc, string argv[])
								{
									if (argc === 2)
									{
										printf("Hello, %s\n", argv[1]);
									}
									else
									{
										printf("Hello, world\n");
									}
								}
							</code></pre>

					<p>This code compiles:</p>

					<pre class="command-line language-bash" data-output="3"><code>
								make argv
								./argv
								Hello, world
							</code></pre>

					<p>But it can do something more interesting now:</p>

					<pre class="command-line language-bash" data-output="3"><code>
								make argv
								./argv Julia
								Hello, Julia
							</code></pre>

					<p>
						How is this working? First, when we pass
						<span class="monoText">argc</span> as an argument, the computer will automatically store in the variable <span class="monoText">argc</span> an <span class="monoText">int</span> value&mdash;the total number of words that the user typed in the terminal (the number of words in the program's name, <span class="monoText">./argv</span>, and the total number of words <span class="italicsText">after</span> <span class="monoText">./argv</span>. Second, by passing the <span class="monoText">string argv[]</span> argument, the computer automatically fills the <span class="monoText">argv[]</span> array with all of the words that the user typed <span class="underlineText">at</span> the prompt. Thus, from the execution above, the array includes (1) <span class="monoText">./argv</span> and <span class="monoText">Julia</span>.
					</p>
					<p>This means that if wrote the following:</p>

					<pre class="command-line language-bash" data-output=""><code>
								make argv
								./argv Jules Verne
								Hello, world
							</code></pre>

					<p>
						it does not execute the code
						<span class="monoText">printf("hello, %s\n", argv[1])</span>, since we wrote, "Execute
						<span class="monoText">printf("hello, %s\n", argv[1]</span>
						<span class="underlineText">only if</span>
						<span class="monoText">argc == 2</span>. By entering <span class="monoText">Jules Verne</span>, we no longer satisfy that condition. The array contains <span class="monoText">["./argv", "Jules", "Verne"]</span>. These are three values, so <span class="monoText">argc == 3</span>.
					</p>
					<p>Question: Why is <span class="monoText">main</span> returning an <span class="monoText">int</span>? In other words, why do we write:</p>

					<pre class="language-c"><code>
								<span class="underlineText">int</span> main()
							</code></pre>

					<p>
						We might have noticed that in other programs, we see random numbers when an error or problem occurs. For example, when attempting to visit a website that takes too long to load, we might see an
						<span class="monoText">Error 404</span>. Programmers often associate integers with errors. The integer <span class="monoText">0</span> is often used to connote that nothing is wrong&mdash;the program performed according to our expectations.
					</p>
					<p>
						To see this in action, suppose we wrote an
						<span class="monoText boldItalics">exit status</span> program:
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;

								int main(int argc, string argv[])
								{
									if (argc != 2)
									{
										printf("missing command-line arguments\n");
										return 1;
									}
									printf("Hello, %s\n", argv[1]);
									return 0;
								}
							</code></pre>

					<p>
						The program above does two things: (1) it outputs the string
						<span class="monoText">missing command-line arguments</span> when the user does not input a string following <span class="monoText">./exit</span>. Furthermore, if the user does not input a string following <span class="monoText">./exit</span>, we also return the number <span class="monoText">1</span>. This is going to be an <span class="boldItalics">error code</span>. The user is not going to see this code, but we can display it with a GUI ("graphical user interface") for the program. If our GUI includes error windows, the number 1 is what will appear. (2) Otherwise, it outputs the string the user entered, and returns the number <span class="monoText">0</span>.
					</p>
					<p>Thus, in our program, <span class="monoText">0</span> means everything went well&mdash;the program does what it is expected to do. Otherwise, it returns <span class="monoText">1</span>.</p>
					<p>When we execute the program, it works as we expect:</p>

					<pre class="command-line language-bash" data-output="2,4"><code>
								./exit
								missing command-line argument
								./exit John
								Hello, John
							</code></pre>

					<p>
						If we wanted to see the return values, we write
						<span class="monoText">echo $?</span>. This is a way of saying, "What was my exit status?"
					</p>

					<pre class="command-line language-bash" data-output="2,4,7"><code>
								./exit
								missing command-line argument
								echo $?
								1
								./exit John
								echo $?
								0
							</code></pre>
				</section>

				<section id="cryptography" class="grid-item">
					<h5>Encryption</h5>
					<p>
						Because characters are really just numbers, and strings are really just arrays of characters, it follows that strings of text can be
						<span class="boldItalics">encrypted</span>; in other words, "scrambled."
					</p>
				</section>

			<!-- ยง Search and Sort -->

				<section id="introduction" class="grid-item">
					<h3>Algorithms in C</h3>
					<p><span class="boldItalics">Searching</span> is a term of art in computer science. It is the way a computer retrieves particular data from a data structure. Both computers and humans need to obtain data, and many programs rely heavily on quickly receiving data to efficiently operate. This means that a computer's ability to search <span class="italicsText">well</span> and <span class="italicsText">efficiently</span> is a core concern in computer science. These two goals can only be achieved if the <span class="boldItalics">algorithm</span> implementing the relevant search performs optimally. To understand how algorithms work, let's return to arrays.</p>
					<p>Recall that the previous sections, we visualized a computer's RAM as a grid with several spaces. Thus, an array can be visualized as the following:</p>
					<figure>
						<img src="images/algorithms_ram.svg" alt="ram row" class="forty-p" loading="lazy" />
					</figure>
					<p>There is, however, a catch with arrays. With the visualization above, we can look at the array from a bird's eye view. Computers, however, cannot. They can only look at one space in the array at a time.</p>
					<p>This fact means that we need to think about a variety of issues when we try to come up with an algorithm for searching through an array: Where should the computer start searching? Where should the computer end the search? How should the computer search?</p>
					<p>The first step to writing a search algorithm is to recognize that algorithms are black boxes, much like functions and the entire computer itself. It takes an input, which could be an array of numbers, strings, characters, arrays, or even larger data&mdash;web pages (see Google), videos (see YouTube), images (see Instagram), "pins" (see Pinterest), posts (see Reddit), stock prices (see Google), products (see Amazon), books (see Library Genesis), articles (see Wikipedia). For all of these inputs, the output is the same&mdash;a Boolean value: what we are looking for is in the array (<span class="monoText">true</span>) or not in the array (<span class="monoText">false</span>).</p>
				</section>

				<section id="run_time" class="grid-item">
					<h3>Run Time</h3>
					<p>
						Whether an algorithm is efficient depends heavily on its
						<span class="boldItalics">run time</span>&mdash;how long it takes to run. It doesn't really matter how measure "how long it takes;" it could be how many iterations the algorithm takes, how many seconds it takes, or how many steps it needs.
					</p>

					<h4>Big O Notation</h4>
					<p><span class="boldItalics">Big O notation</span> is a notation system for studying and evaluating algorithm run times. In Big O notation, we represent an algorithm's run time with an italicized $O$.</p>
					<p>Recall our very first algorithm of searching for a word in a dictionary. If we tried searching for the word one page at a time, we would be doing a <span class="boldItalics">linear search</span>, and the worst case scenario is that the word would be all the way at the letter Z. Thus, given $n$ pages, a linear algorithm would have a run time of $n$. We can display this graphically with the following:</p>
					<figure>
						<div id="linearAlgorithm"></div>
						<figcaption>The first algorithm's run time</figcaption>
					</figure>
					<p>In the second algorithm, we decided to go two pages at a time. This means we cut our time by half. Thus, the graph now looks like:</p>
					<figure>
						<div id="halfTime"></div>
						<figcaption>The first algorithm's run time in red, and the second algorithm's run time in blue.</figcaption>
					</figure>
					<p>In the third algorithm, we divided the search in half, threw away the half further from our word, looked at the second half, split it again, over and over until we reached the page with our word. The run time for this algorithm is logarithmic:</p>
					<figure>
						<div id="logTime"></div>
						<figcaption>The third algorithm's run time in green</figcaption>
					</figure>
					<p>In computer science, we would label these graphs with Big O notation:</p>

					<ul>
						<li>The first algorithm has a run time of $O(n)$.</li>
						<li>The second algorithm has a run time of $O(\frac{n}{2})$.</li>
						<li>The third algorithm has a run time of $O(\log_{2}n)$.</li>
					</ul>

					<p>More accurately, however, we remove constants from Big O notation. This is because computer science isn't too concerned with strict mathematical notation. We generally just want a rough idea of what the run time is. This is because for run times like the first and second algorithms, $O(n)$ and $O(\frac{n}{2})$, the run times are essentially the same. What computer scientists are more interested in are the factors that increase the most. In a function of $f(x) = \frac{n}{2}$, the factor (and constant) $\frac{1}{2}$ remains the same. It's the $n$ that grows the fastest. The same goes for the third algorithm, $O(\log_{2}n)$. We can change the base, and the run time difference is negligible. The key point is looking at the shape of the graph. Thus, the run times above more accurately look like:</p>

					<ul>
						<li>First and second algorithms: $O(n)$</li>
						<li>Third algorithm: $O(\log_{}n)$.</li>
					</ul>

					<p>The above run times are so common, that it's worth noting them:</p>

					<ul>
						<li>$O(n^2)$ - a very slow algorithm</li>
						<li>$O(n \log_{}n)$</li>
						<li>$O(n)$</li>
						<li>$O(\log_{}n)$</li>
						<li>$O(1)$ - a very fast algorithm</li>
					</ul>
				</section>

				<section id="omega_notation" class="grid-item">
					<h4>Omega Notation</h4>
					<p>
						Big O notation tells us the
						<span class="italicsText">lower bound</span> of an algorithm's run time (at most, how many steps does the algorithm take, or how long does the algorithm take?). Omega notation, using the Greek letter $\Omega$, tells us the <span class="italicsText">lower bound</span> of an algorithm's run time (at minimum, how many steps does the algorithm take, or how long does it take?). The syntax in omega notation is the same as Big O notation's:
					</p>

					<ul>
						<li>$\Omega (n^2)$</li>
						<li>$\Omega (n \log_{}n)$</li>
						<li>$\Omega (n)$</li>
						<li>$\Omega (\log_{}n)$</li>
						<li>$\Omega (1)$</li>
					</ul>
				</section>

				<section id="linear_search" class="grid-item">
					<h3>Linear Search</h3>
					<p>
						Suppose we had an array, and we are searching for a particular value in that array. We do not know what each of the elements in the array contain, and the elements are not ordered in any meaningful way. One way to look for this value is by searching through each element, one by one, in order. Or, more specifically, iterating across the array from left to right, searching for the the element. This is called a
						<span class="boldItalics">linear search</span>. We can envision this search as the following:
					</p>
					<figure>
						<img src="images/linear_search.svg" alt="a linear search" class="forty-p" loading="lazy"/>
					</figure>
					<p>We can write this algorithm in pseudocode:</p>

					<pre class="language-pseudo"><code>
								linearSearch() 
								{
									For i from 0 to n-1 
									{
										If value is behind the i<sup>th</sup> door,
											Return <span class="greenText">true</span>
									}
									Return <span class="redText">false</span>
								}
							</code></pre>

					<p>
						The code above should be familiar to us. We start at index
						<span class="monoText">0</span> in the array, and continue. If we find the value at any point in the search, stop the search and return true. We do not write the <span class="monoText">Return false</span> statement as an <span class="monoText">else</span> statement, because we do not want the algorithm to stop simply because the number we are looking for is not behind the current door. We want to let loop through the entire array searching, and only when we have completed the loop and still not found the value do we return <span class="monoText">false</span>.
					</p>

					<h4>How efficient is a linear search?</h4>
					<p>What is the upper bound for this algorithm's run time? To determine this, we ask ourselves, in the worst-case scenario, how many steps might it take our algorithm to find the value we are looking for? Well, it could $n$ steps. We have to look at each of the elements of the array one by one, and there could be $n$ elements. Thus, the algorithm's upper bound is $O(n)$.</p>
					<p>What about the lower bound? To determine this, we ask ourselves, at the very least, how many steps would it take this algorithm to find the value we are looking for? Well, the value could be at the very first element. In which case, it would take the linear search just 1 step. Thus, the algorithm's lower bound is $\Omega (1)$.</p>
					<p>The same values apply for the second algorithm, since the second algorithm is also a simple linear search.</p>
					<p>
						As a further note, the third algorithm does not fare any better than a linear search in this instance. This is because in the problem, the elements in the array are not ordered in any meaningful way. In other words, the values contained in the elements were not
						<span class="boldItalics">sorted</span>.
					</p>
				</section>

				<section id="binary_search" class="grid-item">
					<h3>Binary Search</h3>
					<p>
						Let's assume that the array is sorted. Say the array contains numbers, and the numbers are ordered from least to greatest. With the values sorted, we can conduct a
						<span class="boldItalics">binary search</span>, our third algorithm.
					</p>
					<p>In our third algorithm, we divided the dictionary in half over and over again. In terms of an array, we look at the middle element first, and compare it to our value. If they are the same, the search ends. They are not the same, we discard the half of the array where the target cannot be in. Then we look at the middle element of the remaining half. This goes on over and over. Graphically:</p>
					<figure>
						<img src="images/binary_search.svg" alt="binary search" class="forty-p" loading="lazy" />
					</figure>
					<p>
						We can see that this is a much faster algorithm than a
						<span class="italicsText">linear search</span>, but again, it only works if the values are <span class="underlineText">sorted</span>. In pseudocode, this algorithm might look like:
					</p>

					<pre class="language-pseudo"><code>
								binarySearch()
								{
									If no elements left
										Return <span class="redText">false</span>
									If value inside middle element:
										Return <span class="greenText">true</span>
									Else if number < middle element value
										Search left half
									Else if number > middle element value
										Search right half
								}
							</code></pre>

					<h4>How efficient is this algorithm?</h4>
					<p>What is the upper bound for this algorithm's run time? Again, we ask ourselves, in the worst case scenario, how many steps, or how much time would it take, for this algorithm to find the value? Well, we know that in the worst case scenario, there are $n$ elements. But we also know that we are splitting the number of elements in half each time, and only looking at one element per split. Essentially, we keep dividing the problem of size $n$ by 2 until we get down to a problem of size 1. In other words, the problem goes from $n$, to $\frac{n}{2}$, to $\frac{n}{4}$, to $\frac{n}{8}$, to $\frac{n}{16}$, etc. How many times do we need to divide $n$ by 2 to get down to 1? Well, mathematically, what are doing is:</p>

					<ul>
						<li>$$ \begin{array}{cc} n \\ \hline 2 \\ \hline 2 \\ \hline 2 \\ \hline \vdots \end{array} $$</li>
						<li>This is simply $\frac{n}{2^x}$, where $x$ is the number of times we divide.</li>
						<li>$ \frac{n}{2^x} = 1 $, since we want to keep dividing by two until we get down to 1.</li>
						<li>$ n = 2^x $ by multiplying both sides by $2^x$.</li>
						<li>$ x = \log_{2} n $ by solving for $x$.</li>
						<li>Therefore, given a problem of size $n$, where $n$ is the number of elements in the array, we need to divide $\log_{2}n$ times to reduce the number of elements we have to check to just 1.</li>
					</ul>

					<p>Thus, the upper bound for a binary search's run time is $ O(\log n) $. But what about the lower bound? With a binary search, we target the middle element first. So, at the very least, the algorithm could take just one step (targeting the middle element and finding the value searched for). Thus, the binary search's run time has a lower bound of $ ฮฉ (1) $.</p>
					<p>Let's write the binary search algorithm in C:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
									
								int main(void)
								{
									int numbers[] = {4, 6, 8, 2, 7, 5, 0};
							
									for (int i = 0; i < 7; i++)
									{
										if (numbers[i] == 0)
										{
											printf("Found\n");
											return 0;
										}
									}
									printf("Not found\n");
									return 1;
								}
							</code></pre>

					<p>
						This code is mirrors how we would conduct a linear search. We're given an array of 7 elements, and we go through each of the elements one by one, searching for the number 0. If the number 0 is found, we print the string <span class="monoText">Found</span>, and return the number <span class="monoText">0</span>. Otherwise, once the entire array has been looped through and <span class="monoText">0</span> is not found, print <span class="monoText">"Not found"</span>, and return the number <span class="monoText">0</span>. Why are we returning numbers? Because this allows us to quickly determine whether or not our program ran as expected&mdash;<span class="monoText">0</span> indicating that our program ran as expected, and <span class="monoText">1</span> indicating that something went wrong. Not only that, include the word <span class="monoText">rerturn</span> in a function terminates the function. Thus, returning these numbers serves two purposes: (1) quickly deciphering
						whether our program ran as expected with an exit status, and (2) ending our functions and our program.
					</p>
					<p>Let's write another program that searches for names. For now, let's just try implementing a linear search algorithm.</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string names[] = {"Amy", "Cole", "Hanako", "Gunther", "Taeyong"};
									for (int i = 0; i < 5; i++)
									{
										if (strcmp(names[i], "Taeyong") == 0)
										{
											printf("Found\n");
											return 0;
										}
									}
									printf("Not found\n");
									return 1;
								}
							</code></pre>

					<p>
						Note the new library function we've used,
						<span class="monoText">strcmp</span> ("string compare"). This is a function that comes with the <span class="monoText">string.h</span> library. Unlike many other languages, C does not allow us to compare strings with the equality operator. <span class="monoText">strcmp</span> returns one of three possible values: (1) If the strings are exactly the same, character for character, then the function returns <span class="monoText">0</span>; (2) If the string comes before the searched string alphabetically, then the function returns a negative value; (3) If the string comes after the searched string alphabetically, then the function returns a positive value.Thus, there are three possible outcomes: (1) return value = 0; (2) return value < 0; (3) return value > 0. Note that <span class="monoText">strcmp</span> doesn't actually check strings alphabetically, even though it does do so sometimes. It actually compares strings in ASCII order. So really, what's it doing is comparing the
						ASCII values of the strings from left to right. It just so happens that some of the characters in the ASCII table lead to alphabetical order.
					</p>
					<p>
						Note further that in the test condition, we wrote
						<span class="monoText">(strcmp(names[i], "Taeyong") == 0</span>. We tested for equality to <span class="monoText">0</span> because the function <span class="monoText">strcmp</span> returns either <span class="monoText">0</span> (there's a match) or any other number&mdash;there is no match.
					</p>
					<p>Be very careful about writing test conditions for a function's return value when the function returns a number. For example, if we wrote the following:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string names[] = {"Amy", "Cole", "Hanako", "Gunther", "Taeyong"};
									for (int i = 0; i < 5; i++)
									{
										if (strcmp(names[i], "Taeyong"))
										{
											printf("Found\n");
											return 0;
										}
									}
									printf("Not found\n");
									return 1;
								}
							</code></pre>

					<p>
						The code above will always return
						<span class="monoText">found</span> because the value <span class="monoText">0</span> in C is inherently <span class="monoText">false</span>, and all other values, negative or positive, are inherently <span class="monoText">true</span>. In the buggy code above, the function <span class="monoText">strcmp</span> always return some nonzero number, since <span class="monoText">strcmp</span> evaluates strings as ASCII numbers. This means that the return value will always be <span class="monoText">true</span>, so the program always returns <span class="monoText">"Found"</span>.
					</p>
				</section>

				<section id="data_structures_data_types" class="grid-item">
					<h3>Creating Our Own Data Types</h3>
					<p>
						Suppose we had a phone book, and we wanted to find a person's number. One way to do this would be to store the names in an array, with their indices corresponding to their numbers in another array. So, for example, suppose that Jimmy had a phone number
						<span class="monoText">+1-217-898-5446</span> and Charles had the phone number <span class="monoText">+1-217-898-6335</span>. To each for the numbers, we would write the following (using a linear a search):
					</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;

								int main(void)
								{
									string names[] = {"Jimmy", "Charles"};
									string numbers[] = {"+1-217-898-5446", "+1-217-899-6335"};

									for (int i = 0; i < 2; i++)
									{
										if (strcmp(names[i], "Charles") == 0)
										{
											printf("Found %s\n", numbers[i]);
											return 0;
										}
									}
									printf("Not found\n");
									return 0;
								}
							</code></pre>

					<p>
						The code above works just fine, but it's not well-designed. For starters, the phone number outputted above will only be correct if the arrays are of the exact same size, and only if the numbers correctly correspond to the names in the
						<span class="monoText">names</span> array.
					</p>
					<p>It would be much easier if we had a data type for each phone book entry. Each entry contains two things: (1) a name, and (2) a phone number. Let's just focus on people for now. If we wanted to somehow work with a phone book in C, it would be extemely useful to have a data type called <span class="monoText">person</span>. A value of type <span class="monoText">person</span> would have the same exact two things, a <span class="monoText">name</span> and a <span class="monoText">number</span>. In computer science, such a data type would be a <span class="boldItalics">data structure</span>&mdash;a data type with structure. Fortunately, C provides just the features we need to create this data type.</p>
					<p>First, let's think of what this data type might be like. Well, it would need two values, a <span class="monoText">name</span> and a <span class="monoText">number</span>. Those values would be of type <span class="monoText">string</span>. Why would we want the number value to be of type <span class="monoText">string</span>? For starters, because we aren't necessarily doing math with the phone number. Furthermore, phone numbers often have letters in them&mdash;1-800-Cash Now. It could also have dashes, parentheses, and, for international numbers, a + sign.</p>
					<p>We can define the data structure (the data type) with the following syntax:</p>

					<pre class="language-c"><code>
								typedef struct
								{
									string name;
									string number;
								}
								person;
							</code></pre>

					<p>Notice that in the above code, we're creating the data structure type <span class="monoText">struct</span> ("structure"). This is because the data type we're trying to create is a data structure. In our definition, our structure is a composition of two values, <span class="monoText">name</span> and <span class="monoText">number</span>, which are values of type <span class="monoText">string</span>. Then, we name this structure (data type) <span class="monoText">person</span>.</p>
					<p>So, implementing this syntax in our fictional phonebook:</p>

					<pre class="language-c"><code>
								#include &lt;cs50.h&gt;
								#include &lt;stdio.h&gt;
								#include &lt;string.h&gt;
								
								typedef struct
								{
									string name;
									string number;
								}
								person; // Give the data type a name
								
								int main(void)
								{
									person people[2]; // create an array of type person
									people[0].name = "Jimmy"; 
									people[0].number =  "+1-217-898-5446";

									people[1].name = "Charles";
									people[1].number = "+1-217-898-6335";
							
									for (int i = 0; i < 2; i++)
									{
										if (strcmp(people[i].name, "Charles") == 0)
										{
											printf("Found %s\n", people[i].number);
											return 0;
										}
									}
									printf("Not found\n");
									return 0;
								}
							</code></pre>

					<p>In the code above, we used some new syntax. Our data structure contains two <span class="boldItalics">fields</span>&mdash;places where our two string values go. These two fields are <span class="monoText">name</span> and <span class="monoText">number</span>. So, when we <span class="italicsText">populate</span> that field, we use the syntax <span class="monoText">array[index].field</span>. This allows us to input the two string values we want, the person's name, and the person's number.</p>
					<p>Data structures are what we use to keep related data together. Keeping related data together is critical to large-scale programs. Large programs like Google's search engine, Snapchat, YouTube, TikTok, all of these applications rely on user inputs that need to be organized cohesively. Data structures are what achieve this.</p>
				</section>

				<section id="sorting" class="grid-item">
					<h3>Sorting</h3>
					<p>
						To use the binary search algoithm, the values we search in must be sorted. This brings us to another topic in computer science &mdash;
						<span class="boldItalics">sorting</span>. Like searching, <span class="italicsText">sorting</span> is just another problem to be solved with an algorithm. We give the algorithm an input, and the algorithm processes it and gives us an output. In the case of the sorting algorith, the input will be a set of unsorted values, and the output is a set of the same values sorted.
					</p>
					<figure>
						<img src="images/sort_algorithm.svg" class="fifty-p" alt="sorting" loading="lazy"/>
					</figure>
					<p>Note that we do not always need to sort values. If the data set is relatively small, we should just implement a linear search, rather than going the extra mile of sorting and conducting a binary search. Writing code takes the most precious resource we have&mdash;time. We can toil a night way trying to implement a binary search, or we can simply implement a linear search, go to sleep, and wake up the next day with the values found. Like everyone else, computer scientists are not immune to the economists lurking in the corner&mdash;for everything we do, there is a tradeoff.</p>
					<p>Suppose we had the following numbers:</p>
					<figure>
						<img src="images/unsorted.svg" alt="unsorted numbers" class="fifty-p" loading="lazy"/>
					</figure>
					<p>How do we sort these numbers? One way that humans sort is to simply look for the smallest number, then begin ordering them from least to greatest. Computers, however, cannot do that. They can only look at one value at a time. This is the bedrock assumption of sorting algorithms: the computer can only look at one value at a time. So, keeping this in mind, how might we sort these numbers?</p>
					<p>Well, we go through one value at a time. So, one way to sort the values is to start by looking at the left most place, the number 6. We make that the smallest number. Then we look at the next number, and ask if it 2 is less than or greater than 6. 2 is less than 6, so now we remember that as the smallest number. Then we look at the next number. Is 1 less than 2? Yes, 1 is less than 2, so we remember that as the smallest number. Then we look at 5. 5 is not less than 1, so we continue. 4 is not less than 1 and 3 is not less than 1, so 1 remains the smallest number. Because 1 is the smallest number, 1 and 6 <span class="boldItalics">switch positions</span>. 1 is now the left most value. Then we continue, starting with 2. This process repeats over and over until we see that all of the values have been sorted.</p>
					<figure>
						<img src="images/sorted_numbers_basic.svg" alt="sorted numbers" class="fifty-p" loading="lazy"/>
					</figure>
					<p>We can implement this algorithm:</p>

					<pre class="language-pseudo"><code>
								For i from 0 to n-1
									Find smallest item between i<sup>th</sup> item and last item
									Swap smallest item with i<sup>th</sup> item
							</code></pre>

					<p>
						This sorting algorithm is called
						<span class="boldItalics">selection sort</span>. The algorithm is called selection sort because it <span class="italicsText">selects</span> the smallest element over and over again. The first time the algorithm goes through the array, it takes $n$ steps, where $n$ is the number of unsorted elements in the array. The second it goes through the array, it takes $n-1$ steps, since its sorted 1 value (making the array consist of $n-1$ unsorted elements). The third time, $n-3$, the fourth, $n-4$, and so on.
					</p>
					<p>Mathematically, the selection sort's steps is a series:</p>
					<figure>$$ n + (n - 1) + (n - 2) + \ldots + 1 $$</figure>
					<p>This series sums to:</p>
					<figure>$$ \dfrac{n(n + 1)}{2} $$</figure>
					<p>We can rearrange the sum to $\dfrac{n^2 + n}{2}$, which can then be arranged as $\dfrac{n^2}{2} + \dfrac{n}{2}$. By rearranging the sum this way, we can more readily see the selection sort's run time. Remember, computer scientists are not concerned with the constants or mathematical precision. What's more important is, which factor will grow the fastest? In this case, it is the factor $n^2$. Thus, the selection sort algorithm has a upper bound run time of $O(n^2)$.</p>
					<p>The problem with selection sort is that it doesn't stop if the array has already been sorted. It keeps going, checking the numbers one by one, even if, after say, the third element, the array has been completely sorted. This is a waste of time of resources.</p>
					<p>
						Considering this cost, we need to do better. Can we do better? We can. Another algorithm we could use is
						<span class="boldItalics">bubble sort</span>. Suppose we had the array <span class="monoText">[4, 3, 6, 2, 1, 5]</span>. The computer looks at the first number, as always, and sees that it's 4. Then it looks at the second number, 3. It then asks, is 3 less than 4? Yes. The computer switches 3 and 4. The second number is now 4. The computer then looks at the third number, 6. Is 6 less than 4? No. The computer leaves 4 and 6 at their indices. The computer looks at 2. Is 2 less than 6? Yes. The computer switches 2 and 6. This goes on and on. The larger numbers are, in a sense, <span class="italicsText">bubbling up</span>, hence the name "bubble sort."
					</p>
					<p>Visualizing bubble sort:</p>
					<figure>
						<img src="images/bubble_sort.svg" alt="bubble sort" class="fifty-p" loading="lazy" />
					</figure>
					<p>Implementing bubble sort in pseudocode:</p>

					<pre class="language-pseudo"><code>
								Repeat n-1 times
								{
									For i from 0 to n-2
									{
										If i<sup>th</sup> and i+1<sup>th</sup> elements out of order
										{
											Swap them
										}
									}
									If no swaps
									{
										Quit
									}
								}
							</code></pre>

					<p>
						Notice that in pseudocode, we are iterating from
						<span class="monoText">index = 0</span> to <span class="monoText">index = n - 2</span>. This is because we are switching numbers each time, but we only need to switch numbers up to the second to the last element. We do not want to check the last element, and check <span class="monoText">last element + 1</span>, since there is no <span class="monoText">last element + 1</span>. Doing so will go beyond the array's boundary, touching memory that we should not be touching.
					</p>
					<p>What is the run time for bubble sort? Well, we are running through the algorithm $n - 1$ times, and the most amount of times we need to make a swap is $n - 1$. Thus:</p>
					<figure>$$ (n-1) \times (n - 1) = n^2 - n - n + 1 = n^2 - 2n + 1 $$</figure>
					<p>
						The factor that grows the fastest is $n^2$, so the bubble sort's run time has an upper bound of $O(n^2)$. Notice that this is the same upper bound as selection sort's. This tells us that bubble sort is no better than selection sort. In computer science, we say that bubble sort is
						<span class="boldItalics">asymptotically</span> equivalent&mdash;as $n$ gets very very large, bubble sort is no better than (it is equivalent) to selection sort.
					</p>
					<p>But what's bubble sort's lower bound? Unlike selection sort, bubble sort does not need to keep going through the array. Once it no longer needs to make anymore switches, it stops. This brings bubble sort's lower bound running time lower than selection sort's. Thus, given $n$ elements, the bubble sort algorithm makes $n-1$ total comparisons. The bubble sort algorithm has lower bound running time of $\Omega (n).$</p>
				</section>

				<section id="recursion" class="grid-item">
					<h3>Recursion</h3>
					<p>With bubble and selection sort, the computer must finish its passes, even if the array has already been sorted. This is especially problematic if the array is disordered only because of the very first element, or if the array is sorted right from the beginning. Is there a better option?</p>
					<p>Yes. We can use <span class="boldItalics">recursion</span>&mdash;a function's ability to call itself. We know what happens when a function calls itself. But what happens when a function calls another function?</p>
					<p>We know that functions can call themselves. But what happens when a function calls another function? In other words, what happens when part of the function's body includes code that calls the function itself:</p>

					<pre class="language-pseudo"><code>
							search {
								search;
							}
						</code></pre>

					<p>If a function called <span class="monoText">search</span> calls itself, then it will always be calling itself. And if it always calls itself, that would mean that the function is stuck in a loop. Is this a good idea? Of course not. But, that is an inherent risk that comes with using recursion. Which is why, whenever we use something powerful like recursion, we must include some code that forces the function to stop calling itself. Recall our previous algorithm for searching for a particular word in the dictionary:</p>

					<pre class="language-pseudo"><code>
							pick up dictionary
							open to middle of dictionary
							look at dictionary
							search {
								if word is on page
									return word

								else if word is earlier in dictionary
									open to middle of left half of dictionary
									return to line 3

								else if word is later in dictionary
									open to middle of right half of book
									return to line 3

								else quit
							}
						</code></pre>

					<p>In the code above, we have two lines that force the function to repeat itself: <span class="monoText">return to line 3</span>. This technique is purely <span class="boldItalics">iterative</span>&mdash;it's just a loop. But in addition to loops, we also have <span class="boldItalics">recursion</span>. First, suppose we rewrote the code from above:</p>

					<pre class="language-pseudo"><code>
							pick up dictionary
							open to middle of dictionary
							look at dictionary
							search {
								if word is on page
									return word

								else if word is earlier in dictionary
									search left half of dictionary;

								else if word is later in dictionary
									search right half of dictionary;

								else quit
							}
						</code></pre>

					<p>
						Notice the changes made. Instead of explicitly writing the statement
						<span class="monoText">return to line 3</span>, we wrote <span class="monoText">search left half of dictionary</span> and <span class="monoText">search right half of dictionary</span>.
					</p>
					<p>Notice, however, that the function's recursive nature&mdash;calling itself&mdash;works under certain conditions:</p>
					<ol>
						<li>Recursion only applies when a word is not found;</li>
						<li>The problem is getting smaller</li>
					</ol>
					<p>
						A recursive function is useless if we keep feeding it the same input over and over again. To use recursion properly, we must be certain that the function: (1) outputs a different result each time, (2) takes those results as inputs, and (3) at some point, there are no longer any inputs the function can use. The third point is critical. The code that we write satisfying the third point is called the
						<span class="boldItalics">base case</span>&mdash;the code that allows the computer to tell when there's no longer anymore problem to be solved.
					</p>
					<p>In this case, our function's input is getting smaller and smaller and smaller. At some point, it gets to 0&mdash;no more inputs.</p>
				</section>

				<section id="merge_sort" class="grid-item">
					<h3>Merge Sort</h3>
					<p>We can use another sorting algorithm other than bubble and selection sort&mdash;<span class="boldItalics">merge sort</span>. In pseudocode, merge sort looks something like this:</p>

					<pre class="language-pseudo"><code>
							Sort left half of array
							Sort right half of array
							Merge sorted halves
						</code></pre>

					<p>
						Notice how fishy this looks. We are using a function called
						<span class="monoText">sort</span> in a sorting function. This seems an awful lot like defining a word by using the word in the definition. Under non-computer science circumstances, this would be circular. But, it is perfectly normal to write this sort of function in a program. As long as we have a <span class="boldItalics">base case</span>&mdash;a line of code that makes the function's input smaller and smaller, to the point where the computer recognizes that there is no longer a problem to sole.
					</p>
					<p>The algorithm above, however, is incomplete. We need to include a base case:</p>

					<pre class="language-pseudo"><code>
							If only one number
								quit
							Else
								Sort left half of array
								Sort right half of array
								Merge sorted halves
						</code></pre>

					<p>With the base case included, we can execute. Suppose the unsorted array was [6, 3, 8, 5, 2, 7, 4, 1]. First, we sort the left half of the array: [6, 3, 8, 5]. How do we sort the left half of the array? Well, we sort the left and right halves of that array: [6, 3]. How do we sort that array? Well, we sort the left and right halves of that array: [6] and [3]. These are just one number&mdash;our base case&mdash;so they're sorted. Now we merge the sorted halves: 3 is less than 6, so 3 goes first: [3, 6]. Now we look at the right half of the left half of the array: [8, 5]. We perform the same process: [5, 8]. And we merge again: [3, 5, 6, 8]. The left half is sorted. We perform the same process on the right half of the array, and obtain: [1, 2, 4, 7]. Then we merge the two arrays: [1, 2, 3, 4, 5, 6, 7, 9]. The entire process appears almost magical:</p>
					<figure>
						<img src="images/merge_sort_recursive.svg" alt="recursive merge sort" loading="lazy"/>
					</figure>
				</section>

			<!-- ยง Pointers -->
				<section id="computer_architecture" class="grid-item">
					<h3>Computer Architecture &amp; Hexadecimals</h3>
					<p>Most of the world uses the decimal system, where counting is done in base-10. We've also seen that computers count use the binary system, where counting is done in base-2. The problem with base-10 is that it takes up too many places. The problem with base-2 is that it takes up too few places &mdash; it's too difficult to parse through binary digits and determine number they represent.</p>
					<p>Because of these difficulties, computer scientists generally do not count with the decimal system, nor do they count with the binary system. Instead, the more common system for counting is <span class="boldItalics">hexadecimal</span>. In hexadecimal ("hex" colloquially), the base is 16. Because hex relies on base 16, you have 16 total individual digits: (<span class="monoText">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F</span>). The following table shows hex digits in relation to the other base systems:</p>
					<figure>
						<table id="hex_table">
							<thead>
								<th>Hexadecimal</th>
								<th>Decimal</th>
								<th>Binary</th>
							</thead>
							<tbody>
								<tr>
									<td>0</td>
									<td>0</td>
									<td>0000</td>
								</tr>
								<tr>
									<td>1</td>
									<td>1</td>
									<td>0001</td>
								</tr>
								<tr>
									<td>2</td>
									<td>2</td>
									<td>0010</td>
								</tr>
								<tr>
									<td>3</td>
									<td>3</td>
									<td>0011</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>0100</td>
								</tr>
								<tr>
									<td>5</td>
									<td>5</td>
									<td>0101</td>
								</tr>
								<tr>
									<td>6</td>
									<td>6</td>
									<td>0110</td>
								</tr>
								<tr>
									<td>7</td>
									<td>7</td>
									<td>0111</td>
								</tr>
								<tr>
									<td>8</td>
									<td>8</td>
									<td>1000</td>
								</tr>
								<tr>
									<td>9</td>
									<td>9</td>
									<td>1001</td>
								</tr>
								<tr>
									<td>A</td>
									<td>10</td>
									<td>1010</td>
								</tr>
								<tr>
									<td>B</td>
									<td>11</td>
									<td>1011</td>
								</tr>
								<tr>
									<td>C</td>
									<td>12</td>
									<td>1100</td>
								</tr>
								<tr>
									<td>D</td>
									<td>13</td>
									<td>1101</td>
								</tr>
								<tr>
									<td>E</td>
									<td>14</td>
									<td>1110</td>
								</tr>
								<tr>
									<td>F</td>
									<td>15</td>
									<td>1111</td>
								</tr>
							</tbody>
						</table>
					</figure>
					<p>The hexadecimal system works just like the binary and decimal system, only we use 16 as the base as opposed to 2 and 10. So, for example, the number 10 in binary is 1010, since ${ 10 = 1(2^3) + 0(2^2) + 1(2^1) + 0(2^0) }$. Because Hexadecimal uses base 16, however, the number 10 is simply represented by the letter A. A clearer example: 20 in binary is 10100, since ${ 20 = 1(2^4) + 0(2^3) + 1(2^2) + 0(2^1) + 0(2^0) }$. In hex, 20 is 14, since ${ 20 = 1(16^1) + 4(16^0)}.$ The Hex number <span class="monoText">0xADC</span> is simply:</p>
					<figure class="math-display">
						<div>
							<p>${A(16^2 + D(16^1) + C(16^0) = 10(16^2) + 13(16^1) + 12(16^0))}$</p>
						</div>
					</figure>
					<p>Convering from binary to hexadecimal is much easier than converting from binary to decimal. If we're given a long string of binary digits, all we need to do covert the string into hexadecimal is to group the digits into groups of 4 from right to left, padding the leftmost group with extra 0 bits at the front if necessary. Then, we use the table above to convert those bits into hex.</p>
					<p>Hexadecimal is an attractive base system because it makes calculations much easier. Hexadecimal uses 16 digits to express numbers. 16 is a power of 2, and moreover is ${2^4.}$ These mans that a hexadecimal number represents an ordering of 4 binary digits, or 4 bits. This allows us to express extremely long and complicated binary numbers in much more concise ways, without having to do the cumbersone conversion of turning binary into base-10. For example the magic number of 255 is represented in binary as:</p>
					<figure>
						<img src="images/binary_255.svg" alt="255 in binary" class="fifty-p" loading="lazy"/>
					</figure>
					<p>In hex, however, 255 is simply:</p>
					<figure>
						<img src="images/hex_255.svg" alt="255 in hex" class="ten-p" loading="lazy"/>
					</figure>
					<p>Because of this fact, we can refer to the unit of four bits with a single character, <span class="monoText boldText">F</span>, since 4 one digits in binary is precisely 16 in decimal. Note that because the hexadecimal system shares the same numerals as the decimal system for the first nine numbers, hexadecimal numbers are prefixed with <span class="monoText">0x</span>, to signal to readers that the number is a hexadecimal number as opposed to a decimal or binary number (e.g., the number 8 in hexadecimal is written as <span class="monoText">0x8</span>).</p>
					<p>The RAM memory grid then, might look something like:</p>
					<figure><img src="images/hex_ram.svg" alt="ram in hex" class="fifty-p" loading="lazy"/></figure>
				</section>

				<section id="ram_hex" class="grid-item">
					<h4>What's Going On Under the Computer?</h4>
					<p>Suppose we had the following code:</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int n = 50;
									printf("%i\n", n);
								}
							</code></pre>

					<p>Compiling the program:</p>

					<pre class="command-line language-bash" data-output="3"><code>
								make num
								./num
								50
							</code></pre>

					<p>
						In our simple program, we stored the number
						<span class="monoText">50</span> inside the variable <span class="monoText">n</span> of type <span class="monoText">int</span>. When we store the number <span class="monoText">50</span> in a variable, it takes up space in RAM, and that particular space has an <span class="boldItalics">address</span>. It has an address, because every single one of the squares in our hypothetical RAM grid has an address. In fact we can see this is the case by writing certain lines of code to obtain our variable <span class="monoText">n</span>'s address:
					</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int n = 50;
									printf("%p\n", &n);
								}
							</code></pre>

					<p>
						In the code above, we used a new operator,
						<span class="monoText">&</span> and a new print format, <span class="monoText">%p</span>. The <span class="monoText">&</span> is the <span class="boldItalics">address of</span> operator (do not confuse this with the Boolean operator <span class="monoText">&&</span>). By prefixing any variable name with <span class="monoText">&</span>, we effectively command C to tell us what address the variable is stored in. The print format <span class="monoText">%p</span> is a special print format for addresses. Compiling:
					</p>

					<pre class="command-line language-bash" data-output=""><code>
								make num
								./num
								0x7fffd9e5900c
							</code></pre>

					<p>See gives us a hexadecimal number. This is the address where the variable <span class="monoText">n</span> is stored: <span class="monoText">0x7fffd9e5900c</span>. Another useful operator when handling memory addresses is the <span class="monoText">*</span> operator. The <span class="monoText">*</span> is called the <span class="boldItalics">dereference operator</span>&mdash;it commands C to look inside a particular memory address, or "go to this address." If, for example, we wrote the following:</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int n = 50;
									printf("%\n", *&n);
								}
							</code></pre>

					<p>
						we are effectivelly telling C, "To print out
						<span class="monoText">n</span>, go to the address where <span class="monoText">n</span> is stored." Needless to say, this is redundant, since that is what C already does in the first place. This is apparent given the output to the above code:
					</p>

					<pre class="command-line language-bash" data-output=""><code>
								make num
								./num
								50
							</code></pre>
				</section>

				<section id="pointers" class="grid-item">
					<h4>Pointers</h4>
					<p>The easiest way to see how memory addresses can be useful is to use a special kind of variable called a <span class="boldItalics">pointer</span>. The <span class="monoText">p</span> in the print format <span class="monoText">%p</span> stands for "pointer." A <span class="italicsText">pointer</span> is a variable that contains the address of some other value. We can have pointers to any value of any data type, whether its a Boolean, an int, char, string, etc.</p>

					<p>Think about what this implies. It essentially means that pointers provide an alternative way for us to pass data between functions. In most situations, we pass data to functions by value. But recall that when we do so, we only pass a copy of that data. We never actually pass the variable and its contents to the function. By using pointers rather than passing our declared variables, we can pass the actual variable itself, rather than a mere copy of the variable. This means that when we use a pointer, changing that variable's value with a function <span class="italicsText">can</span> impact what happens in a different function, since we didn't just change a copy of the variable &mdash; we changed the actual variable.</p>

					<p>Pointers and memory are interrelated. Every file on our computer resides on a disk drive, whether the drive is an SSD (solid-state drive) or HDD (hard disk drive). These drives are purely for storage; we never do work in them (in fact, we physically cannot do work in them). All of our actual interactions and work with computer take place in RAM (Random Access Memory). Because our work takes place there, we must move data into RAM, since we cannot work with a computer without data.</p>

					<p>RAM capacity is much smaller than disk drives. They generally come in sizes of 512MB, 1GB, 2GB, 4GB, 8GB. For more expensive computers, 16GB, 32GB, 64GB, and rarely, 128GB. Most users (in fact, a very large majority of users) need no more than 8GB. When we turn our computer off, all of the data in RAM is destroyed. This is why we lose all of our changes to files if we do not save data and our computer shuts down mid-way. This is also why we have disk drives. When computer scientists talk about "memory" they are generally referring to RAM, rather than disk drives.</p>

					<p>Whenever we move data into memory, that data takes up a certain amount of space. That amount of space depends on the data's <span class="italicsText">data type</span>. Data of type <span class="monoText">int</span>, for example, takes up 4 bytes of memory. Thus, whenever we use <span class="monoText">int</span> type values, 4 bytes of memory are set aside in RAM to store that value. Values of type <span class="monoText">char</span> take up 1 byte of memory. Values of type <span class="monoText">float</span> take up 4 bytes; <span class="monoText">double</span> 8 bytes; and <span class="monoText">long long</span> 8 bytes of memory. What about the type <span class="monoText">string</span>? The type <span class="monoText">string</span> is a special case, and to understand their memory consumption, we need to discuss RAM a bit further.</p>

					<p>We can think of the RAM as a large rectangular grid, or array, of squares. Each of those squares is 1 byte. Further, the squares have an address, represented in hexadecimal. Whenever we declare a variable and assign it data, that data is stored by taking up their respective amount of squares (bytes). If, for example, we initialize a variable of type <span class="monoText">char</span> with the value <span class="monoText">H</span>, that value (the 1s and 0s representing that value) is stored in 1 square, since it takes up 1 byte. If we initialized a variable of type <span class="monoText">int</span> with the value 73, that value (the 1s and 0s representing that value) is stored in 4 squares, since it takes up 4 bytes of memory. For data types take up more than 1 byte of memory, their binary representations are broken up into 1 byte chunks, and stored in single squares respectively. More accurately, the chunks are stored in their squares depending on whether the computer uses <span class="boldItalics">little-endian</span> ordering or <span class="boldItalics">big-endian</span> ordering. In little-endian ordering, the single bytes are ordered least-to-most significant. In big-endian ordering, the single bytes are ordered most-to-least significant. For example, the number <span class="monoText">305,419,896</span> in Hex is <span class="monoText">12345678</span>. In little-endian ordering, the number is broken into single bytes, and stored most-to-least significant on the grid: <span class="monoText">78 56 34 12</span>. In big-endian ordering, the number is stored in least-to-most significant: <span class="monoText">12 34 56 78</span>. Another example, but in binary: The number <span class="monoText">9,499,938</span>. In little-endian: <span class="monoText">10010000 11110101 00100010</span>. In big-endian: <span class="monoText">00100010 11110101 10010000</span>.</p>

					<p>Returning to strings. As we know, a <span class="monoText">string</span> value is just an array of <span class="monoText">char</span> values. Thus, the string <span class="monoText">bye</span> has three <span class="monoText">char</span> values: <span class="monoText">b, y, e</span>. But, it does not take up a mere 3 bytes. There is one more character inside all strings, the delimiter <span class="monoText">\0</span>, marking the string's end. Thus, the string <span class="monoText">bye</span> takes up 4 bytes of memory.</p>

					<p>Putting this altogether, a <span class="italicsText">pointer</span> is <span class="underlineText">only</span> an address in memory. We emphasize the word "only" because it's easy to think that pointers contain values. Pointers, on their own, do not contain values. They are <span class="underlineText">only</span> addresses to locations in memory where variables reside. For example, when we write the statement <span class="monoText">int k;</span>, we automatically get memory set aside for <span class="monoText">k</span>. Without anything further, all we have is a reserved space. It's just an empty box at the moment. Later down the program, we can fill it with, and only with, data of type <span class="monoText">int</span>, if we so choose. Otherwise, it is just an empty box. The moment we write <span class="monoText">k = 5;</span>, then the space is occupied &mdash; the 1s and 0s composing <span class="monoText">5</span> have filled the box.</p>

					<p>Now let's say we wrote <span class="monoText">int* pk;</span>. What does this do? This will also reserve a space in memory, but not for an <span class="monoText">int</span> type value. It will reserve a space for the <span class="italicsText">address</span> of some other box that contains an <span class="monoText">int</span> type value. If we wrote <span class="monoText">pk = &k;</span>, then we fill that box. Now it actually stores a <span class="italicsText">particular address</span>. In this case, the address of the variable <span class="monoText">k</span>, which stores the value <span class="monoText">5</span> of type <span class="monoText">int</span>. Once we write <span class="monoText">pk = &k;</span>, we now have a crucial piece of data &mdash; the address of where <span class="monoText">k</span> lives. And with that address, we can actually manipulate value stored in <span class="monoText">k</span> by using <span class="monoText">pk</span>.</p>

					<p>We can see, then, that a pointer is a piece of data, whose value is a memory address. And as a piece of data, it has a <span class="italicsText">type</span>. The pointer's data type is the data type of the value stored in the memory address it points to. Thus, if a pointer's value is the memory address of a variable that stores a value of type <span class="monoText">char</span>, the pointer too will have the data type <span class="monoText">char</span>. This is why we wrote <span class="monoText">int* pk;</span> above when we declared the pointer <span class="monoText">pk</span>. Because pointers store addresses, they allow us to pass actual variables, rather than copies of the variables, between functions.</p>

					<p>To see a pointer in action, let's write:</p>

					<pre class="language-c"><code>
								#include &lt;stdio.h&gt;
								int main(void)
								{
									int n = 50;
									int *p =  &amp;n;
									printf("%p\n", p);
								}
							</code></pre>

					<p>
						In the code above, we used the variable
						<span class="monoText">*p</span>. This variable is a pointer&mdash;it stores the memory address of where the variable <span class="monoText">n</span> is located. Compiling:
					</p>

					<pre class="command-line language-bash" data-output=""><code>
								make num
								./num
								0x7ffeb56da01c
							</code></pre>

					<p>Notice that the address is different. This is because there are other processes running in the computer; data moves around constantly in RAM&mdash;you make a change here, save a file there, these all require moving data memory to make room for more data.</p>
					<p>The number <span class="monoText">50</span>, stored in the variable <span class="monoText">n</span>, appears to reside (at the moment) in <span class="monoText">0x7ffeb56da01c</span>. But what about the variable <span class="monoText">p</span>, which stores the address of another variable? Well, storing a memory address or not, <span class="monoText">p</span> is still a variable. And because it is a variable, it does in fact take up space on our hypothetical grid. Thus, <span class="monoText">p</span> itself has a memory address. However, unlike our variable <span class="monoText">n</span>, a variable of data type <span class="monoText">int</span> (which takes up 4 bytes), the variable <span class="monoText">p</span> takes up twice as much space. On modern computers, pointers generally take up 8 bytes.</p>
					<p>The name <span class="italicsText">pointer</span> comes directly from what a pointer does&mdash;it points. More specifically, it points to another address:</p>
					<figure>
						<img src="images/pointer.svg" alt="pointers" class="seventy-p" loading="lazy"/>
					</figure>
				</section>

				<section id="the_null_pointer" class="grid-item">
					<h4>The <span class="monoText">NULL</span> Pointer</h4>
					<p>There's a special kind of pointer in C called the <span class="monoText">NULL</span> pointer. The <span class="monoText">NULL</span> pointer points to nothing. If we ever create a pointer and do not set its value immediately, we must set the value of the pointer to <span class="monoText">NULL</span>. We can check that a pointer's value is set to <span class="monoText">NULL</span> with the equality operator (<span class="monoText">==</span>).</p>
				</section>

				<section id="the_ampersand_operator" class="grid-item">
					<h4>The <span class="monoText">&amp;</span> Operator</h4>
					<p>We can create a pointer by <span class="italicsText">extracting</span> the address of an already existing variable. To do so, we use the <span class="boldItalics">address extraction operator</span>, <span class="monoText">&amp;</span>. Thus, we wrote <span class="monoText">int x;</span>, the statement <span class="monoText">&x</span> is a pointer to the address of <span class="monoText">x</span>, which contains a value of type <span class="monoText">int</span>. If we wrote <span class="monoText">double arr[i]</span>, the statement <span class="monoText">&arr[i]</span> is a pointer to the address of the <span class="monoText">i<sup>th</sup></span> element of <span class="monoText">arr[]</span>, which contains a value of type <span class="monoText">double</span>. Note what this last example implies: The name given to array is actually a pointer to its first element.</p>
					<p>Putting it altogether, consider the following code:</p>
					<pre class="language-c"><code>
						int m;
						m = 4;
						pk = &m;
					</code></pre>
					<p>This code declares a variable <span class="monoText">m</span> of type <span class="monoText">int</span>. Then, it assigns to <span class="monoText">m</span> the integer value <span class="monoText">4</span>. Then, it declares a pointer called <span class="monoText">pk</span>, and assigns to it the <span class="italicsText">address</span> of <span class="monoText">m</span>.</p>
				</section>

				<section id="dereferencing_operator" class="grid-item">
					<h4>The Dereferencing Operator: <span class="monoText">*</span></h4>
					<p>Pointers are what allow us to modify or inspect the location where data is stored. To do so, we use the <span class="boldItalics">dereferencing operator</span>, <span class="monoText">*</span>. For example, suppose we have a pointer called <span class="monoText">pc</span>. The code <span class="monoText">*pc</span> is a pointer to the data that lives at the memory address stored inside the variable <span class="monoText">pc</span>.</p>

					<p>In other words, attaching the operator <span class="monoText">*</span> to a variable tells C to "go to this address and access the data at that memory location." This effectively allows us to manipulate the data.</p>

					<p>The operation of going to an address (<span class="monoText">*</span>) is different from the operation of retrieving that address (<span class="monoText">&</span>). The fact that we have an address (<span class="monoText">&</span>) does not mean we can interact with what's at that address. To do so, we need to actually go to that address (<span class="monoText">*</span>). Thus, when we write <span class="monoText">*pa = 17</span>, this is syntactically similar to writing <span class="monoText">a = 17</span>. The difference being, we are using a pointer, rather than manually changing the data stored inside the variable.</p>
				</section>

				<section id="dereferencing_null" class="grid-item">
					<h5>Dereferencing <span class="monoText">NULL</span></h5>
					<p>What might happen if we attempt to dereference the <span class="monoText">NULL</span> pointer? Dereferencing a <span class="monoText">NULL</span> pointer tells C to go to the address of <span class="italicsText">nothing</span>. This would lead to a <span class="monoText">Segmentation fault</span>. Why then should we set an uninitialized pointer the value <span class="monoText">NULL</span>? Whenever we declare a pointer in C, we are allocated 4 bytes of memory. Without assigning any value to that pointer, those 4 bytes of memory could be anywhere on the grid, and they might contain data we do not want to touch. By assigning a declared but uninitialized pointer the value <span class="monoText">NULL</span>, we ensure that we aren't using memory already occupied by data values. This prevents our accidentally manipulating unknown pointers.</p>
				</section>

				<section id="pointer_warning_syntax" class="grid-item">
					<h4>Caution: Delcaring Multiple Pointers</h4>
					<p>When declaring a pointer, the <span class="monoText">*</span> operator is actually part of the variable's name. Thus, the code:</p>
					<pre class="language-c"><code>
						int* px, py, pz;
					</code></pre>
					<p>is actually a pointer <span class="monoText">px</span>, and two integer variables, <span class="monoText">py</span> and <span class="monoText">pz</span>. If we want three pointers, we must write:</p>
					<pre class="language-c"><code>
						int* px, *py, *pz;
					</code></pre>
				</section>

				<section id="strings_and_pointers" class="grid-item">
					<h5>Strings and Pointers</h5>
					<p>
						Suppose we create a variable
						<span class="monoText">s</span> containing the string "HI!"
					</p>

					<pre class="language-c"><code>
								string s = "HI!";
							</code></pre>

					<p>That variable <span class="monoText">s</span> holds a string, which is really an array of characters. Thus, the variable <span class="monoText">s</span> takes up multiple spaces of memory:</p>
					<figure>
						<img src="images/string_array_memory.svg" alt="string array in memory" class="fifty-p" loading="lazy"/>
					</figure>
					<p>Each of the individual characters in a string has an address:</p>
					<figure>
						<img src="images/string_memory_address.svg" alt="string memory address" class="fifty-p" loading="lazy"/>
					</figure>
					<p>The addresses above are purely hypothetical, but notice that they are contiguous and exactly 1 byte apart from one another. Remember, each memory space holds 1 byte.</p>
					<p>From now on, let's think of a string as being the address of the first character in the string. Thus, in our hypothetical address grid, the string <span class="monoText">HI!</span> is actually <span class="monoText">0x223</span>. But why would it be good enough to just think of a string as the address of the first character? Because again, strings are just an array of characters, stored in memory back-to-back. And since we know that every string ends with <span class="monoText">\0</span>, we know exactly which memory space the string ends.</p>
					<p>To see that this is the case, let's write:</p>

					<pre class="language-c"><code>
								#include &lt;string.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									string s = "HI!";
									printf("%s\n", s);
								}
							</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
								make string
								./string
								HI!
							</code></pre>

					<p>Now let's see where the address is:</p>

					<pre class="language-c"><code>
								#include &lt;string.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									string s = "HI!";
									printf("%p\n", s);
								}
							</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
								make string
								./string
								0x402004
							</code></pre>

					<p>We get the address <span class="monoText">0x402004</span>. This is the address where the string starts (the character <span class="monoText">H</span>). What if we instead tried to look for the address of the second character:</p>

					<pre class="language-c"><code>
								#include &lt;string.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									string s = "HI!";
									printf("%p\n", s);
									printf("%p\n", &s[1]);
								}
							</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
								make string
								./string
								0x402004
								0x402005
							</code></pre>

					<p>
						We can see that that character at array
						<span class="monoText">s[1]</span> (the second character) is stored at the memory space exactly one by after the first character of the string (<span class="monoText">s[0]</span>). In fact, this is the case for the entire string:
					</p>

					<pre class="language-c"><code>
								#include &lt;string.h&gt;
								#include &lt;stdio.h&gt;
								int main(void)
								{
									string s = "HI!";
									printf("%p\n", s[0]);
									printf("%p\n", s[1]);
									printf("%p\n", s[2]);
								}
							</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
								make string
								./string
								0x402004
								0x402005
								0x402006 
							</code></pre>

					<p>
						What all of this tells us is that strings are really just
						<span class="italicsText">pointers</span>&mdash;they point to a specific array in a computer's memory.
					</p>
				</section>

				<section id="string_data_type_pointers" class="grid-item">
					<h5>Is there actually a data type <span class="monoText">string</span>?</h5>
					<p>
						Now that we know that strings are really just pointers, we have to ask, "Are strings actually a data type?" Not in the sense that
						<span class="monoText">char</span> and <span class="monoText">int</span> are data types. They do exist, but not as data types. At least not in C. More accurately, a string in C is actually a pointer. Thus, in the purest of terms, our string <span class="monoText">s</span> is actually: <span class="monoText">char *s = "HI!"</span>. A string then is really just a synonym for <span class="monoText">char *</span>. Instead of constantly writing <span class="monoText">char *</span>, however, we have libraries like <span class="monoText">string.h</span> that shorten the code to simply <span class="monoText">string</span>.
					</p>
					<p>Recall that we can create our own custom data types with the following syntax:</p>

					<pre class="language-c"><code>
								typedef struct
								{
									<span class="italicsText">dataType</span> <span class="italicsText">variableName</span>
									<span class="italicsText">dataType</span> <span class="italicsText">variableName</span>
								}
								<span class="italicsText">newDataTypeName</span>;
							</code></pre>

					<p>Indeed, most library files creating custom data types for C follow the same structure. The code might look something like:</p>

					<pre class="language-c"><code>
								typedef char *string;
							</code></pre>
				</section>

				<section id="dynamic_memory_allocation" class="grid-item">
					<h4>Dynamic Memory Allocation</h4>
					<p>One of the problems of asking for allocated memory is the need to know beforehand how much memory we want allocated. This can be a cumbersome or practically unreasonable requirement, as we often don't know how many times our functions are going to run or how large outputs are going to be. Fortunately, there's a solution &mdash; <span class="boldItalics">dynamic memory allocation</span>.</p>
					<p>We can use pointers to access dynamically allocated memory, memory that is allocated as our program runs, rather than memory that is allocated at compile time. Whenever we dynamically allocate memory, the memory comes from a pool called the <span class="italicsText">heap</span>. In most of our programs thus far, memory has been allocated for us via the <span class="italicsText">stack</span>. A general rule of thumb is, whenever we give a variable a name, it more than likely resides in the stack. Anytime we <span class="italicsText">do not</span> give a variable a name, it more than likely resides in the heap.</p>
					<p>Our programs run out of memory whenever any one of three situations occur:</p>
					<ol>
						<li>the heap overflows into the stack;</li>
						<li>the stack overflows into the heap; or</li>
						<li>the stack and the heap come into conflict.</li>
					</ol>
					<p>To dynamically allocate memory, we use the function <span class="monoText">malloc()</span> ("memory allocator"). To use <span class="monoText">malloc()</span>, we must pass in the number of bytes that we want allocated. After allocating the memory requested, <span class="monoText">malloc()</span> returns a pointer to that memory. Note that <span class="monoText">malloc()</span> will only allocate memory if it can. If <span class="monoText">malloc()</span> cannot give us memory, it will return the value <span class="monoText">NULL</span>.</p>
					<p>Here is an example of static memory allocation:</p>
					<pre class="language-c"><code>
						int x; 
					</code></pre>
					<p>Dynamic memory allocation:</p>
					<pre class="language-c"><code>
						int *px = malloc(4);
					</code></pre>
					<p>By writing <span class="monoText">int *px = malloc(4)</span>, we allocate 4 bytes of memory from the <span class="italicsText">heap</span>. The return value from <span class="monoText">malloc(4)</span> is the <span class="italicsText">address</span> of that allocated memory in the heap, which is what are storing in our pointer <span class="monoText">*px</span>.</p>
					<p>We can also use dynamic memory allocation for data structures. An array of floats on the stack:</p>
					<pre class="language-c"><code>
						float stack_array[x];
					</code></pre>
					<p>and an array of floats on the heap:</p>
					<pre class="language-c"><code>
						float* heap_array = malloc(x * sizeof(float));
					</code></pre>
					<p>After dynamically allocating memory, we can use the square bracket syntax for arrays residing in the heap just as we would for arrays residing in the stack. There is, however, a big problem, or danger, with using dynamically-allocated memory. Dynamically-allocated memory is <span class="underlineText">not</span> automatically returned to the system for later use after the function where its created finishes executing. This means that the onus is on us, the programmers asking for the memory, to return it back to the system. If we fail to do so, we can quickly run into <span class="italicsText">memory leaks</span>. Accumulate enough memory leaks, the entire system's performance is compromised. Thus, whenever we use <span class="monoText">malloc()</span>, we must always make sure that there is an accompanying <span class="monoText">free()</span> function returning the memory back to the system.</p>
					<pre class="language-c"><code>
						int m;
						int* a;
						int* b = malloc(sizeof(int));
						a = &m;
						a = b;
						m = 10;
						*b = m + 2;
						free(b);
						*a = 11;

						/*
						m lives in the <i>stack</i>. It is statically allocated memory. a lives in the stack as well. b also lives in the stack. But, although b lives in the stack, it <i>points</i> to malloc(sizeof(int)), which lives in the <i>heap</i>. 

						When we write a = &m, we make a point to m. Both still live in the stack. But when we wrote a = b, we made a point to the address where b points, malloc(sizeof(int)). If we wanted a to point to b, we should have written a = &b.

						Writing m = 10, we store the value 10 in the address were m is located. Writing *b = m + 2, we <i>dereference</i> b (go to the address where b points to), and store in it m + 2, which is 12.

						Now when we free(b), completely free up the address that b points to, the address of the memory allocated by malloc(sizeof(int)). 

						The final line, *a = 11, is problematic. There, we're saying, go to the address where a points to, and store in it the value 11. The problem, however, is that we wrote earlier a = b. And when we wrote a = b, we made a point to the address that b pointed to. That address was freed when wrote free(b). And since we wrote free(b), that memory is no longer allocated for our use. It's been returned to the system, and is now likely occupied by some other data. Thus, writing *a = 11 very likely will return a <i>Segmentation fault</i>.
						*/
					</code></pre>
					<p>At the same time, we do not want to use <span class="monoText">free()</span> on memory that we did not dynamically allocate. This is just as dangerous as failing to return allocated memory, as it essentially removes data from memory. For this reason, there are three explicit rules we should always follow with dynamic memory allocation:</p>
					<ol>
						<li>Every block of memory obtained with <span class="monoText">malloc()</span> must be accompanied by a <span class="monoText">free()</span>.</li>
						<li>The only memory that <span class="monoText">free()</span> should be used on is memory obtained through <span class="monoText">malloc()</span>.</li>
						<li>Never <span class="monoText">free()</span> a block of memory more than once.</li>
					</ol>
				</section>

				<section id="the_call_stack" class="grid-item">
					<h4>The Call Stack</h4>
					<p>Whenever we call a function, the system sets aside space in memory for that function to do its necessary work. These chunks of memory are called <span class="boldItalics">stack frames</span> or <span class="boldItalics">function frames</span>.</p>
					<p>More than one function's stack frame can exist in memory at a given time. For example, if the function <span class="monoText">main()</span> calls the function <span class="monoText">search()</span> and the function <span class="monoText">search()</span> calls the function <span class="monoText">sort()</span>, then all three functions &mdash; <span class="monoText">main()</span>, <span class="monoText">search()</span>, and <span class="monoText">sort()</span> &mdash; have <span class="italicsText">open frames</span>. But, while all three functions have memory allocated for them, <span class="italicsText">only one</span> of those functions is active, or running, at any given time.</p>
					<p>The frames are arranged in a <span class="boldItalics">stack</span>. The frame for <span class="italicsText">the most-recently-called function</span> is always at the very top of the stack. When a new funtion is called, a new frame is <span class="boldItalics">pushed</span> to the top of the stack and becomes the <span class="italicsText">active frame</span>. When a function finishes its work, its frame is <span class="boldItalics">popped</span> off the stack, and the frame immediately below it becomes the new, active, function at the very top of the stack. This function picks up immediately where it left off.</p>
				</section>

				<section id="pointer_arithmetic" class="grid-item">
					<h4>Pointer Arithmetic</h4>
					<p>Given our string <span class="monoText">string s = "HI!"</span>, recall that we can print out the individual characters of the string with:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								string s = "HI!";
								printf("%c\n", s[0]);
								printf("%c\n", s[1]);
								printf("%c\n", s[2]);
							}
						</code></pre>
					<pre class="command-line language-bash" data-output="3-5"><code>
							make string
							./string
							H
							I
							!
						</code></pre>
					<p>
						Now that we know that a string is just a pointer, however, we can obtain the same result by removing the entire
						<span class="monoText">#include &lt;string.h&gt;</span> line by using pointer syntax:
					</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							int main(void)
							{
								char *s = "HI!";
								printf("%c\n", s[0]);
								printf("%c\n", s[1]);
								printf("%c\n", s[2]);
							}
						</code></pre>
					<pre class="command-line language-bash" data-output="3-5"><code>
							make string
							./string
							H
							I
							!
						</code></pre>
					<p>We get the exact same result. We can also completely remove the array syntax:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							int main(void)
							{
								char *s = "HI!";
								printf("%\n", *s);
								printf("%\n", *(s+1));
								printf("%\n", *(s+2));
							}
						</code></pre>
					<pre class="command-line language-bash" data-output="3-5"><code>
							make string
							./string
							H
							I
							!
						</code></pre>
					<p>We get the exact same result. Notice what we did. We used the dereference operator (<span class="monoText">*</span>) to tell C to go to a particular address. And since that address is just a number, we can perform arithmetic on it. In this case, we added 1 to the address <span class="monoText">*s</span> to obtain <span class="monoText">I</span>, and we added 2 to the same address to obtain <span class="monoText">!</span>. The address <span class="monoText">*s</span> being, of course, the address of the first character of our string <span class="monoText">HI!</span>, the character <span class="monoText">H</span>. The square bracket notation is just a shorter way of writing the same calculations above.</p>
				</section>

				<section id="segmentation_fault" class="grid-item">
					<h5>Segmentation Fault</h5>
					<p>Suppose we started poking around places in our computer we shouldn't be poking around:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;
							int main(void)
							{
								char *s = "HI!";
								printf("%c\n", *s);
								printf("%c\n", *(s+1));
								printf("%c\n", *(s+2));
								printf("%c\n", *(s+100000));
							}
						</code></pre>
					<pre class="command-line language-bash" data-output="3-6"><code>
							make string
							./string
							H
							I
							!
							Segmentation fault
						</code></pre>
					<p>
						We get back what almost looks like an error:
						<span class="monoText">Segmentation fault</span>. This is not something we want to see. We are effectively being told that we're looking somewhere we shouldn't be looking. We've touched a <span class="italicsText">segment</span> of memory we shouldn't have touched.
					</p>
				</section>

				<section id="string_comparisons_with_pointers" class="grid-item">
					<h4>String Comparisons</h4>
					<p>
						Suppose we had a simple program comparing two
						<span class="monoText">int</span> values inputed by the user, checking to see if they are the same.
					</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								int i = get_int("i: ");
								int j = get_int("j: ");

								if (i == j)
								{
									printf("Same\n");
								}
								else
								{
									printf("Different\n");
								}
							}
						</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
							make comparison
							./comparison
							i: 2
							j: 2
							Same
							./comparison
							i: 3
							j: 2
							Different
						</code></pre>
					<p>As expected, the code above compiles just fine. But, what if instead we used <span class="monoText">string</span> type values rather than <span class="monoText">int</span>?For example, suppose we wrote:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");
								char *t = get_string("t: ");

								if (s == t)
								{
									printf("Same");
								}
								else
								{
									printf{"Different"};
								}
							}
						</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
							make comparison
							./comparison
							s: hi
							t: hi
							Different

							make compare
							s: hi
							t: bye
							Different
						</code></pre>
					<p>It seems that using <span class="monoText">string</span> values rather than <span class="monoText">int</span> values returns different results, even if the <span class="monoText">string</span> inputs are the same in terms of text. What's going on?</p>
					<p>
						This is happening because we're not actually comparing the strings. Instead, we're comparing the
						<span class="italicsText">addresses</span> of the first characters in the string. Those addresses are different. We can that this is the case by running the following code:
					</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");
								char *t = get_string("t: ");

								printf("%p\n", s);
								printf("%p\n", t);
							}
						</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
							make comparison
							./comparison
							s: hi
							t: hi
							0x7636b0
							0x7636f0
						</code></pre>
					<p>Notice that we inputted the exact same string, but the addresses for those strings are different&mdash;we compared the addresses of the first characters of each string, not the strings themselves.</p>
					<p>
						What this tells us is that the function
						<span class="monoText">get_string</span>, which takes as an input whatever the user inputs, returns the address of the first character of the string. What is being stored in our variable <span class="monoText">s</span> is not actually the entire string inputted by the user, but the memory address of the first character of the string. Our variable <span class="monoText">t</span> shares the same story. Putting it all together, in our program, the variable <span class="monoText">s</span> stores the address <span class="monoText">0x763b0</span> and the variable <span class="monoText">t</span> stores the address <span class="monoText">0x763f0</span>. The variables are pointers, and they point to the addresses of the strings stored in memory.
					</p>
					<p>
						Knowing these facts, we can fix our program by using the function
						<span class="monoText">strcmp()</span>:
					</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");
								char *t = get_string("t: ");

								if (strcmp(s, t) == 0)
								{
									printf("Same\n");
								}
								else
								{
									printf("Different\n");
								}
							}
						</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
							make comparison
							./comparison
							s: hi
							t: hi
							Same

							./comparison
							s: hi
							t: bye
							Different
						</code></pre>
					<p>Now the program works. We're actually comparing the strings rather than the addresses of the first characters of each string.</p>
				</section>

				<section id="copying_strings_with_pointers" class="grid-item">
					<h4>Copying Strings with Pointers</h4>
					<p>Consider:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;ctype.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");
								char *t = s;
								t[0] = toupper(t[0]);
								printf("s: %s\n", s);
								printf("t: %s\n", t);
							}
						</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
							make copy
							./copy
							s: hi
							s: Hi
							t: Hi
						</code></pre>
					<p>
						The program takes a user input, and stores it in a pointer,
						<span class="monoText">s</span>. We then declare another variable, a pointer <span class="monoText">t</span>, and assign it the pointer <span class="monoText">s</span> (effectively making a copy of <span class="monoText">s</span>). Executing the program, we see no errors in compiling, but something odd happened. We only passed to the function <span class="monoText">toupper()</span> the first character of <span class="monoText">t</span>. Instead of only capitalizing the first character of <span class="monoText">t</span>, C also capitalized the first character of <span class="monoText">s</span>. What happened?
					</p>
					<p>
						This is occurring because we did not copy the string
						<span class="monoText">hi</span>. What we really did was copy the address of the string <span class="monoText">hi</span>, and assigned that address to the variable <span class="monoText">t</span>. Accordingly, what we passed to the <span class="monoText">toupper()</span> function is a string that is one in the same <span class="monoText">hi</span>&mdash;both <span class="monoText">s</span> and <span class="monoText">t</span> are pointing to the same string, <span class="monoText">hi</span>. Visually, this looks like:
					</p>
					<figure>
						<img src="images/copying_pointers.svg" alt="copying pointers" class="thirty-p" loading="lazy"/>
					</figure>
					<p>
						How do copy strings with pointers then? Well, we know that
						<span class="monoText">s</span> and <span class="monoText">t</span> are pointing to the same address, and that address starts a string. And since a string is just an array of characters, we can loop over the string, copying each character into <span class="monoText">t</span>. To make a copy of the string itself, however, we need additional memory. If, for example, we want to make a copy and store the string <span class="monoText">Hi!</span>, we need 4 more bytes of memory (1 byte for <span class="monoText">H</span>, 1 byte for <span class="monoText">i</span>, 1 byte for <span class="monoText">!</span>, and 1 byte for <span class="monoText">\0</span>). To get these additional bytes, we must actually tell C to give us the additional bytes. This is done with the <span class="monoText">malloc()</span> function (read "malok," for "memory allocation"). The <span class="monoText">malloc()</span> function takes as input a number&mdash;how many bytes of memory we want. Note that
						the <span class="monoText">malloc()</span> function comes from a library, <span class="monoText">stdlib.h</span>.
					</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;ctype.h&gt;
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");

								char *t = malloc(strlen() + 1);

								for (int i = 0; n = strlen(s); i <= n; i++)
								{
									t[i] = s[i];
								}

								t[0] = toupper(t[0]);

								printf("s: %s\n", s);
								printf("t: %s\n", t);
							}
						</code></pre>
					<p>
						Notice that instead of passing an explicit number into the function
						<span class="monoText">malloc()</span>, we passed <span class="monoText">strlen() + 1</span>. This is because we don't want to have to manually count the number of characters in a string each time. Instead, we let the function <span class="monoText">strlen()</span> do that for us. <span class="monoText">strlen()</span> will return a number&mdash;the number of characters in a string&mdash;and we add <span class="monoText">1</span> to that number. Why? Because <span class="monoText">strlen()</span> does not count the string's delimiter, <span class="monoText">\0</span>. We need that delimiter when we copy the string; without it, our copied string does not have a clear ending.
					</p>
					<p>Notice further the <span class="monoText">for</span> loop we used. Instead of simply writing <span class="monoText">i < n</span>, we wrote <span class="monoText">i <= n</span>. This is because again, we need to include our delimiter, the null character <span class="monoText">\0</span>. Without it, the <span class="monoText">for</span> loop will only run from <span class="monoText">H</span> to <span class="monoText">!</span>, the length of the string. We need to iterate one more than the length returned by <span class="monoText">strlen()</span>. Compiling, we obtain our expected results:</p>
					<pre class="command-line language-bash" data-output="4-5"><code>
							make copy
							./copy
							s: hi!
							s: hi!
							t: Hi!
						</code></pre>
					<p>We can write the same code, without using the square bracket notation for arrays:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;ctype.h&gt;
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");

								char *t = malloc(strlen() + 1);

								for (int i = 0; n = strlen(s); i <= n; i++)
								{
									*(t + i) = *(s + i);
								}

								*t = toupper(*t);

								printf("s: %s\n", s);
								printf("t: %s\n", t);
							}
						</code></pre>
					<p>In the code above, replaced <span class="monoText">t[i]</span> and <span class="monoText">s[i]</span> with <span class="monoText">*(t + i)</span> and <span class="monoText">*(s + i)</span> respectively. These are equivalent notations. Nevertheless, the square bracket notation is far more readable than the pointer notation. There is, however, an improvement we can make to the code above. We didn't consider all of the cases for user inputs&mdash;what if the user hits <span class="monoText">enter</span> without inputting any string? If that happens, then we would be capitalizing a string that does not exist. This is not something we want to do because we do not know what its consequences would be.</p>
					<p>
						Another situation we should address is when
						<span class="monoText">t</span> does not have a valid memory address. The function <span class="monoText">malloc()</span>, most of the time, will return the address of a chunk of memory it has allocated in response to our call. Like the function <span class="monoText">get_string()</span>, it will return the address of the first byte of the allocated memory. However, this is not guaranteed. There are times where <span class="monoText">malloc()</span> does not return a valid address, like when our computer is completely out of memory (we see this happen when our computer freezes, hangs, throws on the spinning color wheel, or reboot on its own). To ensure that the return from <span class="monoText">malloc()</span> is a valid memory address, we need to check for the condition <span class="monoText">(t == NULL)</span>. If <span class="monoText">malloc()</span>'s return value is <span class="monoText">NULL</span>, then we want to return an error (i.e.,
						<span class="monoText">return 1</span>).
					</p>
					<p>Do not confuse the value <span class="monoText">NULL</span> with the value <span class="monoText">NUL</span>. The value <span class="monoText">NUL</span> is the delimiter for strings, <span class="monoText">\0</span>. The value <span class="monoText">NULL</span> represents the <span class="italicsText">null pointer</span>&mdash;the address <span class="monoText">0</span>, or, more practically, the absence of an address.</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;ctype.h&gt;
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");

								char *t = malloc(strlen() + 1);

								if(t == NULL)
								{
									return 1;
								}

								for (int i = 0; n = strlen(s); i <= n; i++)
								{
									t[i] = s[i];
								}

								if (strlen(t) > 0)
								{
									t[0] = toupper(t[0]);
								}

								printf("s: %s\n", s);
								printf("t: %s\n", t);
							}
						</code></pre>
					<p>
						As one can see from the code above, copying strings directly with pointers is takes up a fair amount of lines. This is precisely why there are functions built for the task, such as
						<span class="monoText">strcpy()</span>. The function <span class="monoText">strcpy()</span> takes two arguments, the first being the variable we want to store the copy in, and the second being the variable containing the string to be copied. Thus:
					</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;ctype.h&gt;
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");

								char *t = malloc(strlen() + 1);

								if(t == NULL)
								{
									return 1;
								}

								strcpy(t, s);

								if (strlen(t) > 0)
								{
									t[0] = toupper(t[0]);
								}

								printf("s: %s\n", s);
								printf("t: %s\n", t);
							}
						</code></pre>
					<p>There is one final potential bug we should address in the program. Whenever we use the function <span class="monoText">malloc()</span>, we, as the programmers, must give back the memory we were allocated. Normally, when a computer allocates memory, it will move data around to make room for more data. When we explicitly call <span class="monoText">malloc()</span>, however, the computer will not move our allocated memory around. It will stay in place. What this means is, if we use <span class="monoText">malloc()</span> enough, we will eventually run out of memory. Consequently, whenever we use <span class="monoText">malloc()</span>, we need to include code telling the computer to "free up" that allocated memory space once we're done using it. To do so, we simply include the function <span class="monoText">free()</span> at the end of our program:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;ctype.h&gt;
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = get_string("s: ");

								char *t = malloc(strlen() + 1);

								if(t == NULL)
								{
									return 1;
								}

								strcpy(t, s);

								if (strlen(t) > 0)
								{
									t[0] = toupper(t[0]);
								}

								printf("s: %s\n", s);
								printf("t: %s\n", t);

								free(t);
							}
						</code></pre>
					<p>In our program, we called <span class="monoText">malloc()</span> to allocate 4 bytes of memory for a copy of our string. By calling the function <span class="monoText">free()</span> at the end of our program, we free up the <span class="underlineText">first byte</span> of those 4 bytes. What this means is, whenever we use the function <span class="monoText">malloc()</span>, we always&mdash;always&mdash;must keep track of how many bytes were allocated. To ensure that <span class="monoText">free()</span> frees up <span class="italicsText">all</span> of the memory allocated, we need to make sure that the variable we pass into <span class="monoText">free()</span> contains the address of our copied string. Because we did so in our program, passing the variable <span class="monoText">t</span> into <span class="monoText">free()</span> will free up all of the memory we were allocated.</p>
				</section>

				<section id="debugging_memory_issues" class="grid-item">
					<h4>Debugging Memory Issues</h4>
					<p>
						Programming in C requires getting our hands dirty with memory. And because we work so closely with memory, we are bound to encounter memory bugs, such as the dreaded
						<span class="monoText">segmentation fault</span>. Fortunately, there are plethora of memory debugging tools. One such tool is <span class="monoText">valgrind</span>, a C program almost always available by default on most modern operating systems. When we run <span class="monoText">valgrind</span> on our programs, <span class="monoText">valgrind</span> will detect if we're doing anything wrong or bad with memory. For example, with <span class="monoText">segmentation fault</span>, <span class="monoText">valgrind</span> will tell us what memory we touched that should not have been touched. The program will also detect if we neglected to call the function <span class="monoText">free()</span> after using <span class="monoText">malloc()</span>. If we use <span class="monoText">malloc()</span> a certain amount of times and do not have the equivalent amount of <span class="monoText">free()</span> calls, <span class="monoText">valgrind</span> will notify us that we have a
						<span class="italicsText">memory leak</span>.
					</p>
					<p>Memory leaks are almost always the reason behind computers slowing down to a crawl or completely freezing. As one might notice, these slow-downs or freezes almost always happen after we've been using our computers for a long time, or if we have too many programs open at the same time. For example, we might have an unwieldy amount of tabs open in Chrome. Each of those tabs takes up memory. Open enough tabs, and your computer will eventually freeze if Chrome doesn't do so first. If a computer freezes up from just running one program, then it's more than likely because that program is poorly written: a memory leak caused by neglecting to free up memory after allocating memory. Note, however, that sometimes it isn't the programmer's fault&mdash;they probably did not expect you to have a thousand and one tabs open in Chrome while you edit a four gigabyte file in Final Cut Studio.</p>
					<p>To see how <span class="monoText">valgrind</span> works, consider the following program generating memory bugs:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = malloc(3);
								s[0] = 'H';
								s[1] = 'I';
								s[2] = '!';
								s[3] = '\0';
								printf("%s\n", s);
							}
						</code></pre>
					<p>
						In the program above, we allocated memory for our string
						<span class="monoText">HI!</span> manually. We also wrote a mistake: (1) allocating just 3 bytes of memory with <span class="monoText">malloc()</span> when we need 4 bytes of memory, and (2) neglecting to use the <span class="monoText">free()</span> function. Compiling:
					</p>
					<pre class="command-line language-bash" data-output="3"><code>
							make memory
							./memory
							HI!
						</code></pre>
					<p>
						It seems to work just fine. However, while it may run just fine now, we are bound to encounter problems further down the line. Let's run
						<span class="monoText">valgrind</span> on the program:
					</p>
					<pre class="command-line language-bash" data-output="2-43"><code>
							valgrind ./memory
							==361== Memcheck, a memory error detector
							==361== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
							==361== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
							==361== Command: ./memory
							==361== 
							==361== Invalid write of size 1
							==361==    at 0x401171: main (memory.c:10)
							==361==  Address 0x4dd7043 is 0 bytes after a block of size 3 alloc'd
							==361==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
							==361==    by 0x401151: main (memory.c:6)
							==361== 
							==361== Invalid read of size 1
							==361==    at 0x483EF54: strlen (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
							==361==    by 0x4C5EE94: __vfprintf_internal (vfprintf-internal.c:1688)
							==361==    by 0x4C60021: buffered_vfprintf (vfprintf-internal.c:2377)
							==361==    by 0x4C5CEA3: __vfprintf_internal (vfprintf-internal.c:1346)
							==361==    by 0x4C47EBE: printf (printf.c:33)
							==361==    by 0x401189: main (memory.c:11)
							==361==  Address 0x4dd7043 is 0 bytes after a block of size 3 alloc'd
							==361==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
							==361==    by 0x401151: main (memory.c:6)
							==361== 
							HI!
							==361== 
							==361== HEAP SUMMARY:
							==361==     in use at exit: 3 bytes in 1 blocks
							==361==   total heap usage: 1 allocs, 0 frees, 3 bytes allocated
							==361== 
							==361== 3 bytes in 1 blocks are definitely lost in loss record 1 of 1
							==361==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
							==361==    by 0x401151: main (memory.c:6)
							==361== 
							==361== LEAK SUMMARY:
							==361==    definitely lost: 3 bytes in 1 blocks
							==361==    indirectly lost: 0 bytes in 0 blocks
							==361==      possibly lost: 0 bytes in 0 blocks
							==361==    still reachable: 0 bytes in 0 blocks
							==361==         suppressed: 0 bytes in 0 blocks
							==361== 
							==361== For lists of detected and suppressed errors, rerun with: -s
							==361== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
						</code></pre>
					<p>
						We get a massive sequence of outputs. There are, however, a few lines that should immediately take our attention. One particularly worrying output is
						<span class="monoText">Invalid write of size 1</span>. Just below that line, we see <span class="monoText">at 0x401171: main (memory.c:10)</span>. This tells us that we have a memory problem at line 10 in our program. Another output that should catch our attention is the line stating <span class="monoText">Invalid read of size 1</span>. That appears to be on line 11. If we keep looking, we see yet another troublesome line: <span class="monoText">3 bytes in 1 blocks are definitely lost in loss record of 1 of 1</span>. Then, at the very bottom, we see the <span class="monoText">LEAK SUMMARY</span>. It tells us that 3 bytes are definitely lost.
					</p>
					<p>
						What all of this tells us is that there are three problems: (1) a
						<span class="monoText">write</span> problem, (2) a <span class="monoText">read</span> problem, and (3) a memory leak. The word <span class="monoText">write</span> in computer science refers to <span class="italicsText">changing</span> a value. Accordingly, we have a problem with changing a value. The word <span class="monoText">read</span> in computer science refers to <span class="italicsText">using</span> or <span class="italicsText">printing</span> a value. Thus, we have a problem with using a value.
					</p>
					<p>
						Let's focus on line 10 in our program. That line states
						<span class="monoText">s[3] = '\0'</span>. The <span class="monoText">valgrind</span> output tells us that this is an <span class="italicsText">invalid write</span>. Why is it an invalid write? Well, because we only allocated 3 bytes of memory for our string <span class="monoText">HI!</span>. By allocating those 3 bytes, we were free to touch the first, second, and third bytes, but only those bytes. We had no business touching the fourth byte, because we were never allocated that byte.
					</p>
					<p>On line 11, we wrote <span class="monoText">prinf("%s\n", s)</span>. <span class="monoText">valgrind</span> tells us that this is an <span class="italicsText">invalid read</span>. Why is it an invalid read? Because we're telling C to use a string that touches memory we should not have touched at all.</p>
					<p>Finally, <span class="monoText">valgrind</span> tells us that we have a <span class="italicsText">memory leak</span> problem because we did not free up memory after using&mdash;we never called <span class="monoText">free()</span> after using <span class="monoText">malloc()</span>.</p>
					<p>Given what <span class="monoText">valgrind</span> has told us, let's debug our program:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;
							#include &lt;stdlib.h&gt;

							int main(void)
							{
								char *s = malloc(4);
								s[0] = 'H';
								s[1] = 'I';
								s[2] = '!';
								s[3] = '\0';
								printf("%s\n", s);
								free(s);
							}
						</code></pre>
					<pre class="command-line language-bash" data-output="3"><code>
							make memory
							./memory
							HI!
						</code></pre>
					<p>
						Our progrma runs just fine, but let's run
						<span class="monoText">valgrind</span> just to be sure:
					</p>
					<pre class="command-line language-bash" data-output="2-15"><code>
							valgrind ./memory
							==546== Memcheck, a memory error detector
							==546== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
							==546== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
							==546== Command: ./memory
							==546== 
							HI!
							==546== 
							==546== HEAP SUMMARY:
							==546==     in use at exit: 0 bytes in 0 blocks
							==546==   total heap usage: 1 allocs, 1 frees, 4 bytes allocated
							==546== 
							==546== All heap blocks were freed -- no leaks are possible
							==546== 
							==546== For lists of detected and suppressed errors, rerun with: -s
							==546== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
						</code></pre>
					<p><span class="monoText">valgrind</span> tells us <span class="monoText">All heap blocks were freed -- no leaks are possible</span>, and at the very end, it says <span class="monoText">ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span>. This tells us that our program has no memory bugs.</p>
					<p>It is <span class="underlineText">always</span> best practice that whenever we write programs in C allocating memory, we run <span class="monoText">valgrind</span> on the program, regardless of its size, how memory intensive it is, or whether it outputs expected results.</p>
					<p>To see just how bad a memory leak can be, consider the following code:</p>
					<pre class="language-c"><code>
							int main(void)
							{
								int *x;
								int *y;

								x = malloc(sizeof(int));

								*x = 42;
								*y = 13;

								y = x;

								*y = 13;
							}
						</code></pre>
					<p>
						In the code, we declared two pointers,
						<span class="monoText">int *x</span> and <span class="monoText">int *y</span>&mdash;we are creating two points to store the addresses of <span class="monoText">int</span> values. Notice, however, that we aren't assigning values to those pointers. Instead, they go uninitialized until we reach <span class="monoText">x = malloc(sizeof(int))</span>. There, we used the <span class="monoText">sizeof()</span> function, a function in C that tells us the size of a data type. By passing that value into <span class="monoText">malloc()</span> are telling <span class="monoText">malloc()</span> to allocate enough memory for the size of whatever <span class="monoText">int</span> value we are going to assign to our pointer <span class="monoText">x</span>. Because the pointer <span class="monoText">x</span> will store an <span class="monoText">int</span> value, <span class="monoText">malloc()</span> will allocate 4 bytes (on a modern computer). More specifically,
						<span class="monoText">malloc()</span> will allocate memory for the first byte in <span class="monoText">x</span>.
					</p>
					<p>The next statement is <span class="monoText">*x = 42</span>. Here, we tell C, go to the address of <span class="monoText">x</span>, and store in it the value <span class="monoText">42</span>. Similarly, the next line, <span class="monoText">*y = 13</span>, tells C to go the address of <span class="monoText">y</span>, and store in it the value <span class="monoText">13</span>. Simple enough. But there's a problem. What exactly is inside <span class="monoText">y</span>? The program never assigned <span class="monoText">y</span> a value. At least with the variable <span class="monoText">x</span>, we assigned it a value, a memory allocation of 4 bytes.</p>
					<p>
						The problem goes to a nuance about the way computers work. In all of our programs, whenever we ourselves initialize a variable, the compiler allocates memory automatically. For example, writing
						<span class="monoText">int x = 7</span> automatically allocates 4 bytes of memory for our value <span class="monoText">7</span>. If, however, we have not personally allocated memory for a value (as is the case for <span class="monoText">int</span> value goes into <span class="monoText">y</span> in the program above), we must assume that the value is a <span class="boldItalics">garbage value</span>&mdash;a value we do not know. This is because we can <span class="underlineText">never</span> trust what the contents of a computer's memory space are, since data constantly moves around memory: memory spaces are freed up and reused over and over again as programs run on the computer. When memory is freed up, the value that was originally there doesn't get "erased." It simply moves to another place in memory. This means there are remnants of previous values all over a computer's RAM. And because of those remnants, we can never know for certain which values are where.
					</p>
					<p>
						Following these facts, the problem with
						<span class="monoText">*y = 13</span> is that we're telling C to store the value <span class="monoText">13</span> in an address whose contents we don't even know. Chances are, that address is already occupied by some other data, and C will display a <span class="monoText">segmentation fault</span>.
					</p>
				</section>

				<section id="garbage_values" class="grid-item">
					<h5>Garbage Values</h5>
					<p>We can actually see the garbage values in our computer's memory with a simple program. Suppose we wrote the following program:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							int main(void)
							{
								int scores[3];
								for (int i = 0; i < 3; i++)
								{
									printf("%\n", scores[i]);
								}
							}
						</code></pre>
					<p>
						The code above creates an array called
						<span class="monoText">scores</span>, with 3 elements. Then we tell C to iterate through <span class="monoText">scores</span>, printing out whatever is inside <span class="monoText">scores[i]</span>. However, we deliberately did not initialize any of the values to be contained in the array <span class="monoText">scores</span>. This means that we have no idea what's going to be inside <span class="monoText">scores</span>. Because we don't know what those values will be, they're going to be garbage values. Compiling the program:
					</p>
					<pre class="command-line language-bash" data-output=""><code>
							make garbage
							./garbage
							1057480368
							32764
							0
						</code></pre>
					<p>The values above, <span class="monoText">1057480368</span>, <span class="monoText">32767</span>, and <span class="monoText">0</span>, are garbage values. There is, however, one exception to this default behavior of leaving garbage values. Uninitialized global variables (those declared outside <span class="monoText">int main(void)</span>), are, by default, initialized to the value <span class="monoText">NULL</span>. But, we should never count on this exception. Instead, we should always initialize values before touching or reading them.</p>
				</section>

				<section id="value_swapping_with_pointers" class="grid-item">
					<h4>Value Swapping &amp; Pointers</h4>
					<p>
						Knowing about pointers helps with optimizing programs, as well as debugging potential issues. For example, recall that with sorting algorithms, a common step is to
						<span class="italicsText">swap</span> values. The action of swapping two values is directly tied to pointers. How exactly does swapping a value work in memory? Well, consider a simple example. Suppose we had two glasses, one filled with orange juice, and the other filled with tequila. Now suppose we wanted to swap the glasses containing the liquids&mdash;the orange juice glass will contain tequila, and the tequila glass will contain orange juice. How would we go about making this swap? With only two glasses, it's impossible, unless we want two glasses of tequila sunrises. What we need is a third glass, to pour either the orange juice or the tequila into, leaving the respective glass empty, then pour the other liquid into the empty glass, then pour the transferred liquid into the other liquid's empty glass. In doing so, we effectively swap the glasses containing the liquids.
					</p>
					<p>
						The exact same process applies to swapping values in RAM. We have one value, say <span class="monoText">1</span>, in a particular memory space, say <span class="monoText">0x123</span>, and another value, say <span class="monoText">2</span>, in another memory space, say <span class="monoText">0x124</span>. To swap the values, we need a third memory space, say <span class="monoText">0x125</span>, to place either <span class="monoText">1</span> or <span class="monoText">2</span> into. Suppose we chose <span class="monoText">1</span>. We move the value <span class="monoText">1</span> into the third memory space, <span class="monoText">0x125</span>, leaving <span class="monoText">0x123</span> empty. We then move <span class="monoText">2</span> into the space <span class="monoText">0x123</span>, then move <span class="monoText">1</span> into the space <span class="monoText">0x124</span>. After all is said and done, both <span class="monoText">1</span> and
						<span class="monoText">2</span> are swapped: <span class="monoText">1</span> was originally in <span class="monoText">0x123</span>, and <span class="monoText">2</span> was originally in <span class="monoText">0x124</span>, but after moving them around, <span class="monoText">1</span> is in <span class="monoText">0x124</span>, and <span class="monoText">2</span> is in <span class="monoText">0x123</span>.
					</p>
					<p>Let's see this ideas by writing them in a program:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							void swap(int a, int b);

							int main(void)
							{
								int x = 1;
								int y = 2;

								printf("x is %i, y is %i\n", x, y);
								swap(x, y);
								printf("x is %i, y is %i\n", x, y);
							}

							void swap(int a, int b)
							{
								int tmp = a;
								a = b;
								b = tmp;
							}
						</code></pre>
					<p>
						In the program above, we wrote a simple function called
						<span class="monoText">swap()</span>. That function will take two <span class="monoText">int</span> type values as arguments. Inside that function, a variable called <span class="monoText">tmp</span> of type <span class="monoText">int</span> is assigned the value <span class="monoText">a</span>, the value <span class="monoText">a</span> is assigned the value <span class="monoText">b</span>, and the value <span class="monoText">b</span> is assigned the value <span class="monoText">tmp</span>. We then run that function in <span class="monoText">int main(void)</span>. Compiling this program:
					</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
							make swap
							./swap
							x is 1, y is 2
							x is 1, y is 2
						</code></pre>
					<p>
						It doesn't appear to be working. We wanted
						<span class="monoText">1</span> and <span class="monoText">2</span> to swap, but they're clearly still the same. What happened? Let's debug using <span class="monoText">printf()</span>:
					</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							void swap(int a, int b);

							int main(void)
							{
								int x = 1;
								int y = 2;

								printf("x is %i, y is %i\n", x, y);
								swap(x, y);
								printf("x is %i, y is %i\n", x, y);
							}

							void swap(int a, int b)
							{
								printf("a is %i, b is %i\n", a, b);
								int tmp = a;
								a = b;
								b = tmp;
								printf("a is %i, b is %i\n", a, b);
							}
						</code></pre>
					<pre class="command-line language-bash" data-output="3-5"><code>
							make swap
							./swap
							x is 1, y is 2
							a is 1, b is 2
							a is 2, b is 1
							x is 1, y is 2
						</code></pre>
					<p>It looks the swap did work for <span class="monoText">a</span> and <span class="monoText">b</span>, so at the very least, our logic is correct. But, it's not working for <span class="monoText">x</span> and <span class="monoText">y</span>. We can infer then that our <span class="monoText">swap()</span> function works, but the function <span class="monoText">main()</span> is not seeing the results.</p>
					<p>The bug stems from the way functions are run inside a computer. Recall that each chip on a computer's RAM is a rectangular grid of memory. Each square in the grid is part of a row, called a <span class="boldItalics">frame</span>. Frames, together, form various <span class="boldItalics">regions</span> of memory. The computer does not just place data anywhere on the grid&mdash;there are rules. In particular, whenever the computer allocates data, it follows set procedures dictating which values go to which regions of memory. The regions can be thought of as:</p>
					<figure>
						<img src="images/ram_regions.svg" alt="ram regions" class="thirty-p" loading="lazy"/>
					</figure>
					<p>
						For example, when we run a program by writing
						<span class="monoText">./program</span>, or when you double click an icon in the computer's GUI, that triggers the program's machine code (the 0s and 1s) to be loaded at the very top of the grid, taking up what can be thought of as an entire row. Just below that are all of the global variables&mdash;the constants placed outside of functions. Below the global variables is the <span class="boldItalics">heap</span>&mdash;a large region of memory that <span class="monoText">malloc()</span> uses to allocate memory. Anytime we call <span class="monoText">malloc()</span>, we are allocated memory from the heap. But, that large region is not just allocated to heap. There's another entity competing for space, the <span class="boldItalics">stack</span>&mdash;the region of memory allocated for functions.
					</p>
					<p>Thus, the large region below the regions for machine code and global variables is shared by both the heap and the stack. Fortunately, there's usually more than enough memory in the region shared by the heap and the stack such that the two never collide.</p>
					<p>The stack is specifically for functions. Thus, when we run the function <span class="monoText">main()</span>, it goes to a region at the bottom of the rectangle. When we called our function <span class="monoText">swap()</span>, <span class="monoText">swap()</span> used a region of memory just above <span class="monoText">main()</span>. Once <span class="monoText">swap</span> has finished executing, that memory is freed up, and occupied by garbage values. Knowing this, we visually see how our program is running:</p>
					<figure>
						<img src="images/swap_function_ram.svg" alt="swap function ram" loading="lazy"/>
					</figure>
					<p>
						Our program has statements in the
						<span class="monoText">main()</span> function (step 1). Specifically, it initializes a variable <span class="monoText">x</span> with the <span class="monoText">int</span> value <span class="monoText">1</span>. It also initializes a variable <span class="monoText">y</span> with <span class="monoText">int</span> value <span class="monoText">2</span>. Thus, at step 1, the <span class="monoText">main()</span> function takes up a row of memory (the red region in the diagram above), where the variable <span class="monoText">x</span> takes up 4 bytes, and the variable <span class="monoText">y</span> takes up 4 bytes.
					</p>
					<p>Then we called the <span class="monoText">swap()</span> function (step 2). That function takes two arguments, <span class="monoText">a</span> and <span class="monoText">b</span>, which become copies of <span class="monoText">x</span> and <span class="monoText">y</span>. As such, the <span class="monoText">swap()</span> function takes up the next row in memory, where <span class="monoText">a</span> takes up 4 bytes to store the value <span class="monoText">1</span>, and <span class="monoText">b</span> takes up 4 bytes to store the value <span class="monoText">2</span>. But, there's a third variable, <span class="monoText">tmp</span>, which stores the value assigned to <span class="monoText">a</span>, the <span class="monoText">int</span> value <span class="monoText">1</span>. Consequently, another 4 bytes of memory, visually represented as a row above, is taken up by the variable <span class="monoText">tmp</span>, storing the value <span class="monoText">1</span>.</p>
					<p>Further down the <span class="monoText">swap()</span> function (step 3), we assigned the value of <span class="monoText">b</span> to the value of <span class="monoText">a</span>, making <span class="monoText">a</span> store the value <span class="monoText">2</span>. Then we assigned the value of <span class="monoText">tmp</span> to the value of <span class="monoText">b</span>, making <span class="monoText">b</span> store the value of <span class="monoText">a</span>, which is the <span class="monoText">int</span> value <span class="monoText">1</span>.</p>
					<p>But, as soon as <span class="monoText">swap()</span> finishes, the memory spaces they occupied are cleared up, and occupied by garbate values (step 4). This is why we do not see the values for <span class="monoText">x</span> and <span class="monoText">y</span> switching.</p>
					<p>
						What this all means is that we need to write our
						<span class="monoText">swap()</span> function in such a way that it actually changes the values of <span class="monoText">x</span> and <span class="monoText">y</span>. How might we rewrite our program to do this? We can use pointers. Instead of passing <span class="monoText">x</span> and <span class="monoText">y</span>, we should pass in the address of <span class="monoText">x</span> and the address of <span class="monoText">y</span>. This way, our function <span class="monoText">swap()</span> can go to those addresses and perform the swap.
					</p>
					<p>
						A pointer is fairly large, so we need more memory, 8 bytes to be specific. Thus, when we assign the address of
						<span class="monoText">x</span> to our variable <span class="monoText">a</span> in <span class="monoText">swap()</span>, we will need 8 bytes of memory for <span class="monoText">a</span>. Similarly, when we assign the address of <span class="monoText">y</span> to our variable <span class="monoText">b</span> in <span class="monoText">swap()</span>, we will need another 8 bytes. And, we need additional memory for our temporary variable, <span class="monoText">tmp</span>. <span class="monoText">tmp</span>, however, will only need 4 bytes of memory, because it just needs to store an <span class="monoText">int</span> value, rather than an address.
					</p>
					<p>
						Putting it all together. Suppose that our variable
						<span class="monoText">x</span> is at address <span class="monoText">0x123</span> and <span class="monoText">y</span> is at address <span class="monoText">0x127</span>. Then we have <span class="monoText">a</span> store the address of <span class="monoText">x</span> (<span class="monoText">0x123</span>) and <span class="monoText">b</span> store the address of <span class="monoText">y</span> (<span class="monoText">0x127</span>). Our code then needs to tell C, "Store in the variable <span class="monoText">tmp</span> whatever value is at the address stored in <span class="monoText">a</span>." Then our code needs to tell C, "Change the value inside the address stored in <span class="monoText">a</span> to whatever value is stored in the address stored in <span class="monoText">b</span>." Since <span class="monoText">b</span> stores the address containing the <span class="monoText">int</span> value <span class="monoText">2</span>, the value stored in the address stored in
						<span class="monoText">a</span> (the <span class="monoText">int</span> value <span class="monoText">1</span>) will be changed to <span class="monoText">2</span>. The final step then is to tell C, "Go to the address stored in <span class="monoText">b</span>, and changed the value inside that address to the value stored in <span class="monoText">tmp</span>."
					</p>
					<p>Writing all of this:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							void swap(int *a, int *b)

							int main(void)
							{
								int x = 1;
								int y = 2;

								printf("x is %i, y is %i\n", x, y);
								swap(&x, &y);
								printf("x is %i, y is %i\n", x, y);
							}

							void swap(int *a, int *b)
							{
								int tmp = *a;
								*a = *b;
								*b = tmp;
							}
						</code></pre>
					<p>
						In the code above, we made several changes to the original program. First, we changed the arguments to be passed into
						<span class="monoText">swap()</span>. Instead of taking <span class="monoText">int</span> values, <span class="monoText">swap()</span> is going to take pointer (address) values. Then, inside <span class="monoText">swap()</span>, we assign to <span class="monoText">tmp</span> whatever is value is stored in the address stored in <span class="monoText">*a</span>. Then we wrote <span class="monoText">*a = *b</span>, which tells C to store in the address stored in <span class="monoText">*a</span> whatever value is stored in the address stored in <span class="monoText">*b</span>. Then we wrote <span class="monoText">*b = tmp</span>, which then tells C to store in <span class="monoText">*b</span> whatever value is stored in the variable <span class="monoText">tmp</span>. Because we changed the arguments taken by <span class="monoText">swap()</span> we appropriately made the corresponding changes in our prototype statement. Finally, in the
						<span class="monoText">main()</span> function, we changed the values passed into <span class="monoText">swap()</span> from <span class="monoText">int</span> values to the addresses of <span class="monoText">x</span> and <span class="monoText">y</span> respectively. Compiling the code gives us the desired results:
					</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
							make swap
							./swap
							x is 1, y is 2
							x is 2, y is 1
						</code></pre>
				</section>

				<section id="stack_overflow" class="grid-item">
					<h4>Stack Overflow</h4>
					<p>Because the heap and the stack share the same region of memory, if we use <span class="monoText">malloc()</span> carelessly or call too many functions, we are almost certain to encounter memory problems. The most common of these problems are <span class="boldItalics">heap overflow</span> and <span class="boldItalics">stack overflow</span>.</p>
					<p>A <span class="italicsText">stack overflow</span> is what happens when we call a function over and over again, taking up more and more rows of memory from the bottom up, to the point where the stack overflows into the heap. At some point, we will pass the region allocated to the heap, and begin creeping into the global variables region. If our program hasn't crashed before then, it will almost certainly crash the moment it ventures beyond the heap.</p>
					<p>To see what a stack overflow looks like, let's try and induce it. In the program below, we're going to simply print out a pyramid made of pound symbols:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								int height = get_int("Height: ");
								draw(height);
							}

							void draw(int h)
							{
								for (int i = 1; i <= h; i++)
								{
									for (int j = 1; j <= i; j++)
									{
										printf("#");
									}
									printf("\n");
								}
							}
						</code></pre>
					<p>Compiling:</p>
					<pre class="command-line language-bash" data-output="3-6"><code>
							make pyramid
							./pyramid
							Height: 3
							#
							##
							###
						</code></pre>
					<p>The above code is correct. But what would happen if we made the function <span class="monoText">draw()</span> recursive? In other words, what would happen if <span class="monoText">draw()</span> called itself? How might you print a pyramid of height <span class="monoText">h</span>? Well, you would print a pyramid of height 1, then proceed to print one more row of blocks:</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								int height = get_int("Height: ");
								draw(height);
							}

							void draw(int h)
							{
								draw(h - 1);
								
								for (int i = 0; i < h; i++)
								{
									printf("#");
								}
								printf("\n");
							}
						</code></pre>
					<p>Let's try compiling the program above:</p>
					<pre class="command-line language-bash" data-output="2-7"><code>
							make pyramid
							clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow    pyramid.c  -lcrypt -lcs50 -lm -o pyramid
							pyramid.c:13:1: error: all paths through this function will call itself [-Werror,-Winfinite-recursion]
							{
							^
							1 error generated.
							make: *** [&lt;builtin&gt;: pyramid] Error 1
						</code></pre>
					<p>
						A peculiar error is returned:
						<span class="monoText">all paths through this function will all itself</span>. <span class="monoText">clang</span> has preemptively stopped the function from executing, because it recognized that our function <span class="monoText">draw()</span> calls itself and its input never changes (meaning the function will never stop executing). But, we can override it:
					</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
							clang -o pyramid pyramid.c -lcs50
							./pyramid
							Height: 3
							Segmentation fault
						</code></pre>
					<p>
						It compiled well, but when we executed the program, we were greeted with the dreaded error:
						<span class="monoText">Segmentation fault</span>. The program crashed. This should not come as a surprise. We wrote the program in such a way that <span class="monoText">draw()</span> executes over and over again, without end. Of course it would impermissibly touch memory. What we need to do is rewrite the program so that the recursion can eventually terminate. To do so, we simply need to include condition that is bound to be met, at which point we simply <span class="monoText">return</span>:
					</p>
					<pre class="language-c"><code>
							#include &lt;string.h&gt;
							#include &lt;stdio.h&gt;

							int main(void)
							{
								int height = get_int("Height: ");
								draw(height);
							}

							void draw(int h)
							{
								if (h == 0)
								{
									return;
								}

								draw(h - 1);
								
								for (int i = 0; i < h; i++)
								{
									printf("#");
								}
								printf("\n");
							}
						</code></pre>
					<p>Now the program compiles without memory problems:</p>
					<pre class="command-line language-bash" data-output="3-6"><code>
							make pyramid
							./pyramid
							Height: 3
							#
							##
							###
						</code></pre>
					<p>This leads to a question with respect to practice. Should we use iteration or recursion for repetitive computations? It depends. With iteration, we can rest assured that we will never hit the heap with our functions, because we aren't calling functions over and over again. But, with recursion, we have to be hyper vigilant of whether the recursive function has a base case, whether that base case will eventually be met, and whether that base case will actually stop the recursion. Worse, even if we did have a base case, if we call the recursive function enough times, say a billion times, we will eventually hit a segmentation fault, even if we know for a fact that the recursion will eventually end:</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
							make pyramid
							./pyramid
							Height: 1000000000
							Segmentation fault
						</code></pre>
					<p>Thus, while recursion is most certainly far more elegant than iteration, it without question far more dangerous.</p>
				</section>

				<section id="buffer_overflow" class="grid-item">
					<h4>Buffer Overflow</h4>
					<p>
						Another common memory issue is
						<span class="boldItalics">buffer overflow</span>. A buffer overflow occurs when we allocate memory to an array, but go beyond the allocated memory's end. It can also occur when we use <span class="monoText">malloc()</span> to allocate memory, and use memory beyond what we asked for. A <span class="italicsText">buffer</span> is simply a chunk of memory in RAM.
					</p>
				</section>

				<section id="scanf_function" class="grid-item">
					<h4>The <span class="monoText">scanf()</span> Function</h4>
					<p>
						Many C libraries provide functions for retrieving and returning user inputs. For example: <span class="monoText">get_char()</span> for obtaining character inputs; <span class="monoText">get_double()</span> for obtaining large real number inputs; <span class="monoText">get_float()</span> for typical real number inputs; <span class="monoText">get_int()</span> for typical integer inputs; <span class="monoText">get_long()</span> for larger real number inputs; and <span class="monoText">get_string()</span> for string inputs. All of these functions' behaviors or features can be done with functions provided natively by C. One such function is <span class="monoText">scanf()</span>. The problem, however, is that <span class="monoText">scanf()</span> can be an extremely dangerous function. Many functions provided by C libraries have built-in safeguards, preventing us from doing anything detrimental to our system or computer memory. <span class="monoText">scanf()</span>, however,
						provides no such safeguards, as it was not designed with the idea that programmers would use it for the tasks listed earlier.
					</p>
					<p>We can see how <span class="monoText">scanf()</span> works with the following code:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;

							int main(void)
							{
								int x;
								printf("x: ");
								scanf("%i, &x");
								printf("x: %\n", x);
							}
						</code></pre>
					<p>In the code above, we initialized a variable <span class="monoText">x</span> of type <span class="monoText">int</span>. Then, we tell C to print <span class="monoText">x: </span>, what will appear as a prompt. Then, we used the <span class="monoText">scanf()</span> function&mdash;telling C to get input from the user. But, <span class="monoText">scanf()</span> works only with pointers&mdash;it will "scan" or "listen" to the user's keypresses and store the input returned from a keypress that meets certain conditions. This is why we passed the argument <span class="monoText">&x</span> into the argument. C needs a place in memory to store that input, and by passing <span class="monoText">&x</span> into <span class="monoText">scanf()</span>, we give C that place to use. Compiling the program:</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
						make scanf
						./scanf
						x: 4
						x: 4
					</code></pre>
					<p>Note, however, that if we instead passed a <span class="monoText">char</span> value:</p>
					<pre class="command-line language-bash" data-output="2-3"><code>
						./scanf
						x: y
						x: 0
					</code></pre>
					<p>We get <span class="monoText">0</span>. This is to be expected. The function <span class="monoText">scanf()</span> has no safeguards. Let's try using <span class="monoText">scanf()</span> to retrieve strings:</p>
					<pre class="language-c"><code>
							#include &lt;stdio.h&gt;
							
							int main(void)
							{
								char *s;
								printf("s: ");
								scanf("%s", s);
								printf("s: %s\n", s);
							}
						</code></pre>
					<p>If we tried compiling the program above, we get an error:</p>
					<pre class="command-line language-bash" data-output="2-12"><code>
						make scanf
						clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow    scanf.c  -lcrypt -lcs50 -lm -o scanf
						scanf.c:7:17: error: variable 's' is uninitialized when used here [-Werror,-Wuninitialized]
							scanf("%s", s);
											^
						scanf.c:5:12: note: initialize the variable 's' to silence this warning
							char *s;
									^
										= NULL
						1 error generated.
						make: *** [&lt;builtin&gt;: scanf] Error 1
					</code></pre>
					<p>Let's override:</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
						clang -o scanf scanf.c
						./scanf
						s: HI!
						s: (null)
					</code></pre>
					<p>The program compiled, but we're getting odd results. Instead of displaying the user input <span class="monoText">HI!</span>, it's displaying <span class="monoText">(null)</span>. Why? Because when we declared the variable <span class="monoText">s</span>, a pointer, we took 8 bytes of memory. But, those addresses are filled with garbage values. What we need to do is be more specific with C: Give us 4 bytes of memory. We can do this in two ways:</p>
					<ol>
						<li>Write <span class="monoText">char *s = malloc(4)</span>, or</li>
						<li>Write <span class="monoText">char s[4]</span></li>
					</ol>
					<p>If we went with option 1, <span class="monoText">char *s = malloc(4)</span>, we would ask for, and be allocated, 4 bytes of memory in the <span class="italicsText">heap</span>. If we use <span class="monoText">malloc()</span>, we must use <span class="monoText">free()</span>.</p>
					<p>If, however, we went with option 2 &mdash; <span class="monoText">char s[4]</span> &mdash; we would receive 4 bytes of memory in the <span class="italicsText">stack</span>. More specifically, in <span class="monoText">main()</span>'s frames. If we use the stack, we do not have to worry about using <span class="monoText">free()</span>; C will manage everything from there. For now, let's just use the array syntax for simplicity:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;
						{
							char s[4];
							printf("s: ");
							scanf("%s", s);
							printf("s: %s\n", s);
						}
					</code></pre>
					<pre class="command-line language-bash" data-output="3-4"><code>
						make scanf
						./scanf
						s: HI!
						s: HI!
					</code></pre>
					<p>What if instead the user entered the following:</p>
					<pre class="command-line language-bash" data-output=""><code>
						./scanf
						s: Hello world
						s: Hello
					</code></pre>
					<p>The output is only the first word. This is happening because we only allocated 4 bytes of memory. Because we only allocated 4 bytes of memory, only the first word is stored, so only the first word is displayed. Functions like <span class="monoText">get_string()</span> are designed specifically to avoid the headache of having to preemptively provide the length of a string. More specifically, <span class="monoText">get_string()</span> calls <span class="monoText">malloc()</span> for us, and requests the amount of memory needed for however long the user-inputted string is.</p>
				</section>

				<section id="file_io" class="grid-item">
					<h4>File I/O</h4>
					<p>The term <span class="boldItalics">File I/O</span> refers to the feature of taking inputs and outputs of <span class="italicsText">files</span>, rather than <span class="italicsText">users</span>. So far, many of our programs have strictly used memory. The program runs and stores data in memory, but as soon as the program ends, that data disappears. <span class="italicsText">Files</span> are where we store data permanently.</p>
					<p>C provides the ability to save files permanently. For example, consider the following code:</p>
					<pre class="language-c"><code>
						#include &lt;cs50.h&gt;
						#include &lt;stdio.h&gt;
						#include &lt;string.h&gt;

						int main(void)
						{
							FILE *file = fopen("phonebook.csv", "a");
							if (file == NULL)
							{
								return ;
							}
							char *name = get_string("Name: ");
							char *number = get_string("Number: ");

							fprinf(file, "%s,%s,\n", name, number);

							fclose(file);
						}
					</code></pre>
					<p>We have several pieces of new syntax here. First, the word <span class="monoText">FILE</span> is a data type built-in to C. It is the data type for files. Accordingly, the statement <span class="monoText">FILE *file</span> declares a pointer called <span class="monoText">file</span>, of data type <span class="monoText">FILE</span>. Then, we assigned to that pointer the return from the function <span class="monoText">fopen()</span>. That function opens a file. More specifically, we passed into <span class="monoText">fopen()</span> the arguments <span class="monoText">phonebook.csv</span> and <span class="monoText">a</span>. <span class="monoText">phonebook.csv</span> is a file, and <span class="monoText">a</span> stands for "append." When using the <span class="monoText">fopen()</span> function, there are three "modes" for working with a file. We can <span class="italicsText">read</span>, <span class="italicsText">write</span>, and <span class="italicsText">append</span> (add to the file).</p>
					<p>Towards the end of our program, we see the line <span class="monoText">fprintf(file, "%s,%s,\n", name, number)</span>. This tells C to print to a file the values of <span class="monoText">name</span> and <span class="monoText">number</span>, which are inputted by the user. Thus, the arguments we provide <span class="monoText">fprintf()</span> are <span class="monoText">file</span> (our pointer), <span class="monoText">%s,%s</span> (the values of <span class="monoText">name</span> and <span class="monoText">number</span>), and <span class="monoText">name, number</span> (our pointers storing the addresses where the user inputs are). Compiling:</p>
					<pre class="command-line language-bash" data-output="3-4"><code>
						make phone
						./phone
						Name: Daniel
						Number: 217-433-7854
					</code></pre>
					<p>We do not see any actual output from running our program, but we can see a new file in our system called <span class="monoText">phonebook.csv</span>:</p>
					<pre class="command-line language-bash" data-output="2"><code>
						cat phonebook.csv
						Daniel,217-433-8753,
					</code></pre>
					<p>File manipulation functions ("file I/O functions") are provided by C libraries, such as <span class="monoText">stdio.h</span>. All of the functions have <span class="monoText">FILE*</span> (a <span class="italicsText">file pointer</span>) as one of their parameters, except for the function <span class="monoText">fopen()</span>, the function that obtains a file pointer in the first place. The most common file I/O functions are:</p>
					<ul>
						<li><span class="monoText">fopen()</span></li>
						<li><span class="monoText">fclose()</span></li>
						<li><span class="monoText">fgetc()</span></li>
						<li><span class="monoText">fputc()</span></li>
						<li><span class="monoText">fread()</span></li>
						<li><span class="monoText">fwrite()</span></li>
					</ul>
				</section>

				<section id="the_fopen_function" class="grid-item">
					<h5>The <span class="monoText">fopen()</span> Function</h5>
					<p>The <span class="monoText">fopen()</span> function opens a file and returns a <span class="italicsText">file pointer</span> to that file. That file pointer is what is used as an argument for the other file I/O functions. The general syntax for the <span class="monoText">fopen()</span> function:</p>
					<pre class="language-c"><code>
						FILE* p = fopen(&lt;fileName&gt;, &lt;operation&gt;);
					</code></pre>
					<p>Thus, using the above synax, we might use <span class="monoText">fopen()</span> as such:</p>
					<pre class="language-c"><code>
						FILE* ptr1 = fopen("file1.txt", "r");
					</code></pre>
					<p>where <span class="monoText">ptr</span> is a generic name for a pointer, <span class="monoText">file1.txt</span> is the file we want to point to, and <span class="monoText">r</span> is the action <span class="monoText">read</span>. This code effectively gives us a file pointer to a file we can <span class="italicsText">read</span> information from. Similarly, we might write:</p>
					<pre class="language-c"><code>
						FILE* ptr2 = fopen("file2.txt", "w");
					</code></pre>
					<p>Here, we have file pointer to a file, <span class="monoText">file2.txt</span>, that we can <span class="italicsText">write</span> into. And once more:</p>
					<pre class="language-c"><code>
						FILE* ptr3 = fopen("file3.txt", "a");
					</code></pre>
					<p>This code will give us a file pointer to a file called <span class="monoText">file3.txt</span>, which we can <span class="italicsText">append</span>, or <span class="italicsText">add</span>, information into. The difference between appending and writing into a file is that if we ran <span class="monoText">fopen()</span> on an existing file and passed the argument <span class="monoText">w</span>, the existing file's contents are completely overwritten (making it completely blank for us to add data from scratch).</p>
					<p>The most critical point to remember with <span class="monoText">fopen()</span> is to make sure that <span class="monoText">fopen()</span> does not return the value <span class="monoText">NULL</span>. If we try to dereference a <span class="monoText">NULL</span> pointer, we are going to run into a <span class="monoText">Segmentation fault</span>.</p>
				</section>

				<section id="the_fclose_function" class="grid-item">
					<h5>The <span class="monoText">fclose()</span> Function</h5>
					<p>The <span class="monoText">fclose()</span> function is the companion to the <span class="monoText">fopen()</span> function. It will <span class="italicsText">close</span> the file pointed to by the given file pointer. The general syntax:</p>
					<pre class="language-c"><code>
						fclose(&lt;filePointer&gt;);
					</code></pre>
					<p>Once we have closed a file, we can no longer perform any file I/O functions with the closed file. To use file I/O functions with the file, we must reopen the file with <span class="monoText">fopen()</span>.</p>
				</section>

				<section id="the_fgetc_function" class="grid-item">
					<h5>The <span class="monoText">fgetc()</span> Function</h5>
					<p>With a file pointer, the <span class="monoText">fgetc()</span> function reads and returns the next character from the file pointed to. The general syntax:</p>
					<pre class="language-c"><code>
						char ch = fgetc(&lt;filePointer&gt;);
					</code></pre>
					<p>The code above retrieves the very next character in the file, and stores it in a variable called <span class="monoText">ch</span> of type <span class="monoText">char</span>.</p>
					<p>Note that for <span class="monoText">fgetc()</span> to work, the operation of the file pointer passed in as a parameter in <span class="monoText">fopen()</span> must be <span class="monoText">r</span> for "read." Otherwise, <span class="monoText">fgetc()</span> does not work, and we will receive an error. This reveals a strict limitation of using <span class="monoText">fopen()</span>. If we want to read <span class="italicsText">and</span> write to the same file, we have to open two separate file pointers, with the arguments <span class="monoText">r</span> and <span class="monoText">w</span> passed separately.</p>
					<p>With the <span class="monoText">fgetc()</span> function, we can obtain single characters from files. Using a loop, we can read all of the characters from a file and print them to the screen, one-by-one:</p>
					<pre class="language-c"><code>
						char ch;
						while ((ch = fgetc(ptr)) != EOF)
							printf("%c", ch);
					</code></pre>
					<p>The code above essentially duplicates the <span class="monoText">cat</span> command in Linux. The <span class="monoText">EOF</span> value is the "end of file" character, provided by <span class="monoText">stdio.h</span>.</p>
				</section>

				<section id="the_fputc_function" class="grid-item">
					<h5>The <span class="monoText">fputc() Function</span></h5>
					<p>The <span class="monoText">fputc()</span> function writes or appends a specified character to the pointed-to file. The syntax:</p>
					<pre class="language-c"><code>
						fputc(&lt;character&gt;, &lt;filePointer&gt;)
					</code></pre>
					<p>Note that <span class="monoText">fputc()</span> works only if we pass into <span class="monoText">fopen()</span> the argument <span class="monoText">w</span> for "write" or <span class="monoText">a</span> for "append." Like <span class="monoText">fgetc()</span>, failing to provide one of these arguments will return an error.</p>
					<p>With the <span class="monoText">fputc()</span> function we can write all of the characters in a file into a new file:</p>
					<pre class="language-c"><code>
						char ch;
						while ((ch = fgetc(ptr)) != EOF)
						fputc(ch, ptr2);
					</code></pre>
					<p>This duplicates the <span class="monoText">cp</span> command in Linux.</p>
				</section>

				<section id="the_fread_function" class="grid-item">
					<h5>The <span class="monoText">fread()</span> Function</h5>
					<p>The <span class="monoText">fread()</span> function has the following syntax:</p>
					<pre class="language-c"><code>
						fread(&lt;buffer&gt;, &lt;size&gt;, &lt;qty&gt;, &lt;filePointer&gt;);
					</code></pre>
					<p>The function reads &lt;qty&gt; units of size &lt;size&gt; from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by &lt;buffer&gt;.</p>
				</section>

				<section id="the_fwrite_function" class="grid-item">
					<h5>The <span class="monoText">fread()</span> Function</h5>
					<p>The <span class="monoText">fwrite()</span> function is the equivalent of the the <span class="monoText">fread()</span> function, with the difference being <span class="monoText">fwrite()</span> concerns writing, rather then reading. The syntax is the same:</p>
					<pre class="language-c"><code>
						fwrite(&lt;buffer&gt;, &lt;size&gt;, &lt;qty&gt;, &lt;filePointer&gt;);
					</code></pre>
					<p>Like <span class="monoText">fread()</span>, for <span class="monoText">fwrite()</span> to work, we must pass either <span class="monoText">a</span> or <span class="monoText">w</span> into <span class="monoText">fopen()</span> as arguments.</p>
				</section>

			<!-- ยง Data Structures -->
				<section id="data_structures_in_C" class="grid-item">
					<h3>Data Structures in C</h3>
					<p>With the ability to access data stored in memory, and the ability to store data about locations of data stored in memory, we can create more complex data structures. So far, the most basic data structure we've encountered is the <span class="boldItalics">array</span>.</p>
					<p>The problem with arrays in C is that they aren't exactly resizable. Moreover, arrays in C are <span class="italicsText">contiguous</span> in memory. The elements all take up space one after another. If we declare and array of size 3, the array can only contain three values. We don't have access to the memory around the array &mdash; if it's not occupied by other data in our program, it's occupied by garbage values. This means we must decide in advance how large the array will be. The trouble: We don't always know how large the array is going to be.</p>
					<p>Fortunately, using <span class="monoText">struct</span>, <span class="monoText">.</span> (the dot operator), and <span class="monoText">*</span> (the dereference operator/"go to this address ") allows us to create and use data structures beyond simple arrays. The dot operator (<span class="monoText">.</span>) and the dereference operator (<span class="monoText">*</span>) are so commonly used together that they are often combined into a single operator, <span class="monoText">-></span>.</p>
				</section>

				<section id="linked_lists" class="grid-item">
					<h4>Linked Lists</h4>
					<p>Suppose we have an existing array of three values. Now suppose that we have a fourth value that we want to insert into the array. How do we make space for this fourth value in C, given that arrays are contiguous in memory? One way would be to copy all of the contents of the three-value array into a new area in memory, and insert the fourth value at the very end.</p>

					<p>The problem with this approach is cost &mdash; in the best case scenario, this approach has a run time of ${\omega(1),}$ where it only takes one step to complete the task. In the worst case scenario, the run time is ${O(n),}$ where it takes $n$ steps to complete the copy, given $n$ elements. Arrays may be useful for small data sets, and they are particularly useful for searches, but they quickly become unwieldy once the data sets grow too large.</p>
					
					<p>A more dynamic data structure is a <span class="boldItalics">linked list</span>. With linked lists, we can grow and shrink the data structure without having to touch the original data. The most striking difference between linked lists and arrays: in linked lists, we place the our values anywhere in memory. But how do we know where those values are? Can we find those values? The key to answering this questions is ensuring we have some connection between our values, allowing us to go from one value to the next.</p>

					<figure><img src="images/array_v_linked_list.svg" alt="array versus linked list" class="forty-p" loading="lazy"></figure>
					
					<p>One way to ensure that connection is by taking slightly more space in memory for each of our data values:</p>
					
					<figure><img src="images/extra_space_linked_list.svg" alt="extra space" class="twenty-p" loading="lazy"></figure>

					<p>In other words, rather than using just enough memory to store the values <span class="monoText">1, 2, 3</span>, we will use twice as much memory. We will use this extra memory for <span class="boldItalics">metadata</span> &mdash; data we don't really care about, but will help keep track of our actual data. The values stored in these extra boxes will the succeeding value's address:</p>
					
					<figure><img src="images/metadata_linked_list.svg" alt="metadata" class="thirty-p" loading="lazy"></figure>

					<p>By storing this metadata into an extra space, we have the ability to determine how our values relate to one another. The last value in our list has an extra memory space storing the value <span class="monoText">0x0</span>. This value corresponds to <span class="monoText">NULL</span>, representing the absence of an address. Abstracting all of this, we have a <span class="boldItalics">linked list</span> of numbers:</p>

					<figure><img src="images/linked_list.svg" alt="linked list" class="twenty-p" loading="lazy"></figure>

					<p>The links in a linked list are created by way of addresses, which are provided with pointers. Distilling this idea even further, a linked list is a collection of <span class="boldItalics">nodes</span>, corresponding to data values, connected via pointers. In the diagram above, each of the pink shaded squares represents a node. In C, those nodes are created with <span class="monoText">struct</span>.</p>

					<p>The node in a linked list is a <span class="monoText">struct</span> &mdash; a collection of data values (usually of different data types). The node contains two things: (1) data of some type (<span class="monoText">int</span>, <span class="monoText">char</span>, <span class="monoText">float</span>, etc.), and (2) a <span class="italicsText">pointer</span> to another node of the same type. By <span class="italicsText">linking</span> each of these nodes together, we effectively form a chain. That chain has <span class="underlineText">two</span> endpoints: a beginning (the <span class="boldItalics">head</span>) and an end (the <span class="boldItalics">tail</span>).</p>

					<p>Notice, however, the cost of using a linked list: we're using more memory. Not only are we using memory for data, we're using memory for metadata. This is twice as much memory used compared to using another data structure &mdash; e.g., arrays &mdash; which only need memory for data alone. As with all things in computer science, this is the opportunity cost we must pay to use linked lists.</p>
				</section>

				<section id="implementing_a_linked_list_in_C" class="grid-item">
					<h4>Implementing a Linked List in C</h4>
					<p>Let's implement a linked list in C. As review, recall that to create custom data structures in C, we use the syntax:</p>
					<pre class="language-c"><code>
						typedef struct
						{
							dataType dataName1;
							dataType dataName2;
						}
						dataStructureName;
					</code></pre>
					<p>We create a data structure with a name &mdash; <span class="monoText">dataStructureName</span> &mdash; and we include in its definition however many data types we want, with their corresponding names &mdash; <span class="monoText">dataType dataName</span>.</p>
					<p>Following this syntax, let's name our data structure <span class="monoText">node</span>, and include in its definition two data types: an <span class="monoText">int</span> and a <span class="italicsText">pointer</span> to the next node.</p>
					<pre class="language-c"><code>
						typedef struct
						{
							int number;
							node *next;
						}
						node;
					</code></pre>
					<p>There's a problem with our definition above. We're using <span class="monoText">node</span> in the definition's body, but we mention <span class="monoText">node</span> for the very first time at the very last line, outside the definition. The problem arises because with <span class="monoText">typedef</span>, our <span class="monoText">node</span> <span class="underlineText">does not exist</span> until the compiler reaches the very last semicolon in the code above.</p>
					<p>Fortunately, there's a work around:</p>
					<pre class="language-c"><code>
						typedef struct node
						{
							int number;
							struct node *next;
						}
						node;
					</code></pre>
					<p>The workaround had us write <span class="monoText">node</span> just after <span class="monoText">struct</span>. This syntactical solution is similar to the way protoypes work for functions. It gives C a hint that <span class="monoText">node</span> will be defined. We also changed <span class="monoText">node *next</span> to <span class="monoText">struct node *next</span>. This change is just the way we refer to <span class="monoText">node</span> in C. With the above code, we have defined a node, the core component of linked lists.</p>
					<p>Next question: How do we go from this definition to a linked list?</p>
					<p>Response: With <span class="monoText">node</span> defined, the linked list begins with a pointer. First, we declare a pointer variable called <span class="monoText">list</span>. At the moment, <span class="monoText">list</span> points to nothing. Say we have three numbers, <span class="monoText">1, 2, 3</span>. We want the list to point to <span class="monoText">1</span>, then <span class="monoText">1</span> to point to <span class="monoText">2</span>, then <span class="monoText">2</span> to point to <span class="monoText">3</span>. To do so, however, we need space to store the numbers <span class="monoText">1, 2, 3</span>. How do we get that space? With <span class="monoText">malloc()</span>.Putting this altogether, we should have <span class="monoText">malloc()</span> allocate memory for one <span class="monoText">struct</span>, and place the number <span class="monoText">1</span> in it. Then we use <span class="monoText">malloc()</span> again, and insert the number <span class="monoText">2</span>. Then <span class="monoText">malloc()</span> once more, and insert the number <span class="monoText">3</span>. Once we have all of these <span class="monoText">struct</span>s, we can using pointers to link them all together:</p>
					<figure><img src="images/linked_list_pointers.svg" alt="linked list pointers" class="fifty-p" loading="lazy"></figure>
					<p>The diagram above purposefully places the last <span class="monoText">struct</span>, containing the value <span class="monoText">3</span>, further from the rest. This is because our <span class="monoText">struct</span>s could be anywhere in memory; unlike arrays, they do not have to be contiguous.</p>
					<p>Because <span class="monoText">struct</span>s in linked lists are placed anywhere in memory, the values they contain could be anywhere in memory. And because the values could be anywhere in memory, we cannot rely on <span class="italicsText">binary search</span>. Binary search is much faster than linear search, as it has a run time of ${O(\log n_{n}).}$ Thus, whenever we consider using a linked list, we have to weigh the benefit of (1) not having to resize a data structure upon receiving new data, against (2) the inability to using search algorithms like binary search and more memory usage.</p>
					<p>With the general design thought out, we can now look at the details. The <span class="monoText">list</span> variable was declared, but uninitialized. Thus, <span class="monoText">list</span> does not contain anything at the moment. More accurately, the memory space <span class="monoText">list</span> occupies contains some garbage value. To clear that garbage value, we can assign to <span class="monoText">list</span> the value <span class="monoText">NULL</span>:</p>
					<pre class="language-c"><code>
						node *list = NULL;
					</code></pre>
					<p>Now we need to actually create our <span class="monoText">struct</span>s for each of the data value. To do so, we use <span class="monoText">malloc()</span>. To use <span class="monoText">malloc()</span>, however, we need to pass as an argument how many bytes of memory we want allocated. We do not want to have to manually calculate how many bytes we need each time. So, we use the <span class="monoText">sizeof()</span> function, which calculates how many bytes a given data type takes or needs. Here, our data type is the data structure we defined, <span class="monoText">node</span>:</p>
					<pre class="language-c"><code>
						node *n = malloc((sizeof(node)));
					</code></pre>
					<p>By using <span class="monoText">malloc()</span>, we get allocated memory, and, crucially, we are given a return value &mdash; the address of the first byte occupied by our <span class="monoText">struct</span>. That first byte corresponds to <span class="monoText">number</span>. We store that return value in <span class="monoText">node *n</span>. We store it in <span class="monoText">node *n</span> because the value returned is an address. And because it is an address, we want to store it in a pointer, so we can use that address. All of this causes activity in the memory grid that looks something like this:</p>
					<figure><img src="images/linked_list_garbage_values.svg" alt="garbage values" class="thirty-p" loading="lazy"></figure>
					<p>The next step is to clear the garbage values:</p>
					<pre class="language-c"><code>
						if (n != NULL)
						{
							(*n).number = 1;
						}
					</code></pre>
					<p>Note that we checked the condition <span class="monoText">n != NULL</span>. This is a condition we should <span class="underlineText">always</span> check whenever we use pointers returned from a function. We never want to use a pointer with a value of <span class="monoText">NULL</span>, as that indicates that there is no valid address.</p>
					<p>If the pointer <span class="monoText">n</span> does not have the value <span class="monoText">NULL</span> (i.e., it has a valid address), then we have C do the following: <span class="monoText">(*n).number = 1</span>. The dot operator <span class="monoText">.</span> tells C, go inside the structure stored in <span class="monoText">*n</span>, and then go into the variable called <span class="monoText">number</span>. Once there, store the value <span class="monoText">1</span>:</p>
					<figure><img src="images/linked_list_garbage_cleared.svg" alt="garbage cleared" class="thirty-p" loading="lazy"></figure>
					<p>We can make our code more concise with syntactic sugar:</p>
					<pre class="language-c"><code>
						if (n != NULL)
						{
							n->number = NULL;
						}
					</code></pre>
					<p>The next step is to ensure that C actually remembers where the node <span class="monoText">n</span> is in the computer's memory. So far, <span class="monoText">n</span> has just been a temporary variable.Thus, we need to tell C that list has a node inside of it called <span class="monoText">n</span>.</p>
					<pre class="language-c"><code>
						list = n;
					</code></pre>
					<p>By assigning <span class="monoText">n</span> to <span class="monoText">list</span>, the list now looks like the following:</p>
					<figure><img src="images/linked_list_node_connect.svg" alt="connected links" class="thirty-p" loading="lazy"></figure>
					<p>With all of these details, let's create the next node for the value <span class="monoText">2</span>:</p>
					<pre class="language-c"><code>
						node *n = malloc(sizeof(node));
						if (n != NULL)
						{
							n->number = 2;
							n->next = NULL;
						}
					</code></pre>
					<p>The code above results in the following:</p>
					<figure><img src="images/linked_list_new_struct.svg" alt="new struct" class="thirty-p" loading="lazy"></figure>
					<p>Now we need to make the same connection between <span class="monoText">list</span> and <span class="monoText">1</span>, only this time we need to make a connection between the <span class="monoText">next</span> associated with <span class="monoText">1</span> and the <span class="monoText">n</span> associated with <span class="monoText">2</span>. We do so with the same syntax we used before:</p>
					<pre class="language-c"><code>
						list->next = n;
					</code></pre>
					<p>This results in the following:</p>
					<figure><img src="images/linked_list_connect_new_struct.svg" alt="connect new struct" class="thirty-p" loading="lazy"></figure>
					<p>We execute the same code again to link the third node containing <span class="monoText">3</span>:</p>
					<pre class="language-c"><code>
						node *n = malloc(sizeof(node));
						if (n != NULL)
						{
							n->number = 3;
							n->next = NULL;
						}
					</code></pre>
					<p>The code above creates the <span class="monoText">struct</span> containing the value <span class="monoText">3</span>. Now we link the node for <span class="monoText">2</span> to the <span class="monoText">number</span> containing <span class="monoText">3</span>:</p>
					<pre class="language-c"><code>
						list->next->next = n;
					</code></pre>
					<p>And with that, we get our final picture:</p>
					<figure><img src="images/all_nodes_connected.svg" alt="all nodes connected" class="fifty-p" loading="lazy"></figure>
					<p>Without question, linked lists are much more complicated to implement than arrays. But, through that complexity, we now have a data structure that can grow <span class="italicsText">dynamically</span> &mdash; we can organize data into a data structure that does not require our manually increasing the data structure.</p>
					<p>Considering how linked lists work, what might would be the upper bound running time of searching a linked list? Given that the values stored in memory are located anywhere in memory, searching the linked list for a particular value requires looking at all the individual values in the list. Thus, searching a linked list has an upper bound running time of ${O(n).}$</p>
					<p>What is the upper bound running time for <span class="italicsText">inserting</span> into a linked list? We could just have 1 value to insert, so the upper bound running time is ${O(1).}$ Remember, linked lists do not have to be sorted. The fastest way to insert a value into a linked list is to just insert the new value at the beginning of the list.</p>
				</section>

				<section id="array_comparison" class="grid-item">
					<h4>Using Arrays</h4>
					<p>To clarify the benefits of linked lists, let's try using arrays and pointers to store data. First, let's review the usual way of storing data with arrays:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;

						int main(void)
						{
							int list[3];

							list[0] = 1;
							list[1] = 2;
							list[2] = 3;

							for (int i = 0; i < 3; i++)
							{
								printf("%i\n", list[i]);
							}
						}
					</code></pre>
					<pre class="command-line language-bash" data-output=""><code>
						make list
						./list
						1
						2
						3
					</code></pre>
					<p>Let's now write the same program, but with pointers instead:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;

						int main(void)
						{
							int *list = malloc(3 * sizeof(int));
							if (list == NULL)
							{
								return 1;
							}

							list[0] = 1;
							list[1] = 2;
							list[2] = 3;
						}
					</code></pre>
					<p>Some commentary about the above code:</p>
					<ul>
						<li>The code <span class="monoText">malloc(3 * sizeof(int))</span> tells C to allocate three times the size of an <span class="monoText">int</span>. This precisely how arrays are created when we write <span class="monoText">array[sizeOfArray]</span>. The return from <span class="monoText">malloc(3 * sizeof(int))</span> is a contiguous block of memory, the size of three times <span class="monoText">int</span>. Accordingly, we have a chunk of memory that's big enough to store three values of type <span class="monoText">int</span>.</li>
						<li>The code telling C to return <span class="monoText">1</span> if the address stored in <span class="monoText">list</span> is <span class="monoText">NULL</span> is provided in accordance with our usual practice of returning error codes.</li>
						<li>Notice that we used square bracket notation to store our values to each of the memory spaces allocated in memory. This is clear demonstration of an interesting aspect of C &mdash; we can use square bracket notation alongside pointers.</li>
					</ul>
					<p>Considering point (3) from the commentary above, the square bracket notation can be rewritten to use exclusively pointers:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;

						int main(void)
						{
							int *list = malloc(3 * sizeof(int));
							if (list == NULL)
							{
								return 1;
							}
							
							*list = 1;
							*(list+1) = 2;
							*(list+2) = 3;
						}
					</code></pre>
					<p>The square bracket notation, however, is much more readable.</p>
					<p>Note the problem with this code: We cannot add a fourth value to the list. We have <span class="monoText">1, 2, 3</span>, but if we received a new value, say <span class="monoText">4</span>, we cannot insert that into the list. We obviously could just rewrite our code to accomodate a fourth value, but that is impractical when we have continuous streams of data quickly returning hundreds, if not thousands, of values. The remedy is to make sure our code dynamically allocates memory:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;

						int main(void)
						{
							int *list = malloc(3 * sizeof(int));
							if (list == NULL)
							{
								return 1;
							}
							
							*list = 1;
							*(list+1) = 2;
							*(list+2) = 3;

							int *tmp = malloc(4 * sizeof(int));
							if (tmp == NULL)
							{
								free(list);
								return 1;
							}

							for (int i = 0; i < 3; i++)
							{
								tmp[i] = list[i];
							}

							tmp[3] = 4;

							free(list);

							list = tmp;

							for (int i = 0; i < 4; i++)
							{
								printf("%i\n", list[i]);
							}

							free(list);
						}
					</code></pre>
					<p>In the code above, we allocated another block of memory, four times the size of <span class="monoText">int</span>. We then store the address for that allocated block in a temporary pointer variable called <span class="monoText">tmp</span>. Next, we checked if the address stored in <span class="monoText">tmp</span> is <span class="monoText">NULL</span>. If it is, <span class="monoText">free()</span> the entire block of memory allocated to <span class="monoText">list</span>, and <span class="monoText">return 1</span>.</p>
					<p>If, however, the address is not <span class="monoText">NULL</span> (i.e., a valid address), copy the contents of <span class="monoText">list[i]</span> into <span class="monoText">tmp[i]</span>. Then, in the array <span class="monoText">tmp</span>, store the value <span class="monoText">4</span> at the end (<span class="monoText">tmp[3] = 4</span>).</p>
					<p>Because we copied the contents of <span class="monoText">list</span> into <span class="monoText">tmp</span>, we should <span class="monoText">free()</span> the memory allocated to <span class="monoText">list</span>. Then, we told C that the variable <span class="monoText">list</span> stores the values in <span class="monoText">tmp</span>. Finally, at the very end, we print out each of the values in <span class="monoText">list</span>. Compiling:</p>
					<pre class="command-line language-bash" data-output=""><code>
						make list
						./list
						1
						2
						3
						4
					</code></pre>
					<p>It compiled just fine. Notice, however, how much work it took just to insert a value we did not expect. Whenever we use square bracket notation to create an array, we are trapped with the size we initially asked for. This is because square bracket notation <span class="italicsText">statically allocates</span> memory for the array, and more specifically, memory on the <span class="italicsText">stack</span>. The array itself is being placed in the <span class="italicsText">frame</span> belonging to the function creating the array.</p>
					<p>If, however, we use <span class="monoText">malloc()</span>, the memory allocated for the array comes from the <span class="italicsText">heap</span>, rather than the stack. The memory comes from the heap, we can resize our allocated memory &mdash; taking more off, and returning, memory back and forth. In fact, because we can resize the memory allocated in the heap, we can use a special function called <span class="monoText">realloc()</span> that shortens the code we've written above:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;

						int main(void)
						{
							int *list = malloc(3 * sizeof(int));
							if (list == NULL)
							{
								return 1;
							}
							
							*list = 1;
							*(list+1) = 2;
							*(list+2) = 3;

							// reallocate list
							int *tmp = realloc(list, 4 * sizeof(int));
							if (tmp == NULL)
							{
								free(list);
								return 1;
							}

							tmp[3] = 4;

							free(list);

							list = tmp;

							for (int i = 0; i < 4; i++)
							{
								printf("%i\n", list[i]);
							}

							free(list);
						}
					</code></pre>
					<p>The <span class="monoText">realloc()</span> function takes two arguments: (1) the address of the chunk of memory already allocated, and (2) the new size of the chunk we want. Thus, by writing <span class="monoText">realloc(list, 4 * sizeof(int))</span>, we tell C, "Change the size of <span class="monoText">list</span> to be of size <span class="monoText">4</span> times the size of the data type <span class="monoText">int</span>.</p>
					<p>Assuming all goes well, <span class="monoText">realloc()</span> will resize the allocated memory, and return the address of the new, resized chunk of memory. Otherwise, it returns <span class="monoText">NULL</span>, which is what we check for.</p>
					<p>If <span class="monoText">realloc()</span> returns a valid address, then we no longer have to loop through <span class="monoText">list</span> and copy its contents into <span class="monoText">tmp</span>. <span class="monoText">realloc()</span> will copy the contents of the old chunk of memory into the new chunk of memory.</p>
				</section>

				<section id="linked_list_in_practice" class="grid-item">
					<h4>Linked Lists in Practice</h4>
					<p>Now that we've seen how cumbersome arrays can be, let's implement a linked list in C:</p>
					<pre class="language-c"><code>
						#include &lt;stdio.h&gt;
						#include &lt;stdlib.h&gt;

						// Create the data structured "node"
						typedef struct node
						{
							int number;
							struct node *next;
						}
						node;

						int main(void)
						{
						/*
						Create the empty linked list. Assign to list the value NULL, because we do not want the pointer to a point anywhere in memory, leading to potential Segmentation faults.
						*/

							node *list = NULL;

						/*
						Now we create a node, and ask malloc() to allocate for us memory to store that node. Unlike what we did with arrays, we are allocating memory for individual nodes, rather than memory for individual ints. Inside of those nodes is enough room for an int and another pointer to another node. The sizeof() operator figures out how much space is needed to store an int and a pointer, based on our typedef definition above.
						*/

							node *n = malloc(sizeof(node));

						// Check if the pointer n is NULL -- if it is, end.

							if (n == NULL)
							{
								return 1;
							}

						// Go into the node n, then into its number field, and assign it the value 1

							n->number = 1;

						// Then go into the node n, then into its next field, and assign it the value NULL

							n->next = NULL;

						// Now update list to point to the address stored in n

							list = n;

						// Now let's add the number 2 to the list

							n = malloc(sizeof(node));
							if (n == NULL)
							{
								free(list);
								return 1;
							}
							n->number = 2;
							n->next = NULL;
							list->next = n;

							n = malloc(sizeof(node));
							if (n == NULL)
							{
								free(list->next);
								free(list);
								return 1;
							}
							n->number = 3;
							n->next = NULL;
							list->next->next = n;

						// Now let's print out these values
						/*
						Note that the loop below looks very different from what we're used to. This is because we're no longer using integers. We're using pointers. Thus: "node *tmp = list" tells C, make a temporary pointer that points at list. Then, as long as tmp is not NULL, keep executing the code below. On each iteration of the loop, update the temporary pointer so that it is whatever the value of the temporary pointer's "next" field is.
						*/
							
							for (node *tmp = list; tmp != NULL; tmp = tmp->next)
							{
								printf("%i\n", tmp->number);
							}
						// Now we should free the entire list
						/*
						In the code below, we tell C, perform the following as long as the address stored in list is not NULL. If it is not NULL, then: First, give us a temporary pointer called tmp, and have it point not to the first node, but the next node. We want a temporary pointer because if we free the first node without having C remember where the next node is, we have no way of remembering where the second node is. Having a temporary pointer point to the next node ensures that we do not lose track of where the next node is.
						
						Then we tell C, free list -- the first node.

						After that first node is free, update list to equal the variable tmp, and continue the loop. 
						*/
							
							while (list != NULL)
							{
								node *tmp = list->next;
								free(list);
								list = tmp;
							}
						}
					</code></pre>
					<p>Compiling:</p>
					<pre class="command-line language-bash" data-output=""><code>
						make list
						./list
						1
						2
						3
					</code></pre>
				</section>

				<section id="summarizing_linked_lists">
					<h4>Summarizing the Steps to Creating Linked Lists</h4>
					<p>Let's summarize linked lists and how to create them. A linked list consists of <span class="italicsText">nodes</span>. That node is a <span class="monoText">struct</span>. A <span class="monoText">struct</span> is a collection of (usually different) data types and values. With linked lists, a node consists of two things:</p>
					<ol>
						<li>the <span class="italicsText">data type</span> for the actual data values we want to store (it could be an <span class="monoText">int</span>, <span class="monoText">char</span>, <span class="monoText">float</span>, <span class="monoText">double</span>, etc.); and</li>
						<li>a <span class="italicsText">pointer</span> pointing to another node of the same <span class="italicsText">type</span>.</li>
					</ol>
					<p>Because linked lists consist of nodes, we must first create the node. To create a linked list node in C, we use <span class="monoText">typedef</span>. The general syntax:</p>
					<pre class="language-c"><code>
						typedef struct temp
						{
							dataType val;
							struct temp* next;
						}
						listNode;
					</code></pre>
					<p>First, notice what's inside our <span class="monoText">typdef struct</span>: (1) the data type for the actual value want to store (<span class="monoText">dataType val</span>); and (2) the pointer pointing to another node (<span class="monoText">listNode</span>) in the linked list (<span class="monoText">struct linkedList* next</span>).</p>
					<p>Second, notice that this is a <span class="italicsText">self-referential</span> <span class="monoText">struct</span>. The pointer inside node is defined as pointing to another node, which is itself defined as pointing to another node. Because it's a self-referential <span class="monoText">struct</span>, there's a catch. We're calling this <span class="monoText">struct</span> <span class="monoText">listNode</span>, but we cannot reference <span class="monoText">listNode</span> inside <span class="monoText">listNode</span>'s definition itself, because <span class="monoText">listNode</span> does not occur until the very last line. As such, we must give <span class="monoText">listNode</span> a temporary name. In the syntax above, we gave it the temporary name <span class="monoText">struct temp*</span>. By giving it the temporary name <span class="monoText">struct temp*</span>, our definition can say, "I want a pointer to another <span class="monoText">struct temp*</span>." This completes our definition, and we can now use <span class="monoText">listNode</span>. We've created a node. Now let's make the linked list.</p>
					<p>To create the linked list, we start with the following syntax:</p>
					<pre class="language-c"><code>
						listNode* create(dataType val;)
					</code></pre>
					<p>The above syntax indicates a function. It takes one argument &mdash; the actual data we want to store in the linked list. Its return value is <span class="monoText">listNode</span>, a pointer to that node in our linked list. The first time we run this function, it will generate the first node in our linked list. The code above involves the following steps:</p>
					<ol>
						<li>Use <span class="monoText">malloc()</span> to dynamically allocating space for a new <span class="monoText">listNode</span>.</li>
						<li>Check to make sure we do not run out of memory (using an <span class="monoText">if</span> statement).</li>
						<li>Initialize the node's <span class="monoText">val</span> field.</li>
						<li>Initialize the node's <span class="monoText">next</span> field.</li>
						<li>Return a pointer to the newly created <span class="monoText">listNode</span>.</li>
					</ol>
					<p>For example, using actual values:</p>
					<pre class="language-c"><code>
						listNode* new = create(6);
					</code></pre>
					<p>The code above accomplishes steps 1 through 3 (relevant code inside the <span class="monoText">create()</span> function's definition). But, since this is our first node, the <span class="monoText">next</span> field doesn't point to anything, since there are no other nodes. Because there are no other nodes, the <span class="monoText">next</span> field points to <span class="monoText">NULL</span>.</p>
					<p>Finally, we give the return value from this function (again, the return value is a node) the name <span class="monoText">new</span>, so we can refer to it when we have future nodes. This gives us our first node. And once we have our first node, we have a linked list to work with, since the next node point to our first node.</p>
					<p>Now let's insert a new node into the linked list. To do so, we use the following syntax:</p>
					<pre class="language-c"><code>
						listNode* insert(listNode* head, dataType val);
					</code></pre>
					<p>The above syntax indicates a function, <span class="monoText">insert()</span>. The <span class="monoText">insert()</span> function returns a new <span class="monoText">listNode</span>. But, we do not want a mere node somewhere in memory. We want the node chained to an existing node. Thus, we pass two arguments into the function: (1) the linked lists's <span class="monoText">head</span> and (2) the actual data value we want to store. The function <span class="monoText">insert()</span> returns a pointer to the <span class="italicsText">new head</span> of the linked list. The head in a linked list is almost always the last value we inserted (assuming we aren't doing any sorting).</p>
					<p>The <span class="monoText">insert()</span> function involves the following steps:</p>
					<ol>
						<li>Use <span class="monoText">malloc()</span> to allocate space for a new <span class="monoText">listNode</span>.</li>
						<li>Check to make sure the pointer does not point to <span class="monoText">NULL</span>.</li>
						<li>Initialize the node's <span class="monoText">val</span> field.</li>
						<li>Initialize the node's <span class="monoText">next</span> field.</li>
						<li>Insert the node at the <span class="italicsText">beginning</span> of the linked list. We want to insert the new node at the beginning of the list because inserting it to the end of the list would take $n$ steps, where $n$ is the number of nodes in the list before inserting the new node &mdash; an action that would have an upper bound running time of ${O(n).}$</li>
						<ul>
							<li>This step is the riskiest. We always, <span class="italicsText">always</span>, must ensure that the new node points to the current head <span class="italicsText">before</span> making it the new head (<span class="monoText">list = insert(list, dataType val)</span>. This is because we do not want to orphan the other nodes in the list.</li>
						</ul>
						<li>Return a pointer to the new head of the linked list (the node we just inserted).</li>
					</ol>
					<p>Next, let's say we have a long chain of nodes in our linked list. How do we find the value we're looking for along this chain? We use this syntax:</p>
					<pre class="language-c"><code>
						bool find(listNode* head, dataType val);
					</code></pre>
					<p>This is a search function. It's return value is <span class="monoText">bool</span> &mdash; it returns <span class="monoText">true</span> if the value is found, and <span class="monoText">false</span> if the value is not found. The first argument we pass is a <span class="italicsText">pointer</span> to the linked list. The second argument we pass is the actual value we're looking for. The first argument is so important (since its how we find the linked list in the first place) that it's best to place the pointer to the linked list in a global variable. This way, we can easily refer to all of the other elements in the linked list by just following the chain, starting from the beginning of the linked list.</p>
					<p>Writing the search function above consists of several steps:</p>
					<ol>
						<li>Write a <span class="italicsText">traversal pointer</span> &mdash; a pointer that points to the list's head (this should be a a different variable; we should only pass the global variable as an argument, then assign that global variable to a locally-scoped variable in our function's definition; this way, the global variable is unaffected by whatever it is we're doing with the linked list). We can call this pointer <span class="monoText">trav</span>. Note that when we create <span class="monoText">trav</span>, we do not need to <span class="monoText">malloc()</span> any space (e.g., <span class="monoText">trav = malloc()</span>). We do not <span class="monoText">malloc()</span> anything for <span class="monoText">trav</span> because that space in memory already exists (the list's head already exists). All we're doing by writing <span class="monoText">trav</span> is creating another pointer to the list's head.</li>
						<li>Once we have a variable pointing to the list's head, we can then run through the chain, checking each node. If the current node's <span class="monoText">val</span> field contains a value <span class="monoText">==</span> to the value we're looking for, return the <span class="monoText">bool</span> value <span class="monoText">true</span>.</li>
						<li>If not, we set the traversal pointer to the next node in the list (<span class="monoText">trav = trav->next</span>), and go back to step (2).</li>
						<li>If we run through, or traverse, the entire chain and find no match, report a failure (e.g., <span class="monoText">return 1</span>).</li>
					</ol>
					<p>Finally, let's say we want to get rid of the entire linked list. To do so, we would use something like this:</p>
					<pre class="language-c"><code>
						void destroy(listNode* head);
					</code></pre>
					<p>The <span class="monoText">destroy()</span> functions involves the following:</p>
					<ol>
						<li>Check if we've reached the <span class="monoText">NULL</span> pointer (the list's <span class="italicsText">tail</span>). If we have, stop. Otherwise, keep going.</li>
						<li><span class="monoText">free()</span> the rest of the list. Note that this step is recursive. Say we have a linked list of <span class="monoText">[1]--[9]--[7]</span>. The pointer <span class="monoText">list</span> currently points to node <span class="monoText">[1]</span>. <span class="monoText">destroy()</span> goes to <span class="monoText">[1]</span>, and <span class="monoText">[1]</span> says, "Destroy the rest of the list, then come back and destroy me." The pointer <span class="monoText">list</span> next points to <span class="monoText">[9]</span>. So, <span class="monoText">destroy()</span> goes to <span class="monoText">[9]</span>, which says, "Destroy the rest of the list, then come back and destroy me." The pointer <span class="monoText">list</span> finaly goes to <span class="monoText">[7]</span>, which says "Destroy rest of the list, then come back and destroy me." This is the last node in our list, so <span class="monoText">list</span> now points to the <span class="monoText">NULL</span> value in <span class="monoText">[7]</span>. <span class="monoText">destroy()</span> has reached a <span class="monoText">NULL</span> pointer, so it stops. Now we go to the next step.</li>
						<li><span class="monoText">free()</span> the current node. The current node is <span class="monoText">[7]</span>, so we <span class="monoText">free()</span> that node. The next node is <span class="monoText">[9]</span>, so <span class="monoText">free()</span> that node. Then the next and final node is <span class="monoText">[1]</span>, so we <span class="monoText">free()</span> that node. The entire list has been deleted.</li>
					</ol>
				</section>

				<section id="two_dimensional_linked_lists" class="grid-item">
					<h4>Two Dimensional Linked Lists</h4>
					<p>Suppose that we had a linked list with the individual nodes linked to non-sequential numbers:</p>
					<figure><img src="images/unordered_linked_list.svg" alt="unordered linked list" class="fifty-p" loading="lazy"></figure>
					<p>If we want to insert more numbers into the list, but in sorted order, we must first consider the way we insert more numbers in the first place. More specifically, we must think about the way we insert more numbers into the <span class="italicsText">middle</span> of the list.</p>
					<p>If we want to add the number <span class="monoText">1</span>, we can write:</p>
					<pre class="language-c"><code>
						node *n = malloc(sizeof(node));
						if (n != NULL)
						{
							n->number = 1;
							n->next = NULL;
						}
					</code></pre>
					<p>By writing the above, we have a node containing the <span class="monoText">int 1</span> somewhere in memory. We do not know where, but we know it exists. Because we know it exists, the next step is to link it to some other node in our list. If we want the node to appear before the node containing <span class="monoText">2</span>, we should have <span class="monoText">list</span> link first to the node containing <span class="monoText">1</span> then have the node containing <span class="monoText">1</span> link to the node containing <span class="monoText">2</span>. <span class="boldItalics">But</span> there's a problem. By linking <span class="monoText">list</span> to the node containing <span class="monoText">1</span> first, we will completely cut off the nodes containing <span class="monoText">2</span>, <span class="monoText">4</span>, and <span class="monoText">7</span>. We've effectively <span class="italicsText">orphaned</span> the nodes &mdash; forgetting where they are. This leads a substantial memory leak, increasing the likelihood and risk of our program crashing.</p>
					<p>To prevent this from happening, we need to ensure that we have some way of ensuring that C remembers where the original first node &mdash; the node containing <span class="monoText">2</span> &mdash; is in memory.</p>
					<p>One way to do this is to have the new node &mdash; the node containing <span class="monoText">1</span> &mdash; point to the original first node &mdash; the node containing <span class="monoText">2</span>. Once we have the new node pointing to the original node, we effectively have two pointers pointing to the node containing <span class="monoText">2</span>: (1) <span class="monoText">list</span> and (2) the new node containing <span class="monoText">1</span>. We can then rearrange the pointers: (1) only the node containing <span class="monoText">1</span> points to the node containing <span class="monoText">2</span>, and (2) <span class="monoText">list</span> will point to the node containing <span class="monoText">1</span>. Visualizing this process:</p>
					<figure><img src="images/inserting_into_unordered_linked_list.svg" alt="inserting into unordered list" class="thirty-p" loading="lazy"></figure>
					<p>Accordingly, the correct way to insert the node containing <span class="monoText">1</span> into the linked list would be to start at <span class="monoText">node n</span> and update its <span class="monoText">next</span> field to <span class="monoText">list</span> (ensuring that <span class="monoText">n</span> points to the node that <span class="monoText">list</span> originally pointed to, and then update <span class="monoText">list</span> to point at the new node containing <span class="monoText">1</span>.</p>
					<pre class="language-c"><code>
						n->next = list;
						list = n;
					</code></pre>
					<p>Now let's say we have another data value, <span class="monoText">3</span>. We want to insert this value into the linked list, but more specifically, before the node containing <span class="monoText">4</span>. First, we <span class="monoText">malloc()</span> memory for another node. Similar to inserting the node containing <span class="monoText">1</span>, we do not want to orphan the remaining nodes by simply having the node containing <span class="monoText">2</span> point to the new node containing <span class="monoText">3</span>. We must first have both (a) the new node containing <span class="monoText">3</span>, and (b) the new node containing <span class="monoText">2</span>, point to the node containing <span class="monoText">4</span>. Only after we have both nodes pointing to the node containing <span class="monoText">4</span> do we then have the node containing <span class="monoText">2</span> point to the node containing <span class="monoText">3</span>.</p>
				</section>

				<section id="binary_search_trees" class="grid-item">
					<h4>Binary Search Trees</h4>
					<p>Suppose we had the following array:</p>
					<figure class="math-display">
						<div>
							<p><span class="monoText">[1, 2, 3, 4, 5, 6, 7]</span></p>
						</div>
					</figure>
					<p>Because this array is sorted, we can conduct a <span class="italicsText">binary search</span>. We can start by looking in middle, then go left or right to the halfway point, and repeat the process over and over until we find the value we seek. Binary search on a sorted array is extremely fast &mdash; ${O(\log n).}$</p>
					<p>But recall the problem with using binary search: You need a data structure like an array, where the values are contiguous, so you have <span class="italicsText">random access</span> to the values inside the array in constant time. With linked lists, none of the stored data values are contiguous, so we lose the ability to access values randomly in constant time. Is there a better data structure?</p>
					<p>Notice that with arrays, the values are arranged in just one dimension &mdash; left to right and vice versa. What if instead we made a data structure consisting of two dimensions, left to right, up to down? Compared to arrays:</p>
					<figure><img src="images/array_versus_tree.svg" alt="array v tree" class="forty-p" loading="lazy"></figure>
					<p>Is such a data structure possible? Well, we just saw with linked lists that we can connect values in memory with pointers. Moreover, we can connect them together in whatever order with nodes. Because we have that ability, we can certainly make a data structure with both length <span class="italicsText">and</span> width &mdash; a binary search tree.</p>
					<p>The arrangement of the numbers above is not random. Notice the pattern. The number <span class="monoText">4</span> is at the very top of the tree. Compare that with the array: The <span class="monoText">int 4</span> is at the very middle of the array. On the left half of the array, the middle value is the <span class="monoText">2</span>. On the right half of the array, the middle value is <span class="monoText">6</span>. Note that it does not necessarily mean that the branches must stem from a middle value. We can generalize the pattern more broadly: If we select any node in the tree and the node has children, its left child will be less than the node's value, and its right child will be greater than the node's value.</p>
					<p>Based on the generalized pattern's statement, we can see that binary search trees are <span class="italicsText">recursive data structures</span>. The binary search tree is a tree itself. But if we look at the node containing <span class="monoText">4</span>, that node is a tree as well, containing the nodes containing <span class="monoText">2</span> and <span class="monoText">6</span>. And if we look at the nodes containing <span class="monoText">2</span> and <span class="monoText">6</span>, they too are trees &mdash; the node containing <span class="monoText">2</span> containing the nodes containing <span class="monoText">1</span> and <span class="monoText">3</span> respectively, and the node containing <span class="monoText">6</span> containing the nodes containing <span class="monoText">5</span> and <span class="monoText">7</span> respectively. This phenomenon of a tree inside a tree inside a tree follows directly from the generalized pattern's definition. And where there is a recursive data structure, there is recursive code to be written.</p>
					<p>Binary trees provide the dynamic memory allocation we saw with linked lists <span class="italicsText">and</span> the random access ability of arrays. Say we wanted to find the number <span class="monoText">5</span>. We would start at the number <span class="monoText">4</span>, the <span class="boldItalics">root</span>, and ask, is <span class="monoText">3 < 4</span>? Yes, so we go to the left, because <span class="monoText">6</span> is greater than <span class="monoText">4</span> and <span class="monoText">2</span> is less than <span class="monoText">4</span>. Once at <span class="monoText">2</span> we can see that <span class="monoText">3</span> is right there.</p>
				</section>

				<section id="implementing_a_binary_search_tree_in_C" class="grid-item">
					<h4>Implementing a Binary Search Tree in C</h4>
					<p>Let's implement a binary search tree in C. In the section on linked lists, we wrote the following code for our nodes:</p>
					<pre class="language-c"><code>
						typedef struct node
						{
							int number;
							struct node *next;
						}
						node;
					</code></pre>
					<p>In that code, we only had one pointer for the node. With binary search trees, we want two pointers, since a node with children needs two pointers:</p>
					<pre class="language-c"><code>
						typedef struct node
						{
							int number;
							struct node *left;
							struct node *right;
						}
						node
					</code></pre>
					<p>With our node defined, let's begin designing the overall tree. First, let's think about how we would search the tree. We want to search from the root, going down. What do we want as a return value if the value we're looking for is found? Well, it should return <span class="monoText">true</span> or <span class="monoText">false</span>. Thus, we'll set the <span class="monoText">return type</span> for our search function to be <span class="monoText">bool</span>. Now, what arguments would our search function take? Well, it should obviously take as an argument the number we're looking for, we'll call it <span class="monoText">number</span>. It should also take as an argument a pointer to a node. We'll call that pointer <span class="monoText">tree</span>:</p>
					<pre class="language-c"><code>
						bool search(node *tree, int number)
						{

						}
					</code></pre>
					<p>Now, we should check to make sure that our pointer argument is not pointing at <span class="monoText">NULL</span>. If the pointer points at <span class="monoText">NULL</span>, then the value we're looking for, <span class="monoText">number</span>, is clearly not in the tree, so we should return <span class="monoText">false</span>.</p>
					<pre class="language-c"><code>
						bool search(node *tree, int number)
						{
							if (tree == NULL)
							{
								return false;
							}
						}
					</code></pre>
					<p>If, however, the <span class="monoText">tree</span> does not point to <span class="monoText">NULL</span>, i.e., it points to a valid address, then do the following: Go to where <span class="monoText">tree</span> is stored, and look inside its <span class="monoText">number</span> field. If the number we're looking for, <span class="monoText">number</span>, is <span class="italicsText">less than</span> that number inside <span class="monoText">tree</span>, then execute this function: <span class="monoText">search(tree->left, number)</span>:</p>
					<pre class="language-c"><code>
						bool search(node *tree, int number)
						{
							if (tree == NULL)
							{
								return false;
							}
							else if (number < tree->number)
							{
								return search(tree->left, number);
							}
						}
					</code></pre>
					<p>Otherwise, if the number we're looking for, <span class="monoText">number</span> is <span class="italicsText">greater than</span> that number inside <span class="monoText">tree</span>, then execute this function: <span class="monoText">search(tree->right, number)</span>:</p>
					<pre class="language-c"><code>
						bool search(node *tree, int number)
						{
							if (tree == NULL)
							{
								return false;
							}
							else if (number < tree->number)
							{
								return search(tree->left, number);
							}
							else if (number > tree->number)
							{
								return search(tree->right, number);
							}
						}
					</code></pre>
					<p>Notice how we're using our <span class="monoText">search()</span> function inside <span class="monoText">search()</span> itself. This is crystal clear example of recursion. As in previous examples of recursion, we need not worry about the function executing forever, because we've included a base case <span class="monoText">if (tree == NULL) { return false; }</span>. There is, however, one final case we've forgotten to check for: When the number inside <span class="monoText">tree</span> itself is the number we're looking for:</p>
					<pre class="language-c"><code>
						bool search(node *tree, int number)
						{
							if (tree == NULL)
							{
								return false;
							}
							else if (number < tree->number)
							{
								return search(tree->left, number);
							}
							else if (number > tree->number)
							{
								return search(tree->right, number);
							}
							else
							{
								return true;
							}
						}
					</code></pre>
				</section>

				<section id="the_downsides_of_binary_search_trees" class="grid-item">
					<h4>The Costs of Binary Search Trees</h4>
					<p>The most obvious problem with binary search trees is that they require twice as many pointers as linked lists. With enough values, this can very quickly lead to substantial memory usage.</p>
					<p>An addition cost associated with binary search trees is that insertion is no longer in constant time. We cannot just simply insert new data values before the tree's root and expect it to simply push the values further down. To illustrate, consider the tree in the previous section. Suppose we wanted to insert the number <span class="monoText">8</span> into the tree. If we inserted <span class="monoText">8</span>, it would go towards the right, since <span class="monoText">8 > 4</span>. So, we go to <span class="monoText">6</span>. Then we see that <span class="monoText">8 > 6</span>, so it goes right again. We go to <span class="monoText">7</span>. We see that <span class="monoText">8 > 7</span>, so it goes right again, reaching its final place. This took a total of 3 steps. Assuming that the binary search tree is balanced and laid out well like the previous section's tree, the height of that tree will be ${\log n,}$ where $n$ is the total number of nodes.</p>
					<p>But what if instead we began by inserting <span class="monoText">1</span>, <span class="monoText">2</span>, and <span class="monoText">3</span>, such that we end up with <span class="monoText">1</span> connected to <span class="monoText">2</span> and <span class="monoText">2</span> connected to <span class="monoText">3</span> in a linear order:</p>
					<figure><img src="images/sloppy_binary_search_tree.svg" alt="sloppy binary search tree" class="twenty-p" loading="lazy"></figure>
					<p>The tree above meets the definition of a binary search tree. The nodes are arranged according to the general pattern. If we look closely, however, this looks oddly similar to a linked list. In fact, this data structure is both a linked list and a binary search tree. This is not an unusual occurrence. Often times, whether by poor design, poor planning, or just plain bad luck in the amount of data received, a data structure can quickly devolve into some other data structure entirely.</p>
					<p>Is there a way to prevent the above from occurring? Well, the most obvious way is to ensure that <span class="monoText">2</span> is the tree's root, rather than just haphazardly inserting the data values.</p>
					<figure><img src="images/rearrange_sloppy_tree.svg" alt="rearranged tree" class="twenty-p" loading="lazy"></figure>
					<p>In fact, this is the solution to this problem with binary trees. While binary search trees are attractive, there's a potentially even better data structure &mdash; <span class="italicsText">hash tables</span>.</p>
				</section>

				<section id="hash_tables" class="grid-item">
					<h4>Hash Tables</h4>
					<p>A <span class="boldItalics">hash table</span> is a data structure that's essentially an array of linked lists. Suppose we wanted a data structure containing more than just numbers: strings. More specifically, a data structure containing the names of particular individuals, and their associated data. It would be great if we could search for a person by name and retrieve their relevant data in constant time.</p>

					<p>Let's start first by considering an array consisting of 26 elements (26 because there are 26 letters in the English alphabet). We will think of each the elements as representing the letters A through Z. Now let's say that when we insert a new individual's data into the data structure, we'll put them into a specific location inside the array that has some sort of relationship with the name itself. For example, an individual named Ayuri would be stored in element with index <span class="monoText">0</span>, which represents the letter A. An individual named Veer would be stored in element with index <span class="monoText">21</span>, which represents the letter V, and so on and so forth. This would look like the following:</p>

					<p>What's the problem with this data structure? Well, let's say we have another individual named Vivian. That individual would have to go into the element with index <span class="monoText">21</span>, but Veer already occupies that space. We don't really have a good way to deal with this, since we're using an array.</p>

					<p>But, what if we made each element in the array store a linked list? This would allow us to keep the array at size 26, so that each element corresponds to 26 letters. We could have the element of index 21 store the linked list containing the nodes with Veer, Vivian, and future names starting with V. It would take an extra step to find Vivian and further extra steps to find those after Vivian, but it is a much better solution than having to concoct some algorithm for calculating how the letters should change in response to the array increasing. In doing so, the structure looks something like this:</p>

					<figure><img src="images/hash_table.svg" alt="hash table" class="thirty-p" loading="lazy"></figure>

					<p>This data structure, an array of linked lists, is a <span class="italicsText">hash table</span>. To understand hash tables, we first need to understand <span class="italicsText">hash functions</span>.</p>
				</section>

				<section id="hash_functions" class="grid-item">
					<h5>Hash Functions</h5>
					<p>A <span class="boldItalics">hash function</span> is a function that places data values in their appropriate places in a hash table deterministically. More specifically, a hash function takes as input a particular <span class="monoText">string</span>, and returns as output a particular number, called a <span class="boldItalics">hash code</span>. That hash code represents where in the array the data value is placed. In our example data structure above, the hash function takes as input a person's <span class="italicsText">name</span>, and returns as output some <span class="monoText">int</span> between <span class="monoText">0</span> and <span class="monoText">25</span>.</p>
					<p>For example, in our 26 element array, the name <span class="monoText">Zach</span> could return the hash code <span class="monoText">25</span>, which represents the letter <span class="monoText">Z</span>. The code might look something like:</p>
					<pre class="language-c"><code>
						int x = hash("Zach");
						// x is now 25
						hashtable[x] = "Zach";
					</code></pre>
					<p>There are numerous ways to write hash functions. Generally, however, there are several good practices:</p>
					<ol>
						<li>A hash function should use <span class="italicsText">only</span> the data to be hashed and it should use <span class="italicsText">all</span> of it.</li>
						<li>The hash function should be deterministic &mdash; if we passed the exact same data into the function, we should get back the exact same hash code. E.g., if we passed <span class="monoText">Zach</span> into the hash function, we should get back the hash code <span class="monoText">25</span> every single time.</li>
						<li>The hash function should uniformly distribute data &mdash; it should enough of a range to spread data (we do not want long chains).</li>
						<li>The hash function should generate very different hash codes for very similar data.</li>
					</ol>
					<p>Here is one example of a hash function:</p>
					<pre class="language-c"><code>
						unsigned int hash(char* str)
						{
							int asciiSum = 0;
							for (int hashData = 0; str[hashData] != '\0'; hashData++)
							{
								asciiSum += str[hashData];
							}
							return asciiSum % hashArraySize;
						}
					</code></pre>
					<p>The hash function above adds all of the ASCII values of the string data we want to hash (<span class="monoText">hashData</span>), modded by the value <span class="monoText">hashArraySize</span>, which represents the size of the hash table's array.</p>
					<p>Note that we generally do not want to write our own hash functions. They are more of an art than anything else, and there are already numerous hash functions on the internet. As with all things in programming, err on not reinventing the wheel. Of course, whenever we use such code, we should <span class="underlineText">always</span> cite our sources. The computer science community thrives on open source, and that's only possible if we give attribution to those who put in the labor.</p>
				</section>

				<section id="hash_function_collisions" class="grid-item">
					<h6>Hash Function Collisions</h6>
					<p>Suppose we're just using an array. We can use a hash function to determine which element in the array a data value goes into. With just an array and hash functions, we have a significant risk &mdash; <span class="boldItalics">hash collisions</span>. A hash collision occurs when we pass two data values into a hash function, and the function passes the same hash code. We never want to encounter collisions with hash functions &mdash; they can easily wreak havoc on our hash table by overwriting data already inside our function.</p>
					<p>Fortunately, collisions aren't the end of the world. We can use a technique called <span class="boldItalics">linear probing</span> to resolve collisions: When a collision occurs, we try and place the data in the next consecutive element in the array (going around to the beginning if necessary) until we find a vacancy, where we can place the value.</p>
					<p>The problem with linear probing, however, is that it can lead to a problem called <span class="boldItalics">clustering</span>. We keep looking for spaces to place data to the point where our data values are too far apart from one another. And the farther apart they are, the longer it will take to search for data.</p>
					<p>A better method for resolving collisions is with <span class="boldItalics">chaining</span> &mdash; instead of using just storing data into elements inside the hash table's array, we have each element inside the array point to the head of a <span class="italicsText">linked list</span>. This way, a hash function can return the same hash code without causing a collision, since the hash code tells us which linked list the data goes into (which itself can store however much data we want).</p>
				</section>

				<section id="hash_table_costs" class="grid-item">
					<h5>The Costs of Hash Tables</h5>
					<p>One glaring problem with the hash table presented in the preceding section is that the linked lists can easily grow long. If our list stored last names rather than first names and most of the individuals we're concerned with are Korean, the last names Kim and Park would have disproportionately long <span class="boldItalics">chains</span> (the linked lists connected to each element in the array). Some of the names in our array would take just one step to find, while others could easily take hundreds, if not thousands, of steps. What might be a faster way to find these names?</p>

					<p>Well, think about the way the array is structured in the first place. We're running into the problem of long chains because we're only looking at the <span class="italicsText">first letter</span> of the individual's name. We can reduce the length of the chains by making our array longer &mdash; include not just the name's first letter, but the second letter as well. Thus, instead of just having <span class="monoText">0</span> represent the letter <span class="monoText">A</span>, we would have <span class="monoText">0</span> represent the two letters <span class="monoText">AA</span>, <span class="monoText">1</span> represent the two letters <span class="monoText">AB</span>, etc.</p>

					<p>While this would reduce the length of our chains, there are still names that share the same first two letters: John, Johnny, Jon, Joe, Jo, Joann, Joan, Joseph, Josef Jose, Josie, Jolene, etc. So, to reduce these chains, we might want the array to include the first, second, and third letters. Of course, there are names that share the same third letters: Ann, Annie, Anna, Annalyn, etc. So, we might include the fourth letter. All of this, of course, is premised on the idea that the names are what might appear on a birth certificate. We aren't considering <span class="italicsText">usernames</span>: henryvii, henryvi, henrymanywives, henryOfFord, etc.</p>

					<p>This approach comes at a massive cost: memory. At first, our array consisted of just 26 elements. When we include the second letter, that's ${26 \cdot 26 = 676.}$ When we include the third letter, that's ${26 \cdot 26 \cdot 26 = 17,576.}$ If we included the eighth letter, that's ${26^8 = 208,827,064,576.}$ Indeed, as with all data structures, we need to weigh the costs and benefits of using hash tables.</p>

					<p>If we thought about a hash table more carefully, we'd realize that it organizes data in a way we're familiar with. For example, think about the various ways of organizing a deck of cards. Each of the cards has a suit &mdash; hearts, diamonds, spades, and clubs. One way to organize the shuffled deck is to separate the cards into four piles, representing each of the suit, and place each card into their respective pile. The ace of diamonds goes into the diamonds pile; the four of clubs the clubs; the queen of hearts the hearts; etc. This process is precisely how a hash table organizes data &mdash; it <span class="italicsText">hashes</span> values. The act of <span class="italicsText">hashing</span> a value is the act of looking at an input and producing an output, based on some characteristic of that input.</p>

					<p>The benefit of hashing is that we can find a value if we know what "pile" we've placed it in. If we're looking for the knave of spades, we only need to look at the pile of spaces. That pile would contain only 13 cards, so we'd only be looking for 1 card out of 13, rather than 1 card out of 52. Hashing values effectively reduces a problem of size 52 to a problem of size 13 &mdash; it breaks a bigger problem into smaller pieces.</p>

					<p>Thus, when we write hash functions, the goal is to minimize the amount of steps it takes to find a particular value. Minimizing that amount depends directly on how many "piles," in this case elements in the array, we have to separate the values into. But what exactly is the upper bound running time of searching a hash table? How many steps would it take, given $n$ names? Well, the best case scenario is if we have just one name &mdash; ${O(1).}$</p>
				</section>

				<section id="tries_in_C" class="grid-item">
					<h4>Tries</h4>
					<p>One other data structure that could be more useful than a hash table is a <span class="boldItalics">trie</span> (from the middle syllable of re<span class="italicsText">trie</span>val), also known as a <span class="boldItalics">prefix tree</span> or <span class="boldItalics">digital tree</span>. A <span class="italicsText">trie</span> is a type of tree aimed at storing complex pieces of data like strings. At its core, a trie is a tree where each node contains an array, and each of those arrays is an array of pointers to other nodes. (As one might tell, computer scientists are not unlike chefs, meshing things together to make new things).</p>

					<p>In the context of our preceding example attempting to store names, the trie storing the names <span class="monoText">sammy</span>, <span class="monoText">sally</span>, and <span class="monoText">stu</span> would look something like this:</p>

					<figure><img src="images/trie.svg" alt="trie" loading="lazy"></figure>

					<p>Each of the pointers points to another array of letters. We start at the root array. The name <span class="monoText">sammy</span> starts with the letter <span class="monoText">s</span>, so we locate the relevant element, then follow its pointer to the next array. The next letter is <span class="monoText">a</span>, so we locate the relevant element, and follow its pointer to the next array, and so on and so forth.</p>
					<p>Notice, however, that with this data structure, it takes $n$ steps to find a name, where $n$ is the number of letters in the name. It takes $n$ steps to find a match, whether there are twenty or four billion names. This is constant time &mdash; the amount of data stored in a trie has no effect on how long it takes to find a match. Because the time it takes to find a match is constant time, searching a trie effectively has an upper bound running time of ${O(1);}$ in the best case scenario, a name could just be 1 letter.</p>
					<p>Considering that searching tries has a running time of ${O(1),}$ it seems like tries are the end-all-be-all of data structures. But are they? Consider the diagram above (and how much space it takes up on the screen). That entire data structure results from just three names, two of which have shared letters. What if we had a billion names? That's a gargantuan amount of memory. We're storing multiple arrays, each of which contains a pointer. Worse, some of the pointers won't even be used. We aren't just using a substantial amount of memory &mdash; we're wasting it too. The trie is a perfect example of theory versus application. It's the holy grail of data structures, but it simply isn't feasible in practice.</p>
				</section>

				<section id="abstract_data_structures" class="grid-item">
					<h4>Abstract Data Structures</h4>
					<p>Arrays, linked lists, binary search trees, hash tables, and tries provide enough foundational framework for solving higher level problems. We can use them to create other, custom data structures, rearranging and meshing them here and there. In other words, we use them as lower level implementations, or building blocks, to more complex data structures. These structures are called <span class="boldItalics">abstract data structures</span>. One example of an abstract data structure is a <span class="italicsText">queue</span>.</p>
				</section>

				<section id="queues" class="grid-item">
					<h5>Queues</h5>
					<p>In an orderly society, if you're the first one in line (the British "queue"), you're the first to leave the line. In computer science, this concept is called <span class="boldItalics">FIFO</span> (<span class="italicsText">first in, first out</span>). FIFO is the corner stone of the <span class="boldItalics">queue</span> data structure.</p>
					<p>A queue has two core properties: (1) <span class="monoText boldItalics">enqueue</span> (insert, add, get in line) and (2) <span class="monoText boldItalics">dequeue</span> (remove, delete, get out of line). FIFO defines how data enequeues and dequeues &mdash; first in, first out.</p>
					<p>Queues are used all over. For example, when we print something with the school library or company printers, our request goes into a queue. The first person who requested a print out will be the first person who gets their print out.</p>
					<p>How would we implement this in code? Well, we could use an array for each of the "persons" in line. But what would be a downside to using an array? Well, we'd have to come up with a way of removing people from the line. We can't really do that with arrays, at least not dynamically. Removing elements from the array leaves empty spaces at the end of the line. In the real world people just move forward. In computer, data doesn't just move forward unless we tell it to.</p>
				</section>

				<section id="stack_data_structure" class="grid-item">
					<h5>Stacks</h5>
					<p>Another abstract data structure is the <span class="boldItalics">stack</span>. The stack can be thought of as the queue's opposite twin. Instead of following FIFO, the stack follows <span class="boldItalics">LIFO</span> (<span class="italicsText">last in, first out</span>). We can think of LIFO as being similar to a stack of dishes we've left piling in our sink. After some time, we muster enough energy to finally start washing them. Most of us will start by washing the dish at the very top, which is the very last dish we placed. Last in, first out.</p>
					<p>Just as queues have two core properties, stacks also have two core properties: <span class="monoText boldItalics">push</span>  (insert, add, get into the pile) and <span class="monoText boldItalics">pop</span> (remove, delete, get out of the pile). The difference being queues follow FIFO, and stacks follow LIFO.</p>
				</section>

				<section id="dictionaries" class="grid-item">
					<h5>Dictionaries</h5>
					<p>Yet another abstract data structure is the <span class="boldItalics">dictionary</span>. The dictionary data structure is named precisely because it resembles a real world dictionary: The data structure contains <span class="boldItalics">keys</span> assigned with <span class="boldItalics">values</span>, just as a dictionary contains words with their accompanying definitions.</p>
				</section>
			</article>
		</main>
		<!-- Scripts -->
			<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
			<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js " integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
			<script>
				document.addEventListener("DOMContentLoaded", function () {
					renderMathInElement(document.body, {
						// customised options
						// โข auto-render specific keys, e.g.:
						delimiters: [
							{ left: "$$", right: "$$", display: true },
							{ left: "$", right: "$", display: false },
							{ left: "\\(", right: "\\)", display: false },
							{ left: "\\[", right: "\\]", display: true },
						],
						// โข rendering keys, e.g.:
						throwOnError: false,
					});
				});
			</script>
			<!-- <script src="https://unpkg.com/function-plot@1.22.2/dist/function-plot.js"></script> -->
			<script src="js/csfoundations.js"></script>
			<script src="js/prism.js"></script>
	</body>
</html>
